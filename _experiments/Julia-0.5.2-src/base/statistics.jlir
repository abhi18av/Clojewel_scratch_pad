(:quote, (:block,
    (:line, 5, :none),
    "    mean(f::Function, v)\n\nApply the function `f` to each element of `v` and take the mean.\n",
    (:line, 10, :none),
    (:function, (:call, :mean, (:(::), :f, :Callable), :iterable), (:block,
        (:line, 11, :none),
        (:(=), :state, (:call, :start, :iterable)),
        (:line, 12, :none),
        (:if, (:call, :done, :iterable, :state), (:block,
            (:line, 13, :none),
            (:call, :throw, (:call, :ArgumentError, (:string, "mean of empty collection undefined: ", (:call, :repr, :iterable))))
          )),
        (:line, 15, :none),
        (:(=), :count, 1),
        (:line, 16, :none),
        (:(=), (:tuple, :value, :state), (:call, :next, :iterable, :state)),
        (:line, 17, :none),
        (:(=), :f_value, (:call, :f, :value)),
        (:line, 18, :none),
        (:(=), :total, (:call, :+, :f_value, (:call, :zero, :f_value))),
        (:line, 19, :none),
        (:while, (:call, :!, (:call, :done, :iterable, :state)), (:block,
            (:line, 20, :none),
            (:(=), (:tuple, :value, :state), (:call, :next, :iterable, :state)),
            (:line, 21, :none),
            (:+=, :total, (:call, :f, :value)),
            (:line, 22, :none),
            (:+=, :count, 1)
          )),
        (:line, 24, :none),
        (:return, (:call, :/, :total, :count))
      )),
    (:line, 26, :none),
    (:(=), (:call, :mean, :iterable), (:block,
        (:line, 26, :none),
        (:call, :mean, :identity, :iterable)
      )),
    (:line, 27, :none),
    (:(=), (:call, :mean, (:(::), :f, :Callable), (:(::), :A, :AbstractArray)), (:block,
        (:line, 27, :none),
        (:call, :/, (:call, :sum, :f, :A), (:call, :_length, :A))
      )),
    (:line, 28, :none),
    (:(=), (:call, :mean, (:(::), :A, :AbstractArray)), (:block,
        (:line, 28, :none),
        (:call, :/, (:call, :sum, :A), (:call, :_length, :A))
      )),
    (:line, 30, :none),
    (:function, (:call, (:curly, :mean!, :T), (:(::), :R, (:curly, :AbstractArray, :T)), (:(::), :A, :AbstractArray)), (:block,
        (:line, 31, :none),
        (:call, :sum!, (:parameters, (:kw, :init, true)), :R, :A),
        (:line, 32, :none),
        (:call, :scale!, :R, (:call, :/, (:call, :_length, :R), (:call, :_length, :A))),
        (:line, 33, :none),
        (:return, :R)
      )),
    (:line, 36, :none),
    (:(=), (:call, (:curly, :momenttype, :T), (:(::), (:curly, :Type, :T))), (:block,
        (:line, 36, :none),
        (:call, :typeof, (:call, :/, (:call, :+, (:call, :zero, :T), (:call, :zero, :T)), 2))
      )),
    (:line, 37, :none),
    (:(=), (:call, :momenttype, (:(::), (:curly, :Type, :Float32))), (:block,
        (:line, 37, :none),
        :Float32
      )),
    (:line, 38, :none),
    (:(=), (:call, (:curly, :momenttype, (:<:, :T, (:curly, :Union, :Float64, :Int32, :Int64, :UInt32, :UInt64))), (:(::), (:curly, :Type, :T))), (:block,
        (:line, 38, :none),
        :Float64
      )),
    (:line, 40, :none),
    "    mean(v[, region])\n\nCompute the mean of whole array `v`, or optionally along the dimensions in `region`.\n\n!!! note\n    Julia does not ignore `NaN` values in the computation. For applications requiring the\n    handling of missing data, the `DataArrays.jl` package is recommended.\n",
    (:line, 49, :none),
    (:(=), (:call, (:curly, :mean, :T), (:(::), :A, (:curly, :AbstractArray, :T)), :region), (:block,
        (:line, 49, :none),
        (:call, :mean!, (:call, :reducedim_initarray, :A, :region, 0, (:call, :momenttype, :T)), :A)
      )),
    (:line, 56, :none),
    (:(=), (:call, :realXcY, (:(::), :x, :Real), (:(::), :y, :Real)), (:block,
        (:line, 56, :none),
        (:call, :*, :x, :y)
      )),
    (:line, 57, :none),
    (:(=), (:call, :realXcY, (:(::), :x, :Complex), (:(::), :y, :Complex)), (:block,
        (:line, 57, :none),
        (:call, :+, (:call, :*, (:call, :real, :x), (:call, :real, :y)), (:call, :*, (:call, :imag, :x), (:call, :imag, :y)))
      )),
    (:line, 59, :none),
    (:function, (:call, :var, (:parameters, (:kw, (:(::), :corrected, :Bool), true), (:kw, :mean, :nothing)), :iterable), (:block,
        (:line, 60, :none),
        (:(=), :state, (:call, :start, :iterable)),
        (:line, 61, :none),
        (:if, (:call, :done, :iterable, :state), (:block,
            (:line, 62, :none),
            (:call, :throw, (:call, :ArgumentError, (:string, "variance of empty collection undefined: ", (:call, :repr, :iterable))))
          )),
        (:line, 64, :none),
        (:(=), :count, 1),
        (:line, 65, :none),
        (:(=), (:tuple, :value, :state), (:call, :next, :iterable, :state)),
        (:line, 66, :none),
        (:if, (:call, :(===), :mean, :nothing), (:block,
            (:line, 69, :none),
            (:(=), :M, (:call, :/, :value, 1)),
            (:line, 70, :none),
            (:(=), :S, (:call, :real, (:call, :zero, :M))),
            (:line, 71, :none),
            (:while, (:call, :!, (:call, :done, :iterable, :state)), (:block,
                (:line, 72, :none),
                (:(=), (:tuple, :value, :state), (:call, :next, :iterable, :state)),
                (:line, 73, :none),
                (:+=, :count, 1),
                (:line, 74, :none),
                (:(=), :new_M, (:call, :+, :M, (:call, :/, (:call, :-, :value, :M), :count))),
                (:line, 75, :none),
                (:(=), :S, (:call, :+, :S, (:call, :realXcY, (:call, :-, :value, :M), (:call, :-, :value, :new_M)))),
                (:line, 76, :none),
                (:(=), :M, :new_M)
              )),
            (:line, 78, :none),
            (:return, (:call, :/, :S, (:call, :-, :count, (:call, :Int, :corrected))))
          ), (:block,
            (:line, 79, :none),
            (:if, (:call, :isa, :mean, :Number), (:block,
                (:line, 85, :none),
                (:(=), :sum2, (:call, :abs2, (:call, :-, :value, (:(::), :mean, :Number)))),
                (:line, 86, :none),
                (:while, (:call, :!, (:call, :done, :iterable, :state)), (:block,
                    (:line, 87, :none),
                    (:(=), (:tuple, :value, :state), (:call, :next, :iterable, :state)),
                    (:line, 88, :none),
                    (:+=, :count, 1),
                    (:line, 89, :none),
                    (:+=, :sum2, (:call, :abs2, (:call, :-, :value, :mean)))
                  )),
                (:line, 91, :none),
                (:return, (:call, :/, :sum2, (:call, :-, :count, (:call, :Int, :corrected))))
              ), (:block,
                (:line, 93, :none),
                (:call, :throw, (:call, :ArgumentError, (:string, "invalid value of mean, ", :mean, "::", (:call, :typeof, :mean))))
              ))
          ))
      )),
    (:line, 97, :none),
    (:(=), (:call, :centralizedabs2fun, (:(::), :m, :Number)), (:block,
        (:line, 97, :none),
        (:->, :x, (:block,
            (:line, 97, :none),
            (:call, :abs2, (:call, :-, :x, :m))
          ))
      )),
    (:line, 98, :none),
    (:(=), (:call, :centralize_sumabs2, (:(::), :A, :AbstractArray), (:(::), :m, :Number)), (:block,
        (:line, 98, :none),
        (:call, :mapreduce, (:call, :centralizedabs2fun, :m), :+, :A)
      )),
    (:line, 100, :none),
    (:(=), (:call, :centralize_sumabs2, (:(::), :A, :AbstractArray), (:(::), :m, :Number), (:(::), :ifirst, :Int), (:(::), :ilast, :Int)), (:block,
        (:line, 100, :none),
        (:call, :mapreduce_impl, (:call, :centralizedabs2fun, :m), :+, :A, :ifirst, :ilast)
      )),
    (:line, 103, :none),
    (:function, (:call, (:curly, :centralize_sumabs2!, :S, :T, :N), (:(::), :R, (:curly, :AbstractArray, :S)), (:(::), :A, (:curly, :AbstractArray, :T, :N)), (:(::), :means, :AbstractArray)), (:block,
        (:line, 105, :none),
        (:(=), :lsiz, (:call, :check_reducedims, :R, :A)),
        (:line, 106, :none),
        (:||, (:call, :isempty, :R), (:call, :fill!, :R, (:call, :zero, :S))),
        (:line, 107, :none),
        (:&&, (:call, :isempty, :A), (:return, :R)),
        (:line, 109, :none),
        (:if, (:&&, (:call, :has_fast_linear_indexing, :A), (:call, :>, :lsiz, 16)), (:block,
            (:line, 110, :none),
            (:(=), :nslices, (:call, :div, (:call, :_length, :A), :lsiz)),
            (:line, 111, :none),
            (:(=), :ibase, (:call, :-, (:call, :first, (:call, :linearindices, :A)), 1)),
            (:line, 112, :none),
            (:for, (:(=), :i, (:(:), 1, :nslices)), (:block,
                (:line, 113, :none),
                (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :R, :i), (:call, :centralize_sumabs2, :A, (:ref, :means, :i), (:call, :+, :ibase, 1), (:call, :+, :ibase, :lsiz)))),
                (:line, 114, :none),
                (:+=, :ibase, :lsiz)
              )),
            (:line, 116, :none),
            (:return, :R)
          )),
        (:line, 118, :none),
        (:(=), (:tuple, :indsAt, :indsRt), (:tuple, (:call, :safe_tail, (:call, :indices, :A)), (:call, :safe_tail, (:call, :indices, :R)))),
        (:line, 119, :none),
        (:(=), (:tuple, :keep, :Idefault), (:call, (:., :Broadcast, (:quote, #QuoteNode
                :newindexer
              )), :indsAt, :indsRt)),
        (:line, 120, :none),
        (:if, (:call, :reducedim1, :R, :A), (:block,
            (:line, 121, :none),
            (:(=), :i1, (:call, :first, (:call, :indices1, :R))),
            (:line, 122, :none),
            (:macrocall, Symbol("@inbounds"), (:for, (:(=), :IA, (:call, :CartesianRange, :indsAt)), (:block,
                  (:line, 123, :none),
                  (:(=), :IR, (:call, (:., :Broadcast, (:quote, #QuoteNode
                          :newindex
                        )), :IA, :keep, :Idefault)),
                  (:line, 124, :none),
                  (:(=), :r, (:ref, :R, :i1, :IR)),
                  (:line, 125, :none),
                  (:(=), :m, (:ref, :means, :i1, :IR)),
                  (:line, 126, :none),
                  (:macrocall, Symbol("@simd"), (:for, (:(=), :i, (:call, :indices, :A, 1)), (:block,
                        (:line, 127, :none),
                        (:+=, :r, (:call, :abs2, (:call, :-, (:ref, :A, :i, :IA), :m)))
                      ))),
                  (:line, 129, :none),
                  (:(=), (:ref, :R, :i1, :IR), :r)
                )))
          ), (:block,
            (:line, 132, :none),
            (:macrocall, Symbol("@inbounds"), (:for, (:(=), :IA, (:call, :CartesianRange, :indsAt)), (:block,
                  (:line, 133, :none),
                  (:(=), :IR, (:call, (:., :Broadcast, (:quote, #QuoteNode
                          :newindex
                        )), :IA, :keep, :Idefault)),
                  (:line, 134, :none),
                  (:macrocall, Symbol("@simd"), (:for, (:(=), :i, (:call, :indices, :A, 1)), (:block,
                        (:line, 135, :none),
                        (:+=, (:ref, :R, :i, :IR), (:call, :abs2, (:call, :-, (:ref, :A, :i, :IA), (:ref, :means, :i, :IR))))
                      )))
                )))
          )),
        (:line, 139, :none),
        (:return, :R)
      )),
    (:line, 142, :none),
    (:function, (:call, (:curly, :varm, :T), (:parameters, (:kw, (:(::), :corrected, :Bool), true)), (:(::), :A, (:curly, :AbstractArray, :T)), (:(::), :m, :Number)), (:block,
        (:line, 143, :none),
        (:(=), :n, (:call, :_length, :A)),
        (:line, 144, :none),
        (:&&, (:call, :(==), :n, 0), (:return, (:call, :convert, (:call, :real, (:call, :momenttype, :T)), :NaN))),
        (:line, 145, :none),
        (:&&, (:call, :(==), :n, 1), (:return, (:call, :convert, (:call, :real, (:call, :momenttype, :T)), (:call, :/, (:call, :abs2, (:call, :-, (:ref, :A, 1), :m)), (:call, :-, 1, (:call, :Int, :corrected)))))),
        (:line, 146, :none),
        (:return, (:call, :/, (:call, :centralize_sumabs2, :A, :m), (:call, :-, :n, (:call, :Int, :corrected))))
      )),
    (:line, 149, :none),
    (:function, (:call, (:curly, :varm!, :S), (:parameters, (:kw, (:(::), :corrected, :Bool), true)), (:(::), :R, (:curly, :AbstractArray, :S)), (:(::), :A, :AbstractArray), (:(::), :m, :AbstractArray)), (:block,
        (:line, 150, :none),
        (:if, (:call, :isempty, :A), (:block,
            (:line, 151, :none),
            (:call, :fill!, :R, (:call, :convert, :S, :NaN))
          ), (:block,
            (:line, 153, :none),
            (:(=), :rn, (:call, :-, (:call, :div, (:call, :_length, :A), (:call, :_length, :R)), (:call, :Int, :corrected))),
            (:line, 154, :none),
            (:call, :scale!, (:call, :centralize_sumabs2!, :R, :A, :m), (:call, :convert, :S, (:call, :/, 1, :rn)))
          )),
        (:line, 156, :none),
        (:return, :R)
      )),
    (:line, 159, :none),
    "    varm(v, m[, region]; corrected::Bool=true)\n\nCompute the sample variance of a collection `v` with known mean(s) `m`,\noptionally over `region`. `m` may contain means for each dimension of\n`v`. If `corrected` is `true`, then the sum is scaled with `n-1`,\nwhereas the sum is scaled with `n` if `corrected` is `false` where `n = length(x)`.\n\n!!! note\n    Julia does not ignore `NaN` values in the computation. For\n    applications requiring the handling of missing data, the\n    `DataArrays.jl` package is recommended.\n",
    (:line, 172, :none),
    (:(=), (:call, (:curly, :varm, :T), (:parameters, (:kw, (:(::), :corrected, :Bool), true)), (:(::), :A, (:curly, :AbstractArray, :T)), (:(::), :m, :AbstractArray), :region), (:block,
        (:line, 172, :none),
        (:call, :varm!, (:parameters, (:kw, :corrected, :corrected)), (:call, :reducedim_initarray, :A, :region, 0, (:call, :real, (:call, :momenttype, :T))), :A, :m)
      )),
    (:line, 176, :none),
    (:(=), (:call, (:curly, :var, :T), (:parameters, (:kw, (:(::), :corrected, :Bool), true), (:kw, :mean, :nothing)), (:(::), :A, (:curly, :AbstractArray, :T))), (:block,
        (:line, 176, :none),
        (:call, :convert, (:call, :real, (:call, :momenttype, :T)), (:call, :varm, (:parameters, (:kw, :corrected, :corrected)), :A, (:if, (:call, :(===), :mean, :nothing), (:call, (:., :Base, (:quote, #QuoteNode
                    :mean
                  )), :A), :mean)))
      )),
    (:line, 180, :none),
    (:(=), (:call, :var, (:parameters, (:kw, (:(::), :corrected, :Bool), true), (:kw, :mean, :nothing)), (:(::), :A, :AbstractArray), :region), (:block,
        (:line, 180, :none),
        (:call, :varm, (:parameters, (:kw, :corrected, :corrected)), :A, (:if, (:call, :(===), :mean, :nothing), (:call, (:., :Base, (:quote, #QuoteNode
                  :mean
                )), :A, :region), :mean), :region)
      )),
    (:line, 183, :none),
    (:(=), (:call, :varm, (:parameters, (:kw, (:(::), :corrected, :Bool), true)), :iterable, (:(::), :m, :Number)), (:block,
        (:line, 183, :none),
        (:call, :var, :iterable, (:kw, :corrected, :corrected), (:kw, :mean, :m))
      )),
    (:line, 188, :none),
    (:function, (:call, :varm, (:(::), :v, :Range), (:(::), :m, :Number)), (:block,
        (:line, 189, :none),
        (:(=), :f, (:call, :-, (:call, :first, :v), :m)),
        (:line, 190, :none),
        (:(=), :s, (:call, :step, :v)),
        (:line, 191, :none),
        (:(=), :l, (:call, :length, :v)),
        (:line, 192, :none),
        (:if, (:||, (:call, :(==), :l, 0), (:call, :(==), :l, 1)), (:block,
            (:line, 193, :none),
            (:return, :NaN)
          )),
        (:line, 195, :none),
        (:return, (:call, :+, (:call, :/, (:call, :*, (:call, :^, :f, 2), :l), (:call, :-, :l, 1)), (:call, :*, :f, :s, :l), (:call, :/, (:call, :*, (:call, :^, :s, 2), :l, (:call, :-, (:call, :*, 2, :l), 1)), 6)))
      )),
    (:line, 198, :none),
    (:function, (:call, :var, (:(::), :v, :Range)), (:block,
        (:line, 199, :none),
        (:(=), :s, (:call, :step, :v)),
        (:line, 200, :none),
        (:(=), :l, (:call, :length, :v)),
        (:line, 201, :none),
        (:if, (:||, (:call, :(==), :l, 0), (:call, :(==), :l, 1)), (:block,
            (:line, 202, :none),
            (:return, :NaN)
          )),
        (:line, 204, :none),
        (:return, (:call, :/, (:call, :*, (:call, :abs2, :s), (:call, :+, :l, 1), :l), 12))
      )),
    (:line, 210, :none),
    (:function, (:call, :sqrt!, (:(::), :A, :AbstractArray)), (:block,
        (:line, 211, :none),
        (:for, (:(=), :i, (:call, :eachindex, :A)), (:block,
            (:line, 212, :none),
            (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :A, :i), (:call, :sqrt, (:ref, :A, :i))))
          )),
        (:line, 214, :none),
        :A
      )),
    (:line, 217, :none),
    (:(=), (:call, :stdm, (:parameters, (:kw, (:(::), :corrected, :Bool), true)), (:(::), :A, :AbstractArray), (:(::), :m, :Number)), (:block,
        (:line, 217, :none),
        (:call, :sqrt, (:call, :varm, (:parameters, (:kw, :corrected, :corrected)), :A, :m))
      )),
    (:line, 220, :none),
    (:(=), (:call, :std, (:parameters, (:kw, (:(::), :corrected, :Bool), true), (:kw, :mean, :nothing)), (:(::), :A, :AbstractArray)), (:block,
        (:line, 220, :none),
        (:call, :sqrt, (:call, :var, (:parameters, (:kw, :corrected, :corrected), (:kw, :mean, :mean)), :A))
      )),
    (:line, 223, :none),
    "    std(v[, region]; corrected::Bool=true, mean=nothing)\n\nCompute the sample standard deviation of a vector or array `v`, optionally along dimensions\nin `region`. The algorithm returns an estimator of the generative distribution's standard\ndeviation under the assumption that each entry of `v` is an IID drawn from that generative\ndistribution. This computation is equivalent to calculating `sqrt(sum((v - mean(v)).^2) /\n(length(v) - 1))`. A pre-computed `mean` may be provided. If `corrected` is `true`,\nthen the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is\n`false` where `n = length(x)`.\n\n!!! note\n    Julia does not ignore `NaN` values in the computation. For\n    applications requiring the handling of missing data, the\n    `DataArrays.jl` package is recommended.\n",
    (:line, 239, :none),
    (:(=), (:call, :std, (:parameters, (:kw, (:(::), :corrected, :Bool), true), (:kw, :mean, :nothing)), (:(::), :A, :AbstractArray), :region), (:block,
        (:line, 239, :none),
        (:call, :sqrt!, (:call, :var, (:parameters, (:kw, :corrected, :corrected), (:kw, :mean, :mean)), :A, :region))
      )),
    (:line, 242, :none),
    (:(=), (:call, :std, (:parameters, (:kw, (:(::), :corrected, :Bool), true), (:kw, :mean, :nothing)), :iterable), (:block,
        (:line, 242, :none),
        (:call, :sqrt, (:call, :var, :iterable, (:kw, :corrected, :corrected), (:kw, :mean, :mean)))
      )),
    (:line, 245, :none),
    "    stdm(v, m::Number; corrected::Bool=true)\n\nCompute the sample standard deviation of a vector `v`\nwith known mean `m`. If `corrected` is `true`,\nthen the sum is scaled with `n-1`, whereas the sum is\nscaled with `n` if `corrected` is `false` where `n = length(x)`.\n\n!!! note\n    Julia does not ignore `NaN` values in the computation. For\n    applications requiring the handling of missing data, the\n    `DataArrays.jl` package is recommended.\n",
    (:line, 258, :none),
    (:(=), (:call, :stdm, (:parameters, (:kw, (:(::), :corrected, :Bool), true)), :iterable, (:(::), :m, :Number)), (:block,
        (:line, 258, :none),
        (:call, :std, :iterable, (:kw, :corrected, :corrected), (:kw, :mean, :m))
      )),
    (:line, 266, :none),
    (:(=), (:call, (:curly, :_conj, (:<:, :T, :Real)), (:(::), :x, (:curly, :AbstractArray, :T))), (:block,
        (:line, 266, :none),
        :x
      )),
    (:line, 267, :none),
    (:(=), (:call, :_conj, (:(::), :x, :AbstractArray)), (:block,
        (:line, 267, :none),
        (:call, :conj, :x)
      )),
    (:line, 269, :none),
    (:(=), (:call, :_getnobs, (:(::), :x, :AbstractVector), (:(::), :vardim, :Int)), (:block,
        (:line, 269, :none),
        (:call, :_length, :x)
      )),
    (:line, 270, :none),
    (:(=), (:call, :_getnobs, (:(::), :x, :AbstractMatrix), (:(::), :vardim, :Int)), (:block,
        (:line, 270, :none),
        (:call, :size, :x, :vardim)
      )),
    (:line, 272, :none),
    (:function, (:call, :_getnobs, (:(::), :x, :AbstractVecOrMat), (:(::), :y, :AbstractVecOrMat), (:(::), :vardim, :Int)), (:block,
        (:line, 273, :none),
        (:(=), :n, (:call, :_getnobs, :x, :vardim)),
        (:line, 274, :none),
        (:||, (:call, :(==), (:call, :_getnobs, :y, :vardim), :n), (:call, :throw, (:call, :DimensionMismatch, "dimensions of x and y mismatch"))),
        (:line, 275, :none),
        (:return, :n)
      )),
    (:line, 278, :none),
    (:(=), (:call, :_vmean, (:(::), :x, :AbstractVector), (:(::), :vardim, :Int)), (:block,
        (:line, 278, :none),
        (:call, :mean, :x)
      )),
    (:line, 279, :none),
    (:(=), (:call, :_vmean, (:(::), :x, :AbstractMatrix), (:(::), :vardim, :Int)), (:block,
        (:line, 279, :none),
        (:call, :mean, :x, :vardim)
      )),
    (:line, 283, :none),
    (:(=), (:call, :unscaled_covzm, (:(::), :x, :AbstractVector)), (:block,
        (:line, 283, :none),
        (:call, :sumabs2, :x)
      )),
    (:line, 284, :none),
    (:(=), (:call, :unscaled_covzm, (:(::), :x, :AbstractMatrix), (:(::), :vardim, :Int)), (:block,
        (:line, 284, :none),
        (:if, (:call, :(==), :vardim, 1), (:call, :_conj, (:call, :*, (:', :x), :x)), (:call, :*, :x, (:', :x)))
      )),
    (:line, 286, :none),
    (:(=), (:call, :unscaled_covzm, (:(::), :x, :AbstractVector), (:(::), :y, :AbstractVector)), (:block,
        (:line, 286, :none),
        (:call, :dot, :x, :y)
      )),
    (:line, 287, :none),
    (:(=), (:call, :unscaled_covzm, (:(::), :x, :AbstractVector), (:(::), :y, :AbstractMatrix), (:(::), :vardim, :Int)), (:block,
        (:line, 287, :none),
        (:if, (:call, :(==), :vardim, 1), (:call, :At_mul_B, :x, (:call, :_conj, :y)), (:call, :At_mul_Bt, :x, (:call, :_conj, :y)))
      )),
    (:line, 289, :none),
    (:(=), (:call, :unscaled_covzm, (:(::), :x, :AbstractMatrix), (:(::), :y, :AbstractVector), (:(::), :vardim, :Int)), (:block,
        (:line, 289, :none),
        (:block,
          (:(=), :c, (:if, (:call, :(==), :vardim, 1), (:call, :At_mul_B, :x, (:call, :_conj, :y)), (:call, :*, :x, (:call, :_conj, :y)))),
          (:call, :reshape, :c, (:call, :length, :c), 1)
        )
      )),
    (:line, 291, :none),
    (:(=), (:call, :unscaled_covzm, (:(::), :x, :AbstractMatrix), (:(::), :y, :AbstractMatrix), (:(::), :vardim, :Int)), (:block,
        (:line, 291, :none),
        (:if, (:call, :(==), :vardim, 1), (:call, :At_mul_B, :x, (:call, :_conj, :y)), (:call, :A_mul_Bc, :x, :y))
      )),
    (:line, 296, :none),
    (:(=), (:call, :covzm, (:(::), :x, :AbstractVector), (:kw, (:(::), :corrected, :Bool), true)), (:block,
        (:line, 296, :none),
        (:call, :/, (:call, :unscaled_covzm, :x), (:call, :-, (:call, :_length, :x), (:call, :Int, :corrected)))
      )),
    (:line, 297, :none),
    (:(=), (:call, :covzm, (:(::), :x, :AbstractMatrix), (:kw, (:(::), :vardim, :Int), 1), (:kw, (:(::), :corrected, :Bool), true)), (:block,
        (:line, 297, :none),
        (:call, :scale!, (:call, :unscaled_covzm, :x, :vardim), (:call, :inv, (:call, :-, (:call, :size, :x, :vardim), (:call, :Int, :corrected))))
      )),
    (:line, 299, :none),
    (:(=), (:call, :covzm, (:(::), :x, :AbstractVector), (:(::), :y, :AbstractVector), (:kw, (:(::), :corrected, :Bool), true)), (:block,
        (:line, 299, :none),
        (:call, :/, (:call, :unscaled_covzm, :x, :y), (:call, :-, (:call, :_length, :x), (:call, :Int, :corrected)))
      )),
    (:line, 301, :none),
    (:(=), (:call, :covzm, (:(::), :x, :AbstractVecOrMat), (:(::), :y, :AbstractVecOrMat), (:kw, (:(::), :vardim, :Int), 1), (:kw, (:(::), :corrected, :Bool), true)), (:block,
        (:line, 301, :none),
        (:call, :scale!, (:call, :unscaled_covzm, :x, :y, :vardim), (:call, :inv, (:call, :-, (:call, :_getnobs, :x, :y, :vardim), (:call, :Int, :corrected))))
      )),
    (:line, 306, :none),
    (:(=), (:call, :covm, (:(::), :x, :AbstractVector), :xmean, (:kw, (:(::), :corrected, :Bool), true)), (:block,
        (:line, 306, :none),
        (:call, :covzm, (:call, :.-, :x, :xmean), :corrected)
      )),
    (:line, 308, :none),
    (:(=), (:call, :covm, (:(::), :x, :AbstractMatrix), :xmean, (:kw, (:(::), :vardim, :Int), 1), (:kw, (:(::), :corrected, :Bool), true)), (:block,
        (:line, 308, :none),
        (:call, :covzm, (:call, :.-, :x, :xmean), :vardim, :corrected)
      )),
    (:line, 310, :none),
    (:(=), (:call, :covm, (:(::), :x, :AbstractVector), :xmean, (:(::), :y, :AbstractVector), :ymean, (:kw, (:(::), :corrected, :Bool), true)), (:block,
        (:line, 310, :none),
        (:call, :covzm, (:call, :.-, :x, :xmean), (:call, :.-, :y, :ymean), :corrected)
      )),
    (:line, 312, :none),
    (:(=), (:call, :covm, (:(::), :x, :AbstractVecOrMat), :xmean, (:(::), :y, :AbstractVecOrMat), :ymean, (:kw, (:(::), :vardim, :Int), 1), (:kw, (:(::), :corrected, :Bool), true)), (:block,
        (:line, 312, :none),
        (:call, :covzm, (:call, :.-, :x, :xmean), (:call, :.-, :y, :ymean), :vardim, :corrected)
      )),
    (:line, 316, :none),
    "    cov(x[, corrected=true])\n\nCompute the variance of the vector `x`. If `corrected` is `true` (the default) then the sum\nis scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false` where `n = length(x)`.\n",
    (:line, 322, :none),
    (:(=), (:call, :cov, (:(::), :x, :AbstractVector), (:(::), :corrected, :Bool)), (:block,
        (:line, 322, :none),
        (:call, :covm, :x, (:call, (:., :Base, (:quote, #QuoteNode
                :mean
              )), :x), :corrected)
      )),
    (:line, 324, :none),
    (:(=), (:call, (:curly, :cov, (:<:, :T, :AbstractVector)), (:(::), :x, :T)), (:block,
        (:line, 324, :none),
        (:call, :covm, :x, (:call, (:., :Base, (:quote, #QuoteNode
                :mean
              )), :x), true)
      )),
    (:line, 326, :none),
    "    cov(X[, vardim=1, corrected=true])\n\nCompute the covariance matrix of the matrix `X` along the dimension `vardim`. If `corrected`\nis `true` (the default) then the sum is scaled with `n-1`, whereas the sum is scaled with `n`\nif `corrected` is `false` where `n = size(X, vardim)`.\n",
    (:line, 333, :none),
    (:(=), (:call, :cov, (:(::), :X, :AbstractMatrix), (:(::), :vardim, :Int), (:kw, (:(::), :corrected, :Bool), true)), (:block,
        (:line, 333, :none),
        (:call, :covm, :X, (:call, :_vmean, :X, :vardim), :vardim, :corrected)
      )),
    (:line, 336, :none),
    (:(=), (:call, (:curly, :cov, (:<:, :T, :AbstractMatrix)), (:(::), :X, :T)), (:block,
        (:line, 336, :none),
        (:call, :cov, :X, 1, true)
      )),
    (:line, 338, :none),
    "    cov(x, y[, corrected=true])\n\nCompute the covariance between the vectors `x` and `y`. If `corrected` is `true` (the default)\nthen the sum is scaled with `n-1`, whereas the sum is scaled with `n` if `corrected` is `false`\nwhere `n = length(x) = length(y)`.\n",
    (:line, 345, :none),
    (:(=), (:call, :cov, (:(::), :x, :AbstractVector), (:(::), :y, :AbstractVector), (:(::), :corrected, :Bool)), (:block,
        (:line, 345, :none),
        (:call, :covm, :x, (:call, (:., :Base, (:quote, #QuoteNode
                :mean
              )), :x), :y, (:call, (:., :Base, (:quote, #QuoteNode
                :mean
              )), :y), :corrected)
      )),
    (:line, 348, :none),
    (:(=), (:call, (:curly, :cov, (:<:, :T, :AbstractVector), (:<:, :S, :AbstractVector)), (:(::), :x, :T), (:(::), :y, :S)), (:block,
        (:line, 348, :none),
        (:call, :covm, :x, (:call, (:., :Base, (:quote, #QuoteNode
                :mean
              )), :x), :y, (:call, (:., :Base, (:quote, #QuoteNode
                :mean
              )), :y), true)
      )),
    (:line, 351, :none),
    "    cov(X, Y[, vardim=1, corrected=true])\n\nCompute the covariance between the vectors or matrices `X` and `Y` along the dimension\n`vardim`. If `corrected` is `true` (the default) then the sum is scaled with `n-1`, whereas\nthe sum is scaled with `n` if `corrected` is `false` where `n = size(X, vardim) = size(Y, vardim)`.\n",
    (:line, 358, :none),
    (:(=), (:call, :cov, (:(::), :X, :AbstractVecOrMat), (:(::), :Y, :AbstractVecOrMat), (:(::), :vardim, :Int), (:kw, (:(::), :corrected, :Bool), true)), (:block,
        (:line, 358, :none),
        (:call, :covm, :X, (:call, :_vmean, :X, :vardim), :Y, (:call, :_vmean, :Y, :vardim), :vardim, :corrected)
      )),
    (:line, 361, :none),
    (:(=), (:call, :cov, (:(::), :x, :AbstractVector), (:(::), :Y, :AbstractMatrix)), (:block,
        (:line, 361, :none),
        (:call, :cov, :x, :Y, 1, true)
      )),
    (:line, 362, :none),
    (:(=), (:call, :cov, (:(::), :X, :AbstractMatrix), (:(::), :y, :AbstractVector)), (:block,
        (:line, 362, :none),
        (:call, :cov, :X, :y, 1, true)
      )),
    (:line, 363, :none),
    (:(=), (:call, :cov, (:(::), :X, :AbstractMatrix), (:(::), :Y, :AbstractMatrix)), (:block,
        (:line, 363, :none),
        (:call, :cov, :X, :Y, 1, true)
      )),
    (:line, 369, :none),
    (:function, (:call, (:curly, :cov2cor!, :T), (:(::), :C, (:curly, :AbstractMatrix, :T)), (:(::), :xsd, :AbstractArray)), (:block,
        (:line, 370, :none),
        (:(=), :nx, (:call, :length, :xsd)),
        (:line, 371, :none),
        (:||, (:call, :(==), (:call, :size, :C), (:tuple, :nx, :nx)), (:call, :throw, (:call, :DimensionMismatch, "inconsistent dimensions"))),
        (:line, 372, :none),
        (:for, (:(=), :j, (:(:), 1, :nx)), (:block,
            (:line, 373, :none),
            (:for, (:(=), :i, (:(:), 1, (:call, :-, :j, 1))), (:block,
                (:line, 374, :none),
                (:(=), (:ref, :C, :i, :j), (:ref, :C, :j, :i))
              )),
            (:line, 376, :none),
            (:(=), (:ref, :C, :j, :j), (:call, :one, :T)),
            (:line, 377, :none),
            (:for, (:(=), :i, (:(:), (:call, :+, :j, 1), :nx)), (:block,
                (:line, 378, :none),
                (:(=), (:ref, :C, :i, :j), (:call, :clamp, (:call, :/, (:ref, :C, :i, :j), (:call, :*, (:ref, :xsd, :i), (:ref, :xsd, :j))), -1, 1))
              ))
          )),
        (:line, 381, :none),
        (:return, :C)
      )),
    (:line, 383, :none),
    (:function, (:call, :cov2cor!, (:(::), :C, :AbstractMatrix), (:(::), :xsd, :Number), (:(::), :ysd, :AbstractArray)), (:block,
        (:line, 384, :none),
        (:(=), (:tuple, :nx, :ny), (:call, :size, :C)),
        (:line, 385, :none),
        (:||, (:call, :(==), (:call, :length, :ysd), :ny), (:call, :throw, (:call, :DimensionMismatch, "inconsistent dimensions"))),
        (:line, 386, :none),
        (:for, (:(=), (:tuple, :j, :y), (:call, :enumerate, :ysd)), (:block,
            (:line, 387, :none),
            (:for, (:(=), :i, (:(:), 1, :nx)), (:block,
                (:line, 388, :none),
                (:(=), (:ref, :C, :i, :j), (:call, :clamp, (:call, :/, (:ref, :C, :i, :j), (:call, :*, :xsd, :y)), -1, 1))
              ))
          )),
        (:line, 391, :none),
        (:return, :C)
      )),
    (:line, 393, :none),
    (:function, (:call, :cov2cor!, (:(::), :C, :AbstractMatrix), (:(::), :xsd, :AbstractArray), (:(::), :ysd, :Number)), (:block,
        (:line, 394, :none),
        (:(=), (:tuple, :nx, :ny), (:call, :size, :C)),
        (:line, 395, :none),
        (:||, (:call, :(==), (:call, :length, :xsd), :nx), (:call, :throw, (:call, :DimensionMismatch, "inconsistent dimensions"))),
        (:line, 396, :none),
        (:for, (:(=), :j, (:(:), 1, :ny)), (:block,
            (:line, 397, :none),
            (:for, (:(=), (:tuple, :i, :x), (:call, :enumerate, :xsd)), (:block,
                (:line, 398, :none),
                (:(=), (:ref, :C, :i, :j), (:call, :clamp, (:call, :/, (:ref, :C, :i, :j), (:call, :*, :x, :ysd)), -1, 1))
              ))
          )),
        (:line, 401, :none),
        (:return, :C)
      )),
    (:line, 403, :none),
    (:function, (:call, :cov2cor!, (:(::), :C, :AbstractMatrix), (:(::), :xsd, :AbstractArray), (:(::), :ysd, :AbstractArray)), (:block,
        (:line, 404, :none),
        (:(=), (:tuple, :nx, :ny), (:call, :size, :C)),
        (:line, 405, :none),
        (:||, (:&&, (:call, :(==), (:call, :length, :xsd), :nx), (:call, :(==), (:call, :length, :ysd), :ny)), (:call, :throw, (:call, :DimensionMismatch, "inconsistent dimensions"))),
        (:line, 407, :none),
        (:for, (:(=), (:tuple, :i, :x), (:call, :enumerate, :xsd)), (:block,
            (:line, 408, :none),
            (:for, (:(=), (:tuple, :j, :y), (:call, :enumerate, :ysd)), (:block,
                (:line, 409, :none),
                (:(=), (:ref, :C, :i, :j), (:call, :clamp, (:call, :/, (:ref, :C, :i, :j), (:call, :*, :x, :y)), -1, 1))
              ))
          )),
        (:line, 412, :none),
        (:return, :C)
      )),
    (:line, 417, :none),
    (:(=), (:call, (:curly, :corzm, :T), (:(::), :x, (:curly, :AbstractVector, :T))), (:block,
        (:line, 417, :none),
        (:call, :one, (:call, :real, :T))
      )),
    (:line, 418, :none),
    (:function, (:call, :corzm, (:(::), :x, :AbstractMatrix), (:kw, (:(::), :vardim, :Int), 1)), (:block,
        (:line, 419, :none),
        (:(=), :c, (:call, :unscaled_covzm, :x, :vardim)),
        (:line, 420, :none),
        (:return, (:call, :cov2cor!, :c, (:call, :sqrt!, (:call, :diag, :c))))
      )),
    (:line, 422, :none),
    (:(=), (:call, :corzm, (:(::), :x, :AbstractVector), (:(::), :y, :AbstractMatrix), (:kw, (:(::), :vardim, :Int), 1)), (:block,
        (:line, 422, :none),
        (:call, :cov2cor!, (:call, :unscaled_covzm, :x, :y, :vardim), (:call, :sqrt, (:call, :sumabs2, :x)), (:call, :sqrt!, (:call, :sumabs2, :y, :vardim)))
      )),
    (:line, 424, :none),
    (:(=), (:call, :corzm, (:(::), :x, :AbstractMatrix), (:(::), :y, :AbstractVector), (:kw, (:(::), :vardim, :Int), 1)), (:block,
        (:line, 424, :none),
        (:call, :cov2cor!, (:call, :unscaled_covzm, :x, :y, :vardim), (:call, :sqrt!, (:call, :sumabs2, :x, :vardim)), (:call, :sqrt, (:call, :sumabs2, :y)))
      )),
    (:line, 426, :none),
    (:(=), (:call, :corzm, (:(::), :x, :AbstractMatrix), (:(::), :y, :AbstractMatrix), (:kw, (:(::), :vardim, :Int), 1)), (:block,
        (:line, 426, :none),
        (:call, :cov2cor!, (:call, :unscaled_covzm, :x, :y, :vardim), (:call, :sqrt!, (:call, :sumabs2, :x, :vardim)), (:call, :sqrt!, (:call, :sumabs2, :y, :vardim)))
      )),
    (:line, 431, :none),
    (:(=), (:call, (:curly, :corm, :T), (:(::), :x, (:curly, :AbstractVector, :T)), :xmean), (:block,
        (:line, 431, :none),
        (:call, :one, (:call, :real, :T))
      )),
    (:line, 432, :none),
    (:(=), (:call, :corm, (:(::), :x, :AbstractMatrix), :xmean, (:kw, (:(::), :vardim, :Int), 1)), (:block,
        (:line, 432, :none),
        (:call, :corzm, (:call, :.-, :x, :xmean), :vardim)
      )),
    (:line, 433, :none),
    (:function, (:call, :corm, (:(::), :x, :AbstractVector), (:(::), :mx, :Number), (:(::), :y, :AbstractVector), (:(::), :my, :Number)), (:block,
        (:line, 434, :none),
        (:(=), :n, (:call, :length, :x)),
        (:line, 435, :none),
        (:||, (:call, :(==), (:call, :length, :y), :n), (:call, :throw, (:call, :DimensionMismatch, "inconsistent lengths"))),
        (:line, 436, :none),
        (:||, (:call, :>, :n, 0), (:call, :throw, (:call, :ArgumentError, "correlation only defined for non-empty vectors"))),
        (:line, 438, :none),
        (:macrocall, Symbol("@inbounds"), (:block,
            (:line, 440, :none),
            (:(=), :xx, (:call, :zero, (:call, :sqrt, (:call, :*, (:ref, :x, 1), (:ref, :x, 1))))),
            (:line, 441, :none),
            (:(=), :yy, (:call, :zero, (:call, :sqrt, (:call, :*, (:ref, :y, 1), (:ref, :y, 1))))),
            (:line, 442, :none),
            (:(=), :xy, (:call, :zero, (:call, :*, :xx, :yy))),
            (:line, 444, :none),
            (:macrocall, Symbol("@simd"), (:for, (:(=), :i, (:(:), 1, :n)), (:block,
                  (:line, 445, :none),
                  (:(=), :xi, (:call, :-, (:ref, :x, :i), :mx)),
                  (:line, 446, :none),
                  (:(=), :yi, (:call, :-, (:ref, :y, :i), :my)),
                  (:line, 447, :none),
                  (:+=, :xx, (:call, :abs2, :xi)),
                  (:line, 448, :none),
                  (:+=, :yy, (:call, :abs2, :yi)),
                  (:line, 449, :none),
                  (:+=, :xy, (:call, :*, :xi, (:', :yi)))
                )))
          )),
        (:line, 452, :none),
        (:return, (:call, :clamp, (:call, :/, (:call, :/, :xy, (:call, :max, :xx, :yy)), (:call, :sqrt, (:call, :/, (:call, :min, :xx, :yy), (:call, :max, :xx, :yy)))), -1, 1))
      )),
    (:line, 454, :none),
    (:(=), (:call, :corm, (:(::), :x, :AbstractVecOrMat), :xmean, (:(::), :y, :AbstractVecOrMat), :ymean, (:kw, (:(::), :vardim, :Int), 1)), (:block,
        (:line, 454, :none),
        (:call, :corzm, (:call, :.-, :x, :xmean), (:call, :.-, :y, :ymean), :vardim)
      )),
    (:line, 458, :none),
    "    cor(x)\n\nReturn the number one.\n",
    (:line, 463, :none),
    (:(=), (:call, (:curly, :cor, (:<:, :T, :AbstractVector)), (:(::), :x, :T)), (:block,
        (:line, 463, :none),
        (:call, :one, (:call, :real, (:call, :eltype, :x)))
      )),
    (:line, 466, :none),
    "    cor(X[, vardim=1])\n\nCompute the Pearson correlation matrix of the matrix `X` along the dimension `vardim`.\n",
    (:line, 471, :none),
    (:(=), (:call, :cor, (:(::), :X, :AbstractMatrix), (:(::), :vardim, :Int)), (:block,
        (:line, 471, :none),
        (:call, :corm, :X, (:call, :_vmean, :X, :vardim), :vardim)
      )),
    (:line, 473, :none),
    (:(=), (:call, (:curly, :cor, (:<:, :T, :AbstractMatrix)), (:(::), :X, :T)), (:block,
        (:line, 473, :none),
        (:call, :cor, :X, 1)
      )),
    (:line, 475, :none),
    "    cor(x, y)\n\nCompute the Pearson correlation between the vectors `x` and `y`.\n",
    (:line, 480, :none),
    (:(=), (:call, (:curly, :cor, (:<:, :T, :AbstractVector), (:<:, :S, :AbstractVector)), (:(::), :x, :T), (:(::), :y, :S)), (:block,
        (:line, 480, :none),
        (:call, :corm, :x, (:call, (:., :Base, (:quote, #QuoteNode
                :mean
              )), :x), :y, (:call, (:., :Base, (:quote, #QuoteNode
                :mean
              )), :y))
      )),
    (:line, 483, :none),
    "    cor(X, Y[, vardim=1])\n\nCompute the Pearson correlation between the vectors or matrices `X` and `Y` along the dimension `vardim`.\n",
    (:line, 488, :none),
    (:(=), (:call, :cor, (:(::), :x, :AbstractVecOrMat), (:(::), :y, :AbstractVecOrMat), (:(::), :vardim, :Int)), (:block,
        (:line, 488, :none),
        (:call, :corm, :x, (:call, :_vmean, :x, :vardim), :y, (:call, :_vmean, :y, :vardim), :vardim)
      )),
    (:line, 491, :none),
    (:(=), (:call, :cor, (:(::), :x, :AbstractVector), (:(::), :Y, :AbstractMatrix)), (:block,
        (:line, 491, :none),
        (:call, :cor, :x, :Y, 1)
      )),
    (:line, 492, :none),
    (:(=), (:call, :cor, (:(::), :X, :AbstractMatrix), (:(::), :y, :AbstractVector)), (:block,
        (:line, 492, :none),
        (:call, :cor, :X, :y, 1)
      )),
    (:line, 493, :none),
    (:(=), (:call, :cor, (:(::), :X, :AbstractMatrix), (:(::), :Y, :AbstractMatrix)), (:block,
        (:line, 493, :none),
        (:call, :cor, :X, :Y, 1)
      )),
    (:line, 497, :none),
    "    middle(x)\n\nCompute the middle of a scalar value, which is equivalent to `x` itself, but of the type of `middle(x, x)` for consistency.\n",
    (:line, 503, :none),
    (:(=), (:call, :middle, (:(::), :x, (:curly, :Union, :Bool, :Int8, :Int16, :Int32, :Int64, :Int128, :UInt8, :UInt16, :UInt32, :UInt64, :UInt128))), (:block,
        (:line, 503, :none),
        (:call, :Float64, :x)
      )),
    (:line, 504, :none),
    (:(=), (:call, :middle, (:(::), :x, :AbstractFloat)), (:block,
        (:line, 504, :none),
        :x
      )),
    (:line, 505, :none),
    (:(=), (:call, :middle, (:(::), :x, :Float16)), (:block,
        (:line, 505, :none),
        (:call, :Float32, :x)
      )),
    (:line, 506, :none),
    (:(=), (:call, :middle, (:(::), :x, :Real)), (:block,
        (:line, 506, :none),
        (:call, :/, (:call, :+, :x, (:call, :zero, :x)), 1)
      )),
    (:line, 508, :none),
    "    middle(x, y)\n\nCompute the middle of two reals `x` and `y`, which is\nequivalent in both value and type to computing their mean (`(x + y) / 2`).\n",
    (:line, 514, :none),
    (:(=), (:call, :middle, (:(::), :x, :Real), (:(::), :y, :Real)), (:block,
        (:line, 514, :none),
        (:call, :+, (:call, :/, :x, 2), (:call, :/, :y, 2))
      )),
    (:line, 516, :none),
    "    middle(range)\n\nCompute the middle of a range, which consists of computing the mean of its extrema.\nSince a range is sorted, the mean is performed with the first and last element.\n\n```jldoctest\njulia> middle(1:10)\n5.5\n```\n",
    (:line, 527, :none),
    (:(=), (:call, :middle, (:(::), :a, :Range)), (:block,
        (:line, 527, :none),
        (:call, :middle, (:ref, :a, 1), (:ref, :a, :end))
      )),
    (:line, 529, :none),
    "    middle(a)\n\nCompute the middle of an array `a`, which consists of finding its\nextrema and then computing their mean.\n\n```jldoctest\njulia> a = [1,2,3.6,10.9]\n4-element Array{Float64,1}:\n  1.0\n  2.0\n  3.6\n 10.9\n\njulia> middle(a)\n5.95\n```\n",
    (:line, 547, :none),
    (:(=), (:call, :middle, (:(::), :a, :AbstractArray)), (:block,
        (:line, 547, :none),
        (:block,
          (:(=), (:tuple, :v1, :v2), (:call, :extrema, :a)),
          (:call, :middle, :v1, :v2)
        )
      )),
    (:line, 549, :none),
    (:function, (:call, (:curly, :median!, :T), (:(::), :v, (:curly, :AbstractVector, :T))), (:block,
        (:line, 550, :none),
        (:&&, (:call, :isempty, :v), (:call, :throw, (:call, :ArgumentError, (:string, "median of an empty array is undefined, ", (:call, :repr, :v))))),
        (:line, 551, :none),
        (:if, (:<:, :T, :AbstractFloat), (:block,
            (:line, 552, :none),
            (:macrocall, Symbol("@inbounds"), (:for, (:(=), :x, :v), (:block,
                  (:line, 553, :none),
                  (:&&, (:call, :isnan, :x), (:return, :x))
                )))
          )),
        (:line, 556, :none),
        (:(=), :inds, (:call, :indices, :v, 1)),
        (:line, 557, :none),
        (:(=), :n, (:call, :length, :inds)),
        (:line, 558, :none),
        (:(=), :mid, (:call, :div, (:call, :+, (:call, :first, :inds), (:call, :last, :inds)), 2)),
        (:line, 559, :none),
        (:if, (:call, :isodd, :n), (:block,
            (:line, 560, :none),
            (:return, (:call, :middle, (:call, :select!, :v, :mid)))
          ), (:block,
            (:line, 562, :none),
            (:(=), :m, (:call, :select!, :v, (:(:), :mid, (:call, :+, :mid, 1)))),
            (:line, 563, :none),
            (:return, (:call, :middle, (:ref, :m, 1), (:ref, :m, 2)))
          ))
      )),
    (:line, 566, :none),
    (:(=), (:call, (:curly, :median!, :T), (:(::), :v, (:curly, :AbstractArray, :T))), (:block,
        (:line, 566, :none),
        (:call, :median!, (:call, :vec, :v))
      )),
    (:line, 567, :none),
    (:(=), (:call, (:curly, :median, :T), (:(::), :v, (:curly, :AbstractArray, :T))), (:block,
        (:line, 567, :none),
        (:call, :median!, (:call, :copy!, (:call, (:curly, :Array, :T, 1), (:call, :_length, :v)), :v))
      )),
    (:line, 569, :none),
    "    median(v[, region])\n\nCompute the median of an entire array `v`, or, optionally,\nalong the dimensions in `region`. For an even number of\nelements no exact median element exists, so the result is\nequivalent to calculating mean of two median elements.\n\n!!! note\n    Julia does not ignore `NaN` values in the computation. For applications requiring the\n    handling of missing data, the `DataArrays.jl` package is recommended.\n",
    (:line, 581, :none),
    (:(=), (:call, (:curly, :median, :T), (:(::), :v, (:curly, :AbstractArray, :T)), :region), (:block,
        (:line, 581, :none),
        (:call, :mapslices, :median!, :v, :region)
      )),
    (:line, 585, :none),
    "    quantile!([q, ] v, p; sorted=false)\n\nCompute the quantile(s) of a vector `v` at the probabilities `p`, with optional output into\narray `q` (if not provided, a new output array is created). The keyword argument `sorted`\nindicates whether `v` can be assumed to be sorted; if `false` (the default), then the\nelements of `v` may be partially sorted.\n\nThe elements of `p` should be on the interval [0,1], and `v` should not have any `NaN`\nvalues.\n\nQuantiles are computed via linear interpolation between the points `((k-1)/(n-1), v[k])`,\nfor `k = 1:n` where `n = length(v)`. This corresponds to Definition 7 of Hyndman and Fan\n(1996), and is the same as the R default.\n\n!!! note\n    Julia does not ignore `NaN` values in the computation. For applications requiring the\n    handling of missing data, the `DataArrays.jl` package is recommended. `quantile!` will\n    throw an `ArgumentError` in the presence of `NaN` values in the data array.\n\n* Hyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\",\n  *The American Statistician*, Vol. 50, No. 4, pp. 361-365\n",
    (:line, 608, :none),
    (:function, (:call, :quantile!, (:parameters, (:kw, (:(::), :sorted, :Bool), false)), (:(::), :q, :AbstractArray), (:(::), :v, :AbstractVector), (:(::), :p, :AbstractArray)), (:block,
        (:line, 610, :none),
        (:if, (:call, :(!=), (:call, :size, :p), (:call, :size, :q)), (:block,
            (:line, 611, :none),
            (:call, :throw, (:call, :DimensionMismatch, (:string, "size of p, ", (:call, :size, :p), ", must equal size of q, ", (:call, :size, :q))))
          )),
        (:line, 614, :none),
        (:&&, (:call, :isempty, :v), (:call, :throw, (:call, :ArgumentError, "empty data vector"))),
        (:line, 616, :none),
        (:(=), :lv, (:call, :length, :v)),
        (:line, 617, :none),
        (:if, (:call, :!, :sorted), (:block,
            (:line, 618, :none),
            (:(=), (:tuple, :minp, :maxp), (:call, :extrema, :p)),
            (:line, 619, :none),
            (:(=), :lo, (:call, :floor, :Int, (:call, :+, 1, (:call, :*, :minp, (:call, :-, :lv, 1))))),
            (:line, 620, :none),
            (:(=), :hi, (:call, :ceil, :Int, (:call, :+, 1, (:call, :*, :maxp, (:call, :-, :lv, 1))))),
            (:line, 623, :none),
            (:call, :sort!, :v, 1, :lv, (:call, :PartialQuickSort, (:(:), :lo, :hi)), (:., (:., :Base, (:quote, #QuoteNode
                    :Sort
                  )), (:quote, #QuoteNode
                  :Forward
                )))
          )),
        (:line, 625, :none),
        (:&&, (:call, :isnan, (:ref, :v, :end)), (:call, :throw, (:call, :ArgumentError, "quantiles are undefined in presence of NaNs"))),
        (:line, 627, :none),
        (:for, (:(=), (:tuple, :i, :j), (:call, :zip, (:call, :eachindex, :p), (:call, :eachindex, :q))), (:block,
            (:line, 628, :none),
            (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :q, :j), (:call, :_quantile, :v, (:ref, :p, :i))))
          )),
        (:line, 630, :none),
        (:return, :q)
      )),
    (:line, 633, :none),
    (:(=), (:call, :quantile!, (:parameters, (:kw, (:(::), :sorted, :Bool), false)), (:(::), :v, :AbstractVector), (:(::), :p, :AbstractArray)), (:block,
        (:line, 633, :none),
        (:call, :quantile!, (:parameters, (:kw, :sorted, :sorted)), (:call, :similar, :p, (:call, :float, (:call, :eltype, :v))), :v, :p)
      )),
    (:line, 636, :none),
    (:function, (:call, :quantile!, (:parameters, (:kw, (:(::), :sorted, :Bool), false)), (:(::), :v, :AbstractVector), (:(::), :p, :Real)), (:block,
        (:line, 638, :none),
        (:&&, (:call, :isempty, :v), (:call, :throw, (:call, :ArgumentError, "empty data vector"))),
        (:line, 640, :none),
        (:(=), :lv, (:call, :length, :v)),
        (:line, 641, :none),
        (:if, (:call, :!, :sorted), (:block,
            (:line, 642, :none),
            (:(=), :lo, (:call, :floor, :Int, (:call, :+, 1, (:call, :*, :p, (:call, :-, :lv, 1))))),
            (:line, 643, :none),
            (:(=), :hi, (:call, :ceil, :Int, (:call, :+, 1, (:call, :*, :p, (:call, :-, :lv, 1))))),
            (:line, 646, :none),
            (:call, :sort!, :v, 1, :lv, (:call, :PartialQuickSort, (:(:), :lo, :hi)), (:., (:., :Base, (:quote, #QuoteNode
                    :Sort
                  )), (:quote, #QuoteNode
                  :Forward
                )))
          )),
        (:line, 648, :none),
        (:&&, (:call, :isnan, (:ref, :v, :end)), (:call, :throw, (:call, :ArgumentError, "quantiles are undefined in presence of NaNs"))),
        (:line, 650, :none),
        (:return, (:call, :_quantile, :v, :p))
      )),
    (:line, 654, :none),
    (:macrocall, Symbol("@inline"), (:function, (:call, :_quantile, (:(::), :v, :AbstractVector), (:(::), :p, :Real)), (:block,
          (:line, 655, :none),
          (:(=), :T, (:call, :float, (:call, :eltype, :v))),
          (:line, 656, :none),
          (:&&, (:call, :isnan, :p), (:return, (:call, :T, :NaN))),
          (:line, 657, :none),
          (:||, (:comparison, 0, :(<=), :p, :(<=), 1), (:call, :throw, (:call, :ArgumentError, "input probability out of [0,1] range"))),
          (:line, 659, :none),
          (:(=), :lv, (:call, :length, :v)),
          (:line, 660, :none),
          (:(=), :f0, (:call, :*, (:call, :-, :lv, 1), :p)),
          (:line, 661, :none),
          (:(=), :t0, (:call, :trunc, :f0)),
          (:line, 662, :none),
          (:(=), :h, (:call, :-, :f0, :t0)),
          (:line, 664, :none),
          (:(=), :i, (:call, :+, (:call, :trunc, :Int, :t0), 1)),
          (:line, 666, :none),
          (:if, (:call, :(==), :h, 0), (:block,
              (:line, 667, :none),
              (:return, (:call, :T, (:ref, :v, :i)))
            ), (:block,
              (:line, 669, :none),
              (:(=), :a, (:call, :T, (:ref, :v, :i))),
              (:line, 670, :none),
              (:(=), :b, (:call, :T, (:ref, :v, (:call, :+, :i, 1)))),
              (:line, 671, :none),
              (:return, (:call, :+, :a, (:call, :*, :h, (:call, :-, :b, :a))))
            ))
        ))),
    (:line, 676, :none),
    "    quantile(v, p; sorted=false)\n\nCompute the quantile(s) of a vector `v` at a specified probability or vector `p`. The\nkeyword argument `sorted` indicates whether `v` can be assumed to be sorted.\n\nThe `p` should be on the interval [0,1], and `v` should not have any `NaN` values.\n\nQuantiles are computed via linear interpolation between the points `((k-1)/(n-1), v[k])`,\nfor `k = 1:n` where `n = length(v)`. This corresponds to Definition 7 of Hyndman and Fan\n(1996), and is the same as the R default.\n\n!!! note\n    Julia does not ignore `NaN` values in the computation. For applications requiring the\n    handling of missing data, the `DataArrays.jl` package is recommended. `quantile` will\n    throw an `ArgumentError` in the presence of `NaN` values in the data array.\n\n* Hyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\",\n  *The American Statistician*, Vol. 50, No. 4, pp. 361-365\n",
    (:line, 696, :none),
    (:(=), (:call, :quantile, (:parameters, (:kw, (:(::), :sorted, :Bool), false)), (:(::), :v, :AbstractVector), :p), (:block,
        (:line, 696, :none),
        (:call, :quantile!, (:parameters, (:kw, :sorted, :sorted)), (:if, :sorted, :v, (:call, :copymutable, :v)), :p)
      ))
  ))