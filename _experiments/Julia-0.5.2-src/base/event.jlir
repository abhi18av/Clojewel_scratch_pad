(:quote, (:block,
    (:line, 5, :none),
    "    Condition()\n\nCreate an edge-triggered event source that tasks can wait for. Tasks that call `wait` on a\n`Condition` are suspended and queued. Tasks are woken up when `notify` is later called on\nthe `Condition`. Edge triggering means that only tasks waiting at the time `notify` is\ncalled can be woken up. For level-triggered notifications, you must keep extra state to keep\ntrack of whether a notification has happened. The [`Channel`](:class:`Channel`) type does\nthis, and so can be used for level-triggered events.\n",
    (:line, 15, :none),
    (:type, true, :Condition, (:block,
        (:line, 16, :none),
        (:(::), :waitq, (:curly, :Vector, :Any)),
        (:line, 18, :none),
        (:(=), (:call, :Condition), (:block,
            (:line, 18, :none),
            (:call, :new, (:vect,))
          ))
      )),
    (:line, 21, :none),
    (:function, (:call, :wait, (:(::), :c, :Condition)), (:block,
        (:line, 22, :none),
        (:(=), :ct, (:call, :current_task)),
        (:line, 24, :none),
        (:call, :push!, (:., :c, (:quote, #QuoteNode
              :waitq
            )), :ct),
        (:line, 26, :none),
        (:try, (:block,
            (:line, 27, :none),
            (:return, (:call, :wait))
          ), false, (:block,
            (:line, 29, :none),
            (:call, :filter!, (:->, :x, (:block,
                  (:line, 29, :none),
                  (:call, :(!==), :x, :ct)
                )), (:., :c, (:quote, #QuoteNode
                  :waitq
                ))),
            (:line, 30, :none),
            (:call, :rethrow)
          ))
      )),
    (:line, 34, :none),
    "    notify(condition, val=nothing; all=true, error=false)\n\nWake up tasks waiting for a condition, passing them `val`. If `all` is `true` (the default),\nall waiting tasks are woken, otherwise only one is. If `error` is `true`, the passed value\nis raised as an exception in the woken tasks.\n",
    (:line, 41, :none),
    (:(=), (:call, :notify, (:parameters, (:kw, :all, true), (:kw, :error, false)), (:(::), :c, :Condition), (:kw, (:(::), :arg, :ANY), :nothing)), (:block,
        (:line, 41, :none),
        (:call, :notify, :c, :arg, :all, :error)
      )),
    (:line, 42, :none),
    (:function, (:call, :notify, (:(::), :c, :Condition), :arg, :all, :error), (:block,
        (:line, 43, :none),
        (:if, :all, (:block,
            (:line, 44, :none),
            (:for, (:(=), :t, (:., :c, (:quote, #QuoteNode
                    :waitq
                  ))), (:block,
                (:line, 45, :none),
                (:call, :schedule, :t, :arg, (:kw, :error, :error))
              )),
            (:line, 47, :none),
            (:call, :empty!, (:., :c, (:quote, #QuoteNode
                  :waitq
                )))
          ), (:block,
            (:line, 48, :none),
            (:if, (:call, :!, (:call, :isempty, (:., :c, (:quote, #QuoteNode
                      :waitq
                    )))), (:block,
                (:line, 49, :none),
                (:(=), :t, (:call, :shift!, (:., :c, (:quote, #QuoteNode
                        :waitq
                      )))),
                (:line, 50, :none),
                (:call, :schedule, :t, :arg, (:kw, :error, :error))
              ))
          )),
        (:line, 52, :none),
        :nothing
      )),
    (:line, 55, :none),
    (:(=), (:call, :notify1, (:(::), :c, :Condition), (:kw, :arg, :nothing)), (:block,
        (:line, 55, :none),
        (:call, :notify, :c, :arg, (:kw, :all, false))
      )),
    (:line, 57, :none),
    (:(=), (:call, :notify_error, (:(::), :c, :Condition), :err), (:block,
        (:line, 57, :none),
        (:call, :notify, :c, :err, (:kw, :error, true))
      )),
    (:line, 58, :none),
    (:(=), (:call, :notify1_error, (:(::), :c, :Condition), :err), (:block,
        (:line, 58, :none),
        (:call, :notify, :c, :err, (:kw, :error, true), (:kw, :all, false))
      )),
    (:line, 62, :none),
    "    @schedule\n\nWrap an expression in a `Task` and add it to the local machine's scheduler queue.\n",
    (:line, 67, :none),
    (:macro, (:call, :schedule, :expr), (:block,
        (:line, 68, :none),
        (:(=), :expr, (:quote, (:->, (:tuple,), (:block,
                (:line, 68, :none),
                (:$, :expr)
              )))),
        (:line, 69, :none),
        (:quote, (:call, :enq_work, (:call, :Task, (:$, (:call, :esc, :expr)))))
      )),
    (:line, 74, :none),
    (:const, (:global, (:(=), :Workqueue, (:ref, :Any)))),
    (:line, 76, :none),
    (:function, (:call, :enq_work, (:(::), :t, :Task)), (:block,
        (:line, 77, :none),
        (:||, (:call, :(==), (:., :t, (:quote, #QuoteNode
                :state
              )), (:quote, #QuoteNode
              :runnable
            )), (:call, :error, "schedule: Task not runnable")),
        (:line, 78, :none),
        (:ccall, (:quote, #QuoteNode
            :uv_stop
          ), :Void, (:tuple, (:curly, :Ptr, :Void)), (:call, :eventloop)),
        (:line, 79, :none),
        (:call, :push!, :Workqueue, :t),
        (:line, 80, :none),
        (:(=), (:., :t, (:quote, #QuoteNode
              :state
            )), (:quote, #QuoteNode
            :queued
          )),
        (:line, 81, :none),
        (:return, :t)
      )),
    (:line, 84, :none),
    (:(=), (:call, :schedule, (:(::), :t, :Task)), (:block,
        (:line, 84, :none),
        (:call, :enq_work, :t)
      )),
    (:line, 86, :none),
    "    schedule(t::Task, [val]; error=false)\n\nAdd a task to the scheduler's queue. This causes the task to run constantly when the system\nis otherwise idle, unless the task performs a blocking operation such as `wait`.\n\nIf a second argument `val` is provided, it will be passed to the task (via the return value of\n`yieldto`) when it runs again. If `error` is `true`, the value is raised as an exception in\nthe woken task.\n",
    (:line, 96, :none),
    (:function, (:call, :schedule, (:parameters, (:kw, :error, false)), (:(::), :t, :Task), :arg), (:block,
        (:line, 98, :none),
        (:if, :error, (:block,
            (:line, 99, :none),
            (:(=), (:., :t, (:quote, #QuoteNode
                  :exception
                )), :arg)
          ), (:block,
            (:line, 101, :none),
            (:(=), (:., :t, (:quote, #QuoteNode
                  :result
                )), :arg)
          )),
        (:line, 103, :none),
        (:return, (:call, :enq_work, :t))
      )),
    (:line, 107, :none),
    (:function, (:call, :schedule_and_wait, (:(::), :t, :Task), (:kw, :v, :nothing)), (:block,
        (:line, 108, :none),
        (:||, (:call, :(==), (:., :t, (:quote, #QuoteNode
                :state
              )), (:quote, #QuoteNode
              :runnable
            )), (:call, :error, "schedule: Task not runnable")),
        (:line, 109, :none),
        (:if, (:call, :isempty, :Workqueue), (:block,
            (:line, 110, :none),
            (:return, (:call, :yieldto, :t, :v))
          ), (:block,
            (:line, 112, :none),
            (:(=), (:., :t, (:quote, #QuoteNode
                  :result
                )), :v),
            (:line, 113, :none),
            (:call, :push!, :Workqueue, :t),
            (:line, 114, :none),
            (:(=), (:., :t, (:quote, #QuoteNode
                  :state
                )), (:quote, #QuoteNode
                :queued
              ))
          )),
        (:line, 116, :none),
        (:return, (:call, :wait))
      )),
    (:line, 119, :none),
    "    yield()\n\nSwitch to the scheduler to allow another scheduled task to run. A task that calls this\nfunction is still runnable, and will be restarted immediately if there are no other runnable\ntasks.\n",
    (:line, 126, :none),
    (:(=), (:call, :yield), (:block,
        (:line, 126, :none),
        (:block,
          (:call, :enq_work, (:call, :current_task)),
          (:call, :wait)
        )
      )),
    (:line, 128, :none),
    "    yieldto(task, arg = nothing)\n\nSwitch to the given task. The first time a task is switched to, the task's function is\ncalled with no arguments. On subsequent switches, `arg` is returned from the task's last\ncall to `yieldto`. This is a low-level call that only switches tasks, not considering states\nor scheduling in any way. Its use is discouraged.\n",
    (:line, 136, :none),
    (:(=), (:call, :yieldto, (:(::), :t, :Task), (:kw, (:(::), :x, :ANY), :nothing)), (:block,
        (:line, 136, :none),
        (:ccall, (:quote, #QuoteNode
            :jl_switchto
          ), :Any, (:tuple, :Any, :Any), :t, :x)
      )),
    (:line, 139, :none),
    (:function, (:call, :throwto, (:(::), :t, :Task), :exc), (:block,
        (:line, 140, :none),
        (:(=), (:., :t, (:quote, #QuoteNode
              :exception
            )), :exc),
        (:line, 141, :none),
        (:call, :yieldto, :t)
      )),
    (:line, 144, :none),
    (:function, (:call, :wait), (:block,
        (:line, 145, :none),
        (:while, true, (:block,
            (:line, 146, :none),
            (:if, (:call, :isempty, :Workqueue), (:block,
                (:line, 147, :none),
                (:(=), :c, (:call, :process_events, true)),
                (:line, 148, :none),
                (:if, (:&&, (:call, :(==), :c, 0), (:&&, (:call, :(!=), (:call, :eventloop), :C_NULL), (:call, :isempty, :Workqueue))), (:block,
                    (:line, 151, :none),
                    (:call, :pause)
                  ))
              ), (:block,
                (:line, 154, :none),
                (:(=), :t, (:call, :shift!, :Workqueue)),
                (:line, 155, :none),
                (:if, (:call, :(!=), (:., :t, (:quote, #QuoteNode
                        :state
                      )), (:quote, #QuoteNode
                      :queued
                    )), (:block,
                    (:line, 160, :none),
                    (:ccall, (:quote, #QuoteNode
                        :jl_safe_printf
                      ), :Void, (:tuple, (:curly, :Ptr, :UInt8), (:curly, :Vararg, :Int32)), "\nWARNING: Workqueue inconsistency detected: shift!(Workqueue).state != :queued\n"),
                    (:line, 162, :none),
                    (:continue,)
                  )),
                (:line, 164, :none),
                (:(=), :arg, (:., :t, (:quote, #QuoteNode
                      :result
                    ))),
                (:line, 165, :none),
                (:(=), (:., :t, (:quote, #QuoteNode
                      :result
                    )), :nothing),
                (:line, 166, :none),
                (:(=), (:., :t, (:quote, #QuoteNode
                      :state
                    )), (:quote, #QuoteNode
                    :runnable
                  )),
                (:line, 167, :none),
                (:local, :result),
                (:line, 168, :none),
                (:try, (:block,
                    (:line, 169, :none),
                    (:(=), :result, (:call, :yieldto, :t, :arg)),
                    (:line, 170, :none),
                    (:||, (:call, :(==), (:., (:call, :current_task), (:quote, #QuoteNode
                            :state
                          )), (:quote, #QuoteNode
                          :runnable
                        )), (:call, :throw, (:call, :AssertionError, "current_task().state == :runnable")))
                  ), :e, (:block,
                    (:line, 172, :none),
                    (:(=), :ct, (:call, :current_task)),
                    (:line, 173, :none),
                    (:if, (:call, :(==), (:., :ct, (:quote, #QuoteNode
                            :state
                          )), (:quote, #QuoteNode
                          :queued
                        )), (:block,
                        (:line, 174, :none),
                        (:if, (:call, :(==), (:., :t, (:quote, #QuoteNode
                                :state
                              )), (:quote, #QuoteNode
                              :runnable
                            )), (:block,
                            (:line, 177, :none),
                            (:(=), (:., :t, (:quote, #QuoteNode
                                  :result
                                )), :arg),
                            (:line, 178, :none),
                            (:(=), (:., :t, (:quote, #QuoteNode
                                  :state
                                )), (:quote, #QuoteNode
                                :queued
                              )),
                            (:line, 179, :none),
                            (:call, :push!, :Workqueue, :t)
                          )),
                        (:line, 182, :none),
                        (:(=), :i, (:call, :findfirst, :Workqueue, :ct)),
                        (:line, 183, :none),
                        (:||, (:call, :(==), :i, 0), (:call, :deleteat!, :Workqueue, :i)),
                        (:line, 184, :none),
                        (:(=), (:., :ct, (:quote, #QuoteNode
                              :state
                            )), (:quote, #QuoteNode
                            :runnable
                          ))
                      )),
                    (:line, 186, :none),
                    (:call, :rethrow, :e)
                  )),
                (:line, 188, :none),
                (:call, :process_events, false),
                (:line, 190, :none),
                (:return, :result)
              ))
          )),
        (:line, 193, :none),
        (:call, :assert, false)
      )),
    (:line, 196, :none),
    (:if, (:call, :is_windows), (:block,
        (:line, 197, :none),
        (:(=), (:call, :pause), (:block,
            (:line, 197, :none),
            (:ccall, (:quote, #QuoteNode
                :Sleep
              ), :Void, (:tuple, :UInt32), 0xffffffff, (:stdcall,))
          ))
      ), (:block,
        (:line, 199, :none),
        (:(=), (:call, :pause), (:block,
            (:line, 199, :none),
            (:ccall, (:quote, #QuoteNode
                :pause
              ), :Void, (:tuple,))
          ))
      )),
    (:line, 205, :none),
    "    AsyncCondition()\n\nCreate a async condition that wakes up tasks waiting for it (by calling `wait` on the object)\nwhen notified from C by a call to uv_async_send.\nWaiting tasks are woken with an error when the object is closed (by `close`).\nUse `isopen` to check whether it is still active.\n",
    (:line, 213, :none),
    (:type, true, :AsyncCondition, (:block,
        (:line, 214, :none),
        (:(::), :handle, (:curly, :Ptr, :Void)),
        (:line, 215, :none),
        (:(::), :cond, :Condition),
        (:line, 217, :none),
        (:function, (:call, :AsyncCondition), (:block,
            (:line, 218, :none),
            (:(=), :this, (:call, :new, (:call, (:., :Libc, (:quote, #QuoteNode
                      :malloc
                    )), :_sizeof_uv_async), (:call, :Condition))),
            (:line, 219, :none),
            (:call, :associate_julia_struct, (:., :this, (:quote, #QuoteNode
                  :handle
                )), :this),
            (:line, 220, :none),
            (:call, :preserve_handle, :this),
            (:line, 221, :none),
            (:(=), :err, (:ccall, (:quote, #QuoteNode
                  :uv_async_init
                ), :Cint, (:tuple, (:curly, :Ptr, :Void), (:curly, :Ptr, :Void), (:curly, :Ptr, :Void)), (:call, :eventloop), :this, (:(::), :uv_jl_asynccb, (:curly, :Ptr, :Void)))),
            (:line, 223, :none),
            :this
          ))
      )),
    (:line, 227, :none),
    (:(=), (:call, :unsafe_convert, (:(::), (:curly, :Type, (:curly, :Ptr, :Void))), (:(::), :async, :AsyncCondition)), (:block,
        (:line, 227, :none),
        (:., :async, (:quote, #QuoteNode
            :handle
          ))
      )),
    (:line, 229, :none),
    (:function, (:call, :wait, (:(::), :async, :AsyncCondition)), (:block,
        (:line, 230, :none),
        (:||, (:call, :isopen, :async), (:call, :throw, (:call, :EOFError))),
        (:line, 231, :none),
        (:call, :wait, (:., :async, (:quote, #QuoteNode
              :cond
            )))
      )),
    (:line, 234, :none),
    (:(=), (:call, :isopen, (:(::), :t, :AsyncCondition)), (:block,
        (:line, 234, :none),
        (:call, :(!=), (:., :t, (:quote, #QuoteNode
              :handle
            )), :C_NULL)
      )),
    (:line, 236, :none),
    (:(=), (:call, :close, (:(::), :t, :AsyncCondition)), (:block,
        (:line, 236, :none),
        (:ccall, (:quote, #QuoteNode
            :jl_close_uv
          ), :Void, (:tuple, (:curly, :Ptr, :Void)), :t)
      )),
    (:line, 238, :none),
    (:function, (:call, :_uv_hook_close, (:(::), :async, :AsyncCondition)), (:block,
        (:line, 239, :none),
        (:(=), (:., :async, (:quote, #QuoteNode
              :handle
            )), :C_NULL),
        (:line, 240, :none),
        (:call, :unpreserve_handle, :async),
        (:line, 241, :none),
        (:call, :notify_error, (:., :async, (:quote, #QuoteNode
              :cond
            )), (:call, :EOFError)),
        (:line, 242, :none),
        :nothing
      )),
    (:line, 245, :none),
    (:function, (:call, :uv_asynccb, (:(::), :handle, (:curly, :Ptr, :Void))), (:block,
        (:line, 246, :none),
        (:(=), :async, (:macrocall, Symbol("@handle_as"), :handle, :AsyncCondition)),
        (:line, 247, :none),
        (:call, :notify, (:., :async, (:quote, #QuoteNode
              :cond
            ))),
        (:line, 248, :none),
        :nothing
      )),
    (:line, 251, :none),
    "    AsyncCondition(callback::Function)\n\nCreate a async condition that calls the given `callback` function. The `callback` is passed one argument,\nthe async condition object itself.\n",
    (:line, 257, :none),
    (:function, (:call, :AsyncCondition, (:(::), :cb, :Function)), (:block,
        (:line, 258, :none),
        (:(=), :async, (:call, :AsyncCondition)),
        (:line, 259, :none),
        (:(=), :waiter, (:call, :Task, (:function, (:tuple,), (:block,
                (:line, 260, :none),
                (:while, (:call, :isopen, :async), (:block,
                    (:line, 261, :none),
                    (:(=), :success, (:try, (:block,
                          (:line, 262, :none),
                          (:call, :wait, :async),
                          (:line, 263, :none),
                          true
                        ), false, (:block,
                          (:line, 265, :none),
                          false
                        ))),
                    (:line, 267, :none),
                    (:&&, :success, (:call, :cb, :async))
                  ))
              )))),
        (:line, 272, :none),
        (:call, :enq_work, (:call, :current_task)),
        (:line, 273, :none),
        (:call, :yieldto, :waiter),
        (:line, 274, :none),
        (:return, :async)
      )),
    (:line, 279, :none),
    "    Timer(delay, repeat=0)\n\nCreate a timer that wakes up tasks waiting for it (by calling `wait` on the timer object) at\na specified interval.  Times are in seconds.  Waiting tasks are woken with an error when the\ntimer is closed (by `close`). Use `isopen` to check whether a timer is still active.\n",
    (:line, 286, :none),
    (:type, true, :Timer, (:block,
        (:line, 287, :none),
        (:(::), :handle, (:curly, :Ptr, :Void)),
        (:line, 288, :none),
        (:(::), :cond, :Condition),
        (:line, 289, :none),
        (:(::), :isopen, :Bool),
        (:line, 291, :none),
        (:function, (:call, :Timer, (:(::), :timeout, :Real), (:kw, (:(::), :repeat, :Real), 0.0)), (:block,
            (:line, 292, :none),
            (:||, (:call, :≥, :timeout, 0), (:call, :throw, (:call, :ArgumentError, (:string, "timer cannot have negative timeout of ", :timeout, " seconds")))),
            (:line, 293, :none),
            (:||, (:call, :≥, :repeat, 0), (:call, :throw, (:call, :ArgumentError, (:string, "timer cannot have negative repeat interval of ", :repeat, " seconds")))),
            (:line, 295, :none),
            (:(=), :this, (:call, :new, (:call, (:., :Libc, (:quote, #QuoteNode
                      :malloc
                    )), :_sizeof_uv_timer), (:call, :Condition), true)),
            (:line, 296, :none),
            (:(=), :err, (:ccall, (:quote, #QuoteNode
                  :uv_timer_init
                ), :Cint, (:tuple, (:curly, :Ptr, :Void), (:curly, :Ptr, :Void)), (:call, :eventloop), :this)),
            (:line, 297, :none),
            (:if, (:call, :(!=), :err, 0), (:block,
                (:line, 299, :none),
                (:call, (:., :Libc, (:quote, #QuoteNode
                      :free
                    )), (:., :this, (:quote, #QuoteNode
                      :handle
                    ))),
                (:line, 300, :none),
                (:(=), (:., :this, (:quote, #QuoteNode
                      :handle
                    )), :C_NULL),
                (:line, 301, :none),
                (:call, :throw, (:call, :UVError, "uv_make_timer", :err))
              )),
            (:line, 304, :none),
            (:call, :associate_julia_struct, (:., :this, (:quote, #QuoteNode
                  :handle
                )), :this),
            (:line, 305, :none),
            (:call, :preserve_handle, :this),
            (:line, 307, :none),
            (:ccall, (:quote, #QuoteNode
                :uv_update_time
              ), :Void, (:tuple, (:curly, :Ptr, :Void)), (:call, :eventloop)),
            (:line, 308, :none),
            (:ccall, (:quote, #QuoteNode
                :uv_timer_start
              ), :Cint, (:tuple, (:curly, :Ptr, :Void), (:curly, :Ptr, :Void), :UInt64, :UInt64), :this, (:(::), :uv_jl_timercb, (:curly, :Ptr, :Void)), (:call, :+, (:call, :UInt64, (:call, :round, (:call, :*, :timeout, 1000))), 1), (:call, :UInt64, (:call, :round, (:call, :*, :repeat, 1000)))),
            (:line, 311, :none),
            (:return, :this)
          ))
      )),
    (:line, 315, :none),
    (:(=), (:call, :unsafe_convert, (:(::), (:curly, :Type, (:curly, :Ptr, :Void))), (:(::), :t, :Timer)), (:block,
        (:line, 315, :none),
        (:., :t, (:quote, #QuoteNode
            :handle
          ))
      )),
    (:line, 317, :none),
    (:function, (:call, :wait, (:(::), :t, :Timer)), (:block,
        (:line, 318, :none),
        (:||, (:call, :isopen, :t), (:call, :throw, (:call, :EOFError))),
        (:line, 319, :none),
        (:call, :wait, (:., :t, (:quote, #QuoteNode
              :cond
            )))
      )),
    (:line, 322, :none),
    (:(=), (:call, :isopen, (:(::), :t, :Timer)), (:block,
        (:line, 322, :none),
        (:., :t, (:quote, #QuoteNode
            :isopen
          ))
      )),
    (:line, 324, :none),
    (:function, (:call, :close, (:(::), :t, :Timer)), (:block,
        (:line, 325, :none),
        (:if, (:call, :(!=), (:., :t, (:quote, #QuoteNode
                :handle
              )), :C_NULL), (:block,
            (:line, 326, :none),
            (:(=), (:., :t, (:quote, #QuoteNode
                  :isopen
                )), false),
            (:line, 327, :none),
            (:ccall, (:quote, #QuoteNode
                :uv_timer_stop
              ), :Cint, (:tuple, (:curly, :Ptr, :Void)), :t),
            (:line, 328, :none),
            (:ccall, (:quote, #QuoteNode
                :jl_close_uv
              ), :Void, (:tuple, (:curly, :Ptr, :Void)), :t)
          )),
        (:line, 330, :none),
        :nothing
      )),
    (:line, 333, :none),
    (:function, (:call, :_uv_hook_close, (:(::), :t, :Timer)), (:block,
        (:line, 334, :none),
        (:call, :unpreserve_handle, :t),
        (:line, 335, :none),
        (:call, :disassociate_julia_struct, :t),
        (:line, 336, :none),
        (:(=), (:., :t, (:quote, #QuoteNode
              :handle
            )), :C_NULL),
        (:line, 337, :none),
        (:(=), (:., :t, (:quote, #QuoteNode
              :isopen
            )), false),
        (:line, 338, :none),
        (:call, :notify_error, (:., :t, (:quote, #QuoteNode
              :cond
            )), (:call, :EOFError)),
        (:line, 339, :none),
        :nothing
      )),
    (:line, 342, :none),
    (:function, (:call, :uv_timercb, (:(::), :handle, (:curly, :Ptr, :Void))), (:block,
        (:line, 343, :none),
        (:(=), :t, (:macrocall, Symbol("@handle_as"), :handle, :Timer)),
        (:line, 344, :none),
        (:if, (:call, :(==), (:ccall, (:quote, #QuoteNode
                :uv_timer_get_repeat
              ), :UInt64, (:tuple, (:curly, :Ptr, :Void)), :t), 0), (:block,
            (:line, 346, :none),
            (:call, :close, :t)
          )),
        (:line, 348, :none),
        (:call, :notify, (:., :t, (:quote, #QuoteNode
              :cond
            ))),
        (:line, 349, :none),
        :nothing
      )),
    (:line, 352, :none),
    "    sleep(seconds)\n\nBlock the current task for a specified number of seconds. The minimum sleep time is 1\nmillisecond or input of `0.001`.\n",
    (:line, 358, :none),
    (:function, (:call, :sleep, (:(::), :sec, :Real)), (:block,
        (:line, 359, :none),
        (:||, (:call, :≥, :sec, 0), (:call, :throw, (:call, :ArgumentError, (:string, "cannot sleep for ", :sec, " seconds")))),
        (:line, 360, :none),
        (:call, :wait, (:call, :Timer, :sec)),
        (:line, 361, :none),
        :nothing
      )),
    (:line, 365, :none),
    "    Timer(callback::Function, delay, repeat=0)\n\nCreate a timer to call the given `callback` function. The `callback` is passed one argument,\nthe timer object itself. The callback will be invoked after the specified initial `delay`,\nand then repeating with the given `repeat` interval. If `repeat` is `0`, the timer is only\ntriggered once. Times are in seconds. A timer is stopped and has its resources freed by\ncalling `close` on it.\n",
    (:line, 374, :none),
    (:function, (:call, :Timer, (:(::), :cb, :Function), (:(::), :timeout, :Real), (:kw, (:(::), :repeat, :Real), 0.0)), (:block,
        (:line, 375, :none),
        (:(=), :t, (:call, :Timer, :timeout, :repeat)),
        (:line, 376, :none),
        (:(=), :waiter, (:call, :Task, (:function, (:tuple,), (:block,
                (:line, 377, :none),
                (:while, (:call, :isopen, :t), (:block,
                    (:line, 378, :none),
                    (:(=), :success, (:try, (:block,
                          (:line, 379, :none),
                          (:call, :wait, :t),
                          (:line, 380, :none),
                          true
                        ), false, (:block,
                          (:line, 382, :none),
                          false
                        ))),
                    (:line, 384, :none),
                    (:&&, :success, (:call, :cb, :t))
                  ))
              )))),
        (:line, 389, :none),
        (:call, :enq_work, (:call, :current_task)),
        (:line, 390, :none),
        (:call, :yieldto, :waiter),
        (:line, 391, :none),
        (:return, :t)
      ))
  ))