(:quote, (:block,
    (:line, 5, :none),
    (:typealias, (:curly, :AbstractVector, :T), (:curly, :AbstractArray, :T, 1)),
    (:line, 6, :none),
    (:typealias, (:curly, :AbstractMatrix, :T), (:curly, :AbstractArray, :T, 2)),
    (:line, 7, :none),
    (:typealias, (:curly, :AbstractVecOrMat, :T), (:curly, :Union, (:curly, :AbstractVector, :T), (:curly, :AbstractMatrix, :T))),
    (:line, 8, :none),
    (:typealias, :RangeIndex, (:curly, :Union, :Int, (:curly, :Range, :Int), (:curly, :AbstractUnitRange, :Int), :Colon)),
    (:line, 9, :none),
    (:typealias, :DimOrInd, (:curly, :Union, :Integer, :AbstractUnitRange)),
    (:line, 10, :none),
    (:typealias, :IntOrInd, (:curly, :Union, :Int, :AbstractUnitRange)),
    (:line, 11, :none),
    (:typealias, (:curly, :DimsOrInds, :N), (:curly, :NTuple, :N, :DimOrInd)),
    (:line, 12, :none),
    (:typealias, :NeedsShaping, (:curly, :Union, (:curly, :Tuple, :Integer, (:curly, :Vararg, :Integer)), (:curly, :Tuple, :OneTo, (:curly, :Vararg, :OneTo)))),
    (:line, 14, :none),
    (:macro, (:call, :_inline_pure_meta), (:block,
        (:line, 15, :none),
        (:call, :Expr, (:quote, #QuoteNode
            :meta
          ), (:quote, #QuoteNode
            :inline
          ), (:quote, #QuoteNode
            :pure
          ))
      )),
    (:line, 20, :none),
    (:(=), (:call, :vect), (:block,
        (:line, 20, :none),
        (:call, (:curly, :Array, :Any, 1), 0)
      )),
    (:line, 21, :none),
    (:(=), (:call, (:curly, :vect, :T), (:..., (:(::), :X, :T))), (:block,
        (:line, 21, :none),
        (:typed_comprehension, :T, (:generator, (:ref, :X, :i), (:(=), :i, (:(:), 1, (:call, :length, :X)))))
      )),
    (:line, 23, :none),
    (:function, (:call, :vect, (:..., :X)), (:block,
        (:line, 24, :none),
        (:(=), :T, (:call, :promote_typeof, (:..., :X))),
        (:line, 27, :none),
        (:call, :copy!, (:call, (:curly, :Array, :T, 1), (:call, :length, :X)), :X)
      )),
    (:line, 30, :none),
    "    size(A::AbstractArray, [dim...])\n\nReturns a tuple containing the dimensions of `A`. Optionally you can specify the\ndimension(s) you want the length of, and get the length of that dimension, or a tuple of the\nlengths of dimensions you asked for.\n\n```jldoctest\njulia> A = ones(2,3,4);\n\njulia> size(A, 2)\n3\n\njulia> size(A,3,2)\n(4,3)\n```\n",
    (:line, 47, :none),
    (:(=), (:call, (:curly, :size, :T, :N), (:(::), :t, (:curly, :AbstractArray, :T, :N)), :d), (:block,
        (:line, 47, :none),
        (:if, (:call, :(<=), :d, :N), (:ref, (:call, :size, :t), :d), 1)
      )),
    (:line, 48, :none),
    (:(=), (:call, (:curly, :size, :N), :x, (:(::), :d1, :Integer), (:(::), :d2, :Integer), (:(::), :dx, (:curly, :Vararg, :Integer, :N))), (:block,
        (:line, 48, :none),
        (:tuple, (:call, :size, :x, :d1), (:call, :size, :x, :d2), (:..., (:call, :ntuple, (:->, :k, (:block,
                  (:line, 48, :none),
                  (:call, :size, :x, (:ref, :dx, :k))
                )), (:curly, :Val, :N))))
      )),
    (:line, 50, :none),
    "    indices(A, d)\n\nReturns the valid range of indices for array `A` along dimension `d`.\n",
    (:line, 55, :none),
    (:function, (:call, (:curly, :indices, :T, :N), (:(::), :A, (:curly, :AbstractArray, :T, :N)), :d), (:block,
        (:line, 56, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 57, :none),
        (:if, (:call, :(<=), :d, :N), (:ref, (:call, :indices, :A), :d), (:call, :OneTo, 1))
      )),
    (:line, 60, :none),
    "    indices(A)\n\nReturns the tuple of valid indices for array `A`.\n",
    (:line, 65, :none),
    (:function, (:call, :indices, :A), (:block,
        (:line, 66, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 67, :none),
        (:call, :map, :OneTo, (:call, :size, :A))
      )),
    (:line, 73, :none),
    (:(=), (:call, (:curly, :indices1, :T), (:(::), :A, (:curly, :AbstractArray, :T, 0))), (:block,
        (:line, 73, :none),
        (:call, :OneTo, 1)
      )),
    (:line, 74, :none),
    (:(=), (:call, (:curly, :indices1, :T), (:(::), :A, (:curly, :AbstractArray, :T))), (:block,
        (:line, 74, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:ref, (:call, :indices, :A), 1)
        )
      )),
    (:line, 75, :none),
    (:(=), (:call, :indices1, :iter), (:block,
        (:line, 75, :none),
        (:call, :OneTo, (:call, :length, :iter))
      )),
    (:line, 77, :none),
    (:(=), (:call, :unsafe_indices, :A), (:block,
        (:line, 77, :none),
        (:call, :indices, :A)
      )),
    (:line, 78, :none),
    (:(=), (:call, :unsafe_indices, (:(::), :r, :Range)), (:block,
        (:line, 78, :none),
        (:tuple, (:call, :OneTo, (:call, :unsafe_length, :r)))
      )),
    (:line, 80, :none),
    "    linearindices(A)\n\nReturns a `UnitRange` specifying the valid range of indices for `A[i]`\nwhere `i` is an `Int`. For arrays with conventional indexing (indices\nstart at 1), or any multidimensional array, this is `1:length(A)`;\nhowever, for one-dimensional arrays with unconventional indices, this\nis `indices(A, 1)`.\n\nCalling this function is the \"safe\" way to write algorithms that\nexploit linear indexing.\n",
    (:line, 92, :none),
    (:(=), (:call, :linearindices, :A), (:block,
        (:line, 92, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :OneTo, (:call, :_length, :A))
        )
      )),
    (:line, 93, :none),
    (:(=), (:call, :linearindices, (:(::), :A, :AbstractVector)), (:block,
        (:line, 93, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :indices1, :A)
        )
      )),
    (:line, 94, :none),
    (:(=), (:call, (:curly, :eltype, :T), (:(::), (:curly, :Type, (:curly, :AbstractArray, :T)))), (:block,
        (:line, 94, :none),
        :T
      )),
    (:line, 95, :none),
    (:(=), (:call, (:curly, :eltype, :T, :N), (:(::), (:curly, :Type, (:curly, :AbstractArray, :T, :N)))), (:block,
        (:line, 95, :none),
        :T
      )),
    (:line, 96, :none),
    (:(=), (:call, (:curly, :elsize, :T), (:(::), (:curly, :AbstractArray, :T))), (:block,
        (:line, 96, :none),
        (:call, :sizeof, :T)
      )),
    (:line, 97, :none),
    "    ndims(A::AbstractArray) -> Integer\n\nReturns the number of dimensions of `A`.\n\n```jldoctest\njulia> A = ones(3,4,5);\n\njulia> ndims(A)\n3\n```\n",
    (:line, 109, :none),
    (:(=), (:call, (:curly, :ndims, :T, :N), (:(::), (:curly, :AbstractArray, :T, :N))), (:block,
        (:line, 109, :none),
        :N
      )),
    (:line, 110, :none),
    (:(=), (:call, (:curly, :ndims, :T, :N), (:(::), (:curly, :Type, (:curly, :AbstractArray, :T, :N)))), (:block,
        (:line, 110, :none),
        :N
      )),
    (:line, 111, :none),
    (:(=), (:call, (:curly, :ndims, (:<:, :T, :AbstractArray)), (:(::), (:curly, :Type, :T))), (:block,
        (:line, 111, :none),
        (:call, :ndims, (:call, :supertype, :T))
      )),
    (:line, 113, :none),
    "    length(A::AbstractArray) -> Integer\n\nReturns the number of elements in `A`.\n\n```jldoctest\njulia> A = ones(3,4,5);\n\njulia> length(A)\n60\n```\n",
    (:line, 125, :none),
    (:(=), (:call, :length, (:(::), :t, :AbstractArray)), (:block,
        (:line, 125, :none),
        (:call, :prod, (:call, :size, :t))
      )),
    (:line, 126, :none),
    (:(=), (:call, :_length, (:(::), :A, :AbstractArray)), (:block,
        (:line, 126, :none),
        (:call, :prod, (:call, :map, :unsafe_length, (:call, :indices, :A)))
      )),
    (:line, 127, :none),
    (:(=), (:call, :_length, :A), (:block,
        (:line, 127, :none),
        (:call, :length, :A)
      )),
    (:line, 128, :none),
    (:(=), (:call, :endof, (:(::), :a, :AbstractArray)), (:block,
        (:line, 128, :none),
        (:call, :length, :a)
      )),
    (:line, 129, :none),
    (:(=), (:call, :first, (:(::), :a, :AbstractArray)), (:block,
        (:line, 129, :none),
        (:ref, :a, (:call, :first, (:call, :eachindex, :a)))
      )),
    (:line, 131, :none),
    (:function, (:call, :first, :itr), (:block,
        (:line, 132, :none),
        (:(=), :state, (:call, :start, :itr)),
        (:line, 133, :none),
        (:&&, (:call, :done, :itr, :state), (:call, :throw, (:call, :ArgumentError, "collection must be non-empty"))),
        (:line, 134, :none),
        (:ref, (:call, :next, :itr, :state), 1)
      )),
    (:line, 136, :none),
    (:(=), (:call, :last, :a), (:block,
        (:line, 136, :none),
        (:ref, :a, :end)
      )),
    (:line, 138, :none),
    "    stride(A, k::Integer)\n\nReturns the distance in memory (in number of elements) between adjacent elements in dimension `k`.\n\n```jldoctest\njulia> A = ones(3,4,5);\n\njulia> stride(A,2)\n3\n\njulia> stride(A,3)\n12\n```\n",
    (:line, 153, :none),
    (:function, (:call, :stride, (:(::), :a, :AbstractArray), (:(::), :i, :Integer)), (:block,
        (:line, 154, :none),
        (:if, (:call, :>, :i, (:call, :ndims, :a)), (:block,
            (:line, 155, :none),
            (:return, (:call, :length, :a))
          )),
        (:line, 157, :none),
        (:(=), :s, 1),
        (:line, 158, :none),
        (:for, (:(=), :n, (:(:), 1, (:call, :-, :i, 1))), (:block,
            (:line, 159, :none),
            (:*=, :s, (:call, :size, :a, :n))
          )),
        (:line, 161, :none),
        (:return, :s)
      )),
    (:line, 164, :none),
    (:(=), (:call, (:curly, :strides, :T), (:(::), :A, (:curly, :AbstractArray, :T, 0))), (:block,
        (:line, 164, :none),
        (:tuple,)
      )),
    (:line, 165, :none),
    "    strides(A)\n\nReturns a tuple of the memory strides in each dimension.\n\n```jldoctest\njulia> A = ones(3,4,5);\n\njulia> strides(A)\n(1,3,12)\n```\n",
    (:line, 177, :none),
    (:(=), (:call, :strides, (:(::), :A, :AbstractArray)), (:block,
        (:line, 177, :none),
        (:call, :_strides, (:tuple, 1), :A)
      )),
    (:line, 178, :none),
    (:(=), (:call, (:curly, :_strides, :T, :N), (:(::), :out, (:curly, :NTuple, :N)), (:(::), :A, (:curly, :AbstractArray, :T, :N))), (:block,
        (:line, 178, :none),
        :out
      )),
    (:line, 179, :none),
    (:function, (:call, (:curly, :_strides, :M, :T, :N), (:(::), :out, (:curly, :NTuple, :M)), (:(::), :A, (:curly, :AbstractArray, :T, :N))), (:block,
        (:line, 180, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 181, :none),
        (:call, :_strides, (:tuple, (:..., :out), (:call, :*, (:ref, :out, :M), (:call, :size, :A, :M))), :A)
      )),
    (:line, 184, :none),
    (:function, (:call, :isassigned, (:(::), :a, :AbstractArray), (:..., (:(::), :i, :Int))), (:block,
        (:line, 185, :none),
        (:try, (:block,
            (:line, 186, :none),
            (:ref, :a, (:..., :i)),
            (:line, 187, :none),
            true
          ), :e, (:block,
            (:line, 189, :none),
            (:if, (:||, (:call, :isa, :e, :BoundsError), (:call, :isa, :e, :UndefRefError)), (:block,
                (:line, 190, :none),
                (:return, false)
              ), (:block,
                (:line, 192, :none),
                (:call, :rethrow, :e)
              ))
          ))
      )),
    (:line, 198, :none),
    (:function, (:call, :trailingsize, :A, :n), (:block,
        (:line, 199, :none),
        (:(=), :s, 1),
        (:line, 200, :none),
        (:for, (:(=), :i, (:(:), :n, (:call, :ndims, :A))), (:block,
            (:line, 201, :none),
            (:*=, :s, (:call, :size, :A, :i))
          )),
        (:line, 203, :none),
        (:return, :s)
      )),
    (:line, 205, :none),
    (:function, (:call, :trailingsize, (:(::), :inds, :Indices), :n), (:block,
        (:line, 206, :none),
        (:(=), :s, 1),
        (:line, 207, :none),
        (:for, (:(=), :i, (:(:), :n, (:call, :length, :inds))), (:block,
            (:line, 208, :none),
            (:*=, :s, (:call, :unsafe_length, (:ref, :inds, :i)))
          )),
        (:line, 210, :none),
        (:return, :s)
      )),
    (:line, 213, :none),
    (:function, (:call, :trailingsize, (:(::), :inds, :Indices)), (:block,
        (:line, 214, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 215, :none),
        (:call, :prod, (:call, :map, :unsafe_length, :inds))
      )),
    (:line, 220, :none),
    (:abstract, :LinearIndexing),
    (:line, 221, :none),
    (:type, false, (:<:, :LinearFast, :LinearIndexing), (:block,
        (:line, 221, :none)
      )),
    (:line, 222, :none),
    (:type, false, (:<:, :LinearSlow, :LinearIndexing), (:block,
        (:line, 222, :none)
      )),
    (:line, 224, :none),
    "    Base.linearindexing(A)\n\n`linearindexing` defines how an AbstractArray most efficiently accesses its elements. If\n`Base.linearindexing(A)` returns `Base.LinearFast()`, this means that linear indexing with\nonly one index is an efficient operation. If it instead returns `Base.LinearSlow()` (by\ndefault), this means that the array intrinsically accesses its elements with indices\nspecified for every dimension. Since converting a linear index to multiple indexing\nsubscripts is typically very expensive, this provides a traits-based mechanism to enable\nefficient generic code for all array types.\n\nAn abstract array subtype `MyArray` that wishes to opt into fast linear indexing behaviors\nshould define `linearindexing` in the type-domain:\n\n    Base.linearindexing{T<:MyArray}(::Type{T}) = Base.LinearFast()\n",
    (:line, 240, :none),
    (:(=), (:call, :linearindexing, (:(::), :A, :AbstractArray)), (:block,
        (:line, 240, :none),
        (:call, :linearindexing, (:call, :typeof, :A))
      )),
    (:line, 241, :none),
    (:(=), (:call, (:curly, :linearindexing, (:<:, :T, :AbstractArray)), (:(::), (:curly, :Type, :T))), (:block,
        (:line, 241, :none),
        (:call, :LinearSlow)
      )),
    (:line, 242, :none),
    (:(=), (:call, (:curly, :linearindexing, (:<:, :T, :Array)), (:(::), (:curly, :Type, :T))), (:block,
        (:line, 242, :none),
        (:call, :LinearFast)
      )),
    (:line, 243, :none),
    (:(=), (:call, (:curly, :linearindexing, (:<:, :T, :Range)), (:(::), (:curly, :Type, :T))), (:block,
        (:line, 243, :none),
        (:call, :LinearFast)
      )),
    (:line, 245, :none),
    (:(=), (:call, :linearindexing, (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 245, :none),
        (:call, :linearindexing, (:call, :linearindexing, :A), (:call, :linearindexing, :B))
      )),
    (:line, 246, :none),
    (:(=), (:call, :linearindexing, (:(::), :A, :AbstractArray), (:..., (:(::), :B, :AbstractArray))), (:block,
        (:line, 246, :none),
        (:call, :linearindexing, (:call, :linearindexing, :A), (:call, :linearindexing, (:..., :B)))
      )),
    (:line, 247, :none),
    (:(=), (:call, :linearindexing, (:(::), :LinearFast), (:(::), :LinearFast)), (:block,
        (:line, 247, :none),
        (:call, :LinearFast)
      )),
    (:line, 248, :none),
    (:(=), (:call, :linearindexing, (:(::), :LinearIndexing), (:(::), :LinearIndexing)), (:block,
        (:line, 248, :none),
        (:call, :LinearSlow)
      )),
    (:line, 266, :none),
    "    checkbounds(Bool, A, I...)\n\nReturn `true` if the specified indices `I` are in bounds for the given\narray `A`. Subtypes of `AbstractArray` should specialize this method\nif they need to provide custom bounds checking behaviors; however, in\nmany cases one can rely on `A`'s indices and `checkindex`.\n\nSee also `checkindex`.\n",
    (:line, 276, :none),
    (:function, (:call, :checkbounds, (:(::), (:curly, :Type, :Bool)), (:(::), :A, :AbstractArray), (:..., :I)), (:block,
        (:line, 277, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 278, :none),
        (:call, :checkbounds_indices, :Bool, (:call, :indices, :A), :I)
      )),
    (:line, 280, :none),
    (:function, (:call, :checkbounds, (:(::), (:curly, :Type, :Bool)), (:(::), :A, :AbstractArray), (:(::), :I, (:curly, :AbstractArray, :Bool))), (:block,
        (:line, 281, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 282, :none),
        (:call, :checkbounds_logical, :Bool, :A, :I)
      )),
    (:line, 285, :none),
    "    checkbounds(A, I...)\n\nThrow an error if the specified indices `I` are not in bounds for the given array `A`.\n",
    (:line, 290, :none),
    (:function, (:call, :checkbounds, (:(::), :A, :AbstractArray), (:..., :I)), (:block,
        (:line, 291, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 292, :none),
        (:||, (:call, :checkbounds, :Bool, :A, (:..., :I)), (:call, :throw_boundserror, :A, :I)),
        (:line, 293, :none),
        :nothing
      )),
    (:line, 295, :none),
    (:(=), (:call, :checkbounds, (:(::), :A, :AbstractArray)), (:block,
        (:line, 295, :none),
        (:call, :checkbounds, :A, 1)
      )),
    (:line, 297, :none),
    "    checkbounds_indices(Bool, IA, I)\n\nReturn `true` if the \"requested\" indices in the tuple `I` fall within\nthe bounds of the \"permitted\" indices specified by the tuple\n`IA`. This function recursively consumes elements of these tuples,\nusually in a 1-for-1 fashion,\n\n    checkbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &\n                                                          checkbounds_indices(Bool, IA, I)\n\nNote that `checkindex` is being used to perform the actual\nbounds-check for a single dimension of the array.\n\nThere are two important exceptions to the 1-1 rule: linear indexing and\nCartesianIndex{N}, both of which may \"consume\" more than one element\nof `IA`.\n",
    (:line, 315, :none),
    (:function, (:call, :checkbounds_indices, (:(::), (:curly, :Type, :Bool)), (:(::), :IA, :Tuple), (:(::), :I, :Tuple)), (:block,
        (:line, 316, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 317, :none),
        (:call, :&, (:call, :checkindex, :Bool, (:ref, :IA, 1), (:ref, :I, 1)), (:call, :checkbounds_indices, :Bool, (:call, :tail, :IA), (:call, :tail, :I)))
      )),
    (:line, 319, :none),
    (:(=), (:call, :checkbounds_indices, (:(::), (:curly, :Type, :Bool)), (:(::), (:curly, :Tuple)), (:(::), (:curly, :Tuple))), (:block,
        (:line, 319, :none),
        true
      )),
    (:line, 320, :none),
    (:(=), (:call, :checkbounds_indices, (:(::), (:curly, :Type, :Bool)), (:(::), (:curly, :Tuple)), (:(::), :I, (:curly, :Tuple, :Any))), (:block,
        (:line, 320, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :checkindex, :Bool, (:(:), 1, 1), (:ref, :I, 1))
        )
      )),
    (:line, 321, :none),
    (:function, (:call, :checkbounds_indices, (:(::), (:curly, :Type, :Bool)), (:(::), (:curly, :Tuple)), (:(::), :I, :Tuple)), (:block,
        (:line, 322, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 323, :none),
        (:call, :&, (:call, :checkindex, :Bool, (:(:), 1, 1), (:ref, :I, 1)), (:call, :checkbounds_indices, :Bool, (:tuple,), (:call, :tail, :I)))
      )),
    (:line, 325, :none),
    (:function, (:call, :checkbounds_indices, (:(::), (:curly, :Type, :Bool)), (:(::), :IA, (:curly, :Tuple, :Any)), (:(::), :I, (:curly, :Tuple, :Any))), (:block,
        (:line, 326, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 327, :none),
        (:call, :checkindex, :Bool, (:ref, :IA, 1), (:ref, :I, 1))
      )),
    (:line, 329, :none),
    (:function, (:call, :checkbounds_indices, (:(::), (:curly, :Type, :Bool)), (:(::), :IA, :Tuple), (:(::), :I, (:curly, :Tuple, :Any))), (:block,
        (:line, 330, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 331, :none),
        (:call, :checkindex, :Bool, (:call, :OneTo, (:call, :trailingsize, :IA)), (:ref, :I, 1))
      )),
    (:line, 334, :none),
    "    checkbounds_logical(Bool, A, I::AbstractArray{Bool})\n\nReturn `true` if the logical array `I` is consistent with the indices\nof `A`. `I` and `A` should have the same size and compatible indices.\n",
    (:line, 340, :none),
    (:function, (:call, :checkbounds_logical, (:(::), (:curly, :Type, :Bool)), (:(::), :A, :AbstractArray), (:(::), :I, (:curly, :AbstractArray, :Bool))), (:block,
        (:line, 341, :none),
        (:call, :(==), (:call, :indices, :A), (:call, :indices, :I))
      )),
    (:line, 343, :none),
    (:function, (:call, :checkbounds_logical, (:(::), (:curly, :Type, :Bool)), (:(::), :A, :AbstractArray), (:(::), :I, (:curly, :AbstractVector, :Bool))), (:block,
        (:line, 344, :none),
        (:call, :(==), (:call, :length, :A), (:call, :length, :I))
      )),
    (:line, 346, :none),
    (:function, (:call, :checkbounds_logical, (:(::), (:curly, :Type, :Bool)), (:(::), :A, :AbstractVector), (:(::), :I, (:curly, :AbstractArray, :Bool))), (:block,
        (:line, 347, :none),
        (:call, :(==), (:call, :length, :A), (:call, :length, :I))
      )),
    (:line, 349, :none),
    (:function, (:call, :checkbounds_logical, (:(::), (:curly, :Type, :Bool)), (:(::), :A, :AbstractVector), (:(::), :I, (:curly, :AbstractVector, :Bool))), (:block,
        (:line, 350, :none),
        (:call, :(==), (:call, :indices, :A), (:call, :indices, :I))
      )),
    (:line, 353, :none),
    "    checkbounds_logical(A, I::AbstractArray{Bool})\n\nThrow an error if the logical array `I` is inconsistent with the indices of `A`.\n",
    (:line, 358, :none),
    (:function, (:call, :checkbounds_logical, :A, (:(::), :I, (:curly, :AbstractVector, :Bool))), (:block,
        (:line, 359, :none),
        (:||, (:call, :checkbounds_logical, :Bool, :A, :I), (:call, :throw_boundserror, :A, :I)),
        (:line, 360, :none),
        :nothing
      )),
    (:line, 363, :none),
    (:(=), (:call, :throw_boundserror, :A, :I), (:block,
        (:line, 363, :none),
        (:block,
          (:macrocall, Symbol("@_noinline_meta")),
          (:call, :throw, (:call, :BoundsError, :A, :I))
        )
      )),
    (:line, 366, :none),
    "    checkindex(Bool, inds::AbstractUnitRange, index)\n\nReturn `true` if the given `index` is within the bounds of\n`inds`. Custom types that would like to behave as indices for all\narrays can extend this method in order to provide a specialized bounds\nchecking implementation.\n",
    (:line, 374, :none),
    (:(=), (:call, :checkindex, (:(::), (:curly, :Type, :Bool)), (:(::), :inds, :AbstractUnitRange), :i), (:block,
        (:line, 374, :none),
        (:call, :throw, (:call, :ArgumentError, (:string, "unable to check bounds for indices of type ", (:call, :typeof, :i))))
      )),
    (:line, 375, :none),
    (:(=), (:call, :checkindex, (:(::), (:curly, :Type, :Bool)), (:(::), :inds, :AbstractUnitRange), (:(::), :i, :Real)), (:block,
        (:line, 375, :none),
        (:call, :&, (:call, :(<=), (:call, :first, :inds), :i), (:call, :(<=), :i, (:call, :last, :inds)))
      )),
    (:line, 376, :none),
    (:(=), (:call, :checkindex, (:(::), (:curly, :Type, :Bool)), (:(::), :inds, :AbstractUnitRange), (:(::), :Colon)), (:block,
        (:line, 376, :none),
        true
      )),
    (:line, 377, :none),
    (:function, (:call, :checkindex, (:(::), (:curly, :Type, :Bool)), (:(::), :inds, :AbstractUnitRange), (:(::), :r, :Range)), (:block,
        (:line, 378, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 379, :none),
        (:call, :|, (:call, :isempty, :r), (:call, :&, (:call, :checkindex, :Bool, :inds, (:call, :first, :r)), (:call, :checkindex, :Bool, :inds, (:call, :last, :r))))
      )),
    (:line, 381, :none),
    (:(=), (:call, (:curly, :checkindex, :N), (:(::), (:curly, :Type, :Bool)), (:(::), :indx, :AbstractUnitRange), (:(::), :I, (:curly, :AbstractArray, :Bool, :N))), (:block,
        (:line, 381, :none),
        (:&&, (:call, :(==), :N, 1), (:call, :(==), :indx, (:call, :indices1, :I)))
      )),
    (:line, 382, :none),
    (:function, (:call, :checkindex, (:(::), (:curly, :Type, :Bool)), (:(::), :inds, :AbstractUnitRange), (:(::), :I, :AbstractArray)), (:block,
        (:line, 383, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 384, :none),
        (:(=), :b, true),
        (:line, 385, :none),
        (:for, (:(=), :i, :I), (:block,
            (:line, 386, :none),
            (:&=, :b, (:call, :checkindex, :Bool, :inds, :i))
          )),
        (:line, 388, :none),
        :b
      )),
    (:line, 396, :none),
    "    similar(array, [element_type=eltype(array)], [dims=size(array)])\n\nCreate an uninitialized mutable array with the given element type and size, based upon the\ngiven source array. The second and third arguments are both optional, defaulting to the\ngiven array's `eltype` and `size`. The dimensions may be specified either as a single tuple\nargument or as a series of integer arguments.\n\nCustom AbstractArray subtypes may choose which specific array type is best-suited to return\nfor the given element type and dimensionality. If they do not specialize this method, the\ndefault is an `Array{element_type}(dims...)`.\n\nFor example, `similar(1:10, 1, 4)` returns an uninitialized `Array{Int,2}` since ranges are\nneither mutable nor support 2 dimensions:\n\n    julia> similar(1:10, 1, 4)\n    1×4 Array{Int64,2}:\n     4419743872  4374413872  4419743888  0\n\nConversely, `similar(trues(10,10), 2)` returns an uninitialized `BitVector` with two\nelements since `BitArray`s are both mutable and can support 1-dimensional arrays:\n\n    julia> similar(trues(10,10), 2)\n    2-element BitArray{1}:\n     false\n     false\n\nSince `BitArray`s can only store elements of type `Bool`, however, if you request a\ndifferent element type it will create a regular `Array` instead:\n\n    julia> similar(falses(10), Float64, 2, 4)\n    2×4 Array{Float64,2}:\n     2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n     2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n\n",
    (:line, 432, :none),
    (:(=), (:call, (:curly, :similar, :T), (:(::), :a, (:curly, :AbstractArray, :T))), (:block,
        (:line, 432, :none),
        (:call, :similar, :a, :T)
      )),
    (:line, 433, :none),
    (:(=), (:call, (:curly, :similar, :T), (:(::), :a, :AbstractArray), (:(::), (:curly, :Type, :T))), (:block,
        (:line, 433, :none),
        (:call, :similar, :a, :T, (:call, :to_shape, (:call, :indices, :a)))
      )),
    (:line, 434, :none),
    (:(=), (:call, (:curly, :similar, :T), (:(::), :a, (:curly, :AbstractArray, :T)), (:(::), :dims, :Tuple)), (:block,
        (:line, 434, :none),
        (:call, :similar, :a, :T, (:call, :to_shape, :dims))
      )),
    (:line, 435, :none),
    (:(=), (:call, (:curly, :similar, :T), (:(::), :a, (:curly, :AbstractArray, :T)), (:..., (:(::), :dims, :DimOrInd))), (:block,
        (:line, 435, :none),
        (:call, :similar, :a, :T, (:call, :to_shape, :dims))
      )),
    (:line, 436, :none),
    (:(=), (:call, (:curly, :similar, :T), (:(::), :a, :AbstractArray), (:(::), (:curly, :Type, :T)), (:..., (:(::), :dims, :DimOrInd))), (:block,
        (:line, 436, :none),
        (:call, :similar, :a, :T, (:call, :to_shape, :dims))
      )),
    (:line, 437, :none),
    (:(=), (:call, (:curly, :similar, :T), (:(::), :a, :AbstractArray), (:(::), (:curly, :Type, :T)), (:(::), :dims, :NeedsShaping)), (:block,
        (:line, 437, :none),
        (:call, :similar, :a, :T, (:call, :to_shape, :dims))
      )),
    (:line, 439, :none),
    (:(=), (:call, (:curly, :similar, :T, :N), (:(::), :a, :AbstractArray), (:(::), (:curly, :Type, :T)), (:(::), :dims, (:curly, :Dims, :N))), (:block,
        (:line, 439, :none),
        (:call, (:curly, :Array, :T, :N), :dims)
      )),
    (:line, 441, :none),
    (:(=), (:call, :to_shape, (:(::), (:curly, :Tuple))), (:block,
        (:line, 441, :none),
        (:tuple,)
      )),
    (:line, 442, :none),
    (:(=), (:call, :to_shape, (:(::), :dims, :Dims)), (:block,
        (:line, 442, :none),
        :dims
      )),
    (:line, 443, :none),
    (:(=), (:call, :to_shape, (:(::), :dims, :DimsOrInds)), (:block,
        (:line, 443, :none),
        (:call, :map, :to_shape, :dims)
      )),
    (:line, 445, :none),
    (:(=), (:call, :to_shape, (:(::), :i, :Int)), (:block,
        (:line, 445, :none),
        :i
      )),
    (:line, 446, :none),
    (:(=), (:call, :to_shape, (:(::), :i, :Integer)), (:block,
        (:line, 446, :none),
        (:call, :Int, :i)
      )),
    (:line, 447, :none),
    (:(=), (:call, :to_shape, (:(::), :r, :OneTo)), (:block,
        (:line, 447, :none),
        (:call, :Int, (:call, :last, :r))
      )),
    (:line, 448, :none),
    (:(=), (:call, :to_shape, (:(::), :r, :AbstractUnitRange)), (:block,
        (:line, 448, :none),
        :r
      )),
    (:line, 450, :none),
    "    similar(storagetype, indices)\n\nCreate an uninitialized mutable array analogous to that specified by\n`storagetype`, but with `indices` specified by the last\nargument. `storagetype` might be a type or a function.\n\n**Examples**:\n\n    similar(Array{Int}, indices(A))\n\ncreates an array that \"acts like\" an `Array{Int}` (and might indeed be\nbacked by one), but which is indexed identically to `A`. If `A` has\nconventional indexing, this will be identical to\n`Array{Int}(size(A))`, but if `A` has unconventional indexing then the\nindices of the result will match `A`.\n\n    similar(BitArray, (indices(A, 2),))\n\nwould create a 1-dimensional logical array whose indices match those\nof the columns of `A`.\n\n    similar(dims->zeros(Int, dims), indices(A))\n\nwould create an array of `Int`, initialized to zero, matching the\nindices of `A`.\n",
    (:line, 477, :none),
    (:(=), (:call, :similar, :f, (:(::), :shape, :Tuple)), (:block,
        (:line, 477, :none),
        (:call, :f, (:call, :to_shape, :shape))
      )),
    (:line, 478, :none),
    (:(=), (:call, :similar, :f, (:..., (:(::), :dims, :DimOrInd))), (:block,
        (:line, 478, :none),
        (:call, :similar, :f, :dims)
      )),
    (:line, 482, :none),
    (:function, (:call, :copy!, (:(::), :dest, :AbstractArray), :src), (:block,
        (:line, 483, :none),
        (:(=), :destiter, (:call, :eachindex, :dest)),
        (:line, 484, :none),
        (:(=), :state, (:call, :start, :destiter)),
        (:line, 485, :none),
        (:for, (:(=), :x, :src), (:block,
            (:line, 486, :none),
            (:(=), (:tuple, :i, :state), (:call, :next, :destiter, :state)),
            (:line, 487, :none),
            (:(=), (:ref, :dest, :i), :x)
          )),
        (:line, 489, :none),
        (:return, :dest)
      )),
    (:line, 492, :none),
    (:function, (:call, :copy!, (:(::), :dest, :AbstractArray), (:(::), :dstart, :Integer), :src), (:block,
        (:line, 493, :none),
        (:(=), :i, (:call, :Int, :dstart)),
        (:line, 494, :none),
        (:for, (:(=), :x, :src), (:block,
            (:line, 495, :none),
            (:(=), (:ref, :dest, :i), :x),
            (:line, 496, :none),
            (:+=, :i, 1)
          )),
        (:line, 498, :none),
        (:return, :dest)
      )),
    (:line, 502, :none),
    (:function, (:call, :copy!, (:(::), :dest, :AbstractArray), (:(::), :dstart, :Integer), :src, (:(::), :sstart, :Integer)), (:block,
        (:line, 503, :none),
        (:if, (:call, :<, :sstart, 1), (:block,
            (:line, 504, :none),
            (:call, :throw, (:call, :ArgumentError, (:call, :string, "source start offset (", :sstart, ") is < 1")))
          )),
        (:line, 506, :none),
        (:(=), :st, (:call, :start, :src)),
        (:line, 507, :none),
        (:for, (:(=), :j, (:(:), 1, (:call, :-, :sstart, 1))), (:block,
            (:line, 508, :none),
            (:if, (:call, :done, :src, :st), (:block,
                (:line, 509, :none),
                (:call, :throw, (:call, :ArgumentError, (:call, :string, "source has fewer elements than required, ", "expected at least ", :sstart, ", got ", (:call, :-, :j, 1))))
              )),
            (:line, 512, :none),
            (:(=), (:tuple, :_, :st), (:call, :next, :src, :st))
          )),
        (:line, 514, :none),
        (:(=), :dn, (:call, :done, :src, :st)),
        (:line, 515, :none),
        (:if, :dn, (:block,
            (:line, 516, :none),
            (:call, :throw, (:call, :ArgumentError, (:call, :string, "source has fewer elements than required, ", "expected at least ", :sstart, ", got ", (:call, :-, :sstart, 1))))
          )),
        (:line, 519, :none),
        (:(=), :i, (:call, :Int, :dstart)),
        (:line, 520, :none),
        (:while, (:call, :!, :dn), (:block,
            (:line, 521, :none),
            (:(=), (:tuple, :val, :st), (:call, :next, :src, :st)),
            (:line, 522, :none),
            (:(=), (:ref, :dest, :i), :val),
            (:line, 523, :none),
            (:+=, :i, 1),
            (:line, 524, :none),
            (:(=), :dn, (:call, :done, :src, :st))
          )),
        (:line, 526, :none),
        (:return, :dest)
      )),
    (:line, 530, :none),
    (:function, (:call, :copy!, (:(::), :dest, :AbstractArray), (:(::), :dstart, :Integer), :src, (:(::), :sstart, :Integer), (:(::), :n, :Integer)), (:block,
        (:line, 531, :none),
        (:&&, (:call, :<, :n, 0), (:call, :throw, (:call, :ArgumentError, (:call, :string, "tried to copy n=", :n, " elements, but n should be nonnegative")))),
        (:line, 532, :none),
        (:&&, (:call, :(==), :n, 0), (:return, :dest)),
        (:line, 533, :none),
        (:(=), :dmax, (:call, :-, (:call, :+, :dstart, :n), 1)),
        (:line, 534, :none),
        (:(=), :inds, (:call, :linearindices, :dest)),
        (:line, 535, :none),
        (:if, (:call, :|, (:||, (:call, :∉, :dstart, :inds), (:call, :∉, :dmax, :inds)), (:call, :<, :sstart, 1)), (:block,
            (:line, 536, :none),
            (:&&, (:call, :<, :sstart, 1), (:call, :throw, (:call, :ArgumentError, (:call, :string, "source start offset (", :sstart, ") is < 1")))),
            (:line, 537, :none),
            (:call, :throw, (:call, :BoundsError, :dest, (:(:), :dstart, :dmax)))
          )),
        (:line, 539, :none),
        (:(=), :st, (:call, :start, :src)),
        (:line, 540, :none),
        (:for, (:(=), :j, (:(:), 1, (:call, :-, :sstart, 1))), (:block,
            (:line, 541, :none),
            (:if, (:call, :done, :src, :st), (:block,
                (:line, 542, :none),
                (:call, :throw, (:call, :ArgumentError, (:call, :string, "source has fewer elements than required, ", "expected at least ", :sstart, ", got ", (:call, :-, :j, 1))))
              )),
            (:line, 545, :none),
            (:(=), (:tuple, :_, :st), (:call, :next, :src, :st))
          )),
        (:line, 547, :none),
        (:(=), :i, (:call, :Int, :dstart)),
        (:line, 548, :none),
        (:while, (:&&, (:call, :(<=), :i, :dmax), (:call, :!, (:call, :done, :src, :st))), (:block,
            (:line, 549, :none),
            (:(=), (:tuple, :val, :st), (:call, :next, :src, :st)),
            (:line, 550, :none),
            (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :dest, :i), :val)),
            (:line, 551, :none),
            (:+=, :i, 1)
          )),
        (:line, 553, :none),
        (:&&, (:call, :(<=), :i, :dmax), (:call, :throw, (:call, :BoundsError, :dest, :i))),
        (:line, 554, :none),
        (:return, :dest)
      )),
    (:line, 560, :none),
    (:(=), (:call, :copy!, (:(::), :dest, :AbstractArray), (:(::), :src, :AbstractArray)), (:block,
        (:line, 560, :none),
        (:call, :copy!, (:call, :linearindexing, :dest), :dest, (:call, :linearindexing, :src), :src)
      )),
    (:line, 563, :none),
    (:function, (:call, :copy!, (:(::), :LinearIndexing), (:(::), :dest, :AbstractArray), (:(::), :LinearIndexing), (:(::), :src, :AbstractArray)), (:block,
        (:line, 564, :none),
        (:(=), (:tuple, :destinds, :srcinds), (:tuple, (:call, :linearindices, :dest), (:call, :linearindices, :src))),
        (:line, 565, :none),
        (:||, (:call, :isempty, :srcinds), (:||, (:&&, (:call, :∈, (:call, :first, :srcinds), :destinds), (:call, :∈, (:call, :last, :srcinds), :destinds)), (:call, :throw, (:call, :BoundsError, :dest, :srcinds)))),
        (:line, 566, :none),
        (:macrocall, Symbol("@inbounds"), (:for, (:(=), :i, :srcinds), (:block,
              (:line, 567, :none),
              (:(=), (:ref, :dest, :i), (:ref, :src, :i))
            ))),
        (:line, 569, :none),
        (:return, :dest)
      )),
    (:line, 572, :none),
    (:function, (:call, :copy!, (:(::), :LinearIndexing), (:(::), :dest, :AbstractArray), (:(::), :LinearSlow), (:(::), :src, :AbstractArray)), (:block,
        (:line, 573, :none),
        (:(=), (:tuple, :destinds, :srcinds), (:tuple, (:call, :linearindices, :dest), (:call, :linearindices, :src))),
        (:line, 574, :none),
        (:||, (:call, :isempty, :srcinds), (:||, (:&&, (:call, :∈, (:call, :first, :srcinds), :destinds), (:call, :∈, (:call, :last, :srcinds), :destinds)), (:call, :throw, (:call, :BoundsError, :dest, :srcinds)))),
        (:line, 575, :none),
        (:(=), :i, 0),
        (:line, 576, :none),
        (:macrocall, Symbol("@inbounds"), (:for, (:(=), :a, :src), (:block,
              (:line, 577, :none),
              (:(=), (:ref, :dest, (:+=, :i, 1)), :a)
            ))),
        (:line, 579, :none),
        (:return, :dest)
      )),
    (:line, 582, :none),
    (:function, (:call, :copy!, (:(::), :dest, :AbstractArray), (:(::), :dstart, :Integer), (:(::), :src, :AbstractArray)), (:block,
        (:line, 583, :none),
        (:call, :copy!, :dest, :dstart, :src, (:call, :first, (:call, :linearindices, :src)), (:call, :_length, :src))
      )),
    (:line, 586, :none),
    (:function, (:call, :copy!, (:(::), :dest, :AbstractArray), (:(::), :dstart, :Integer), (:(::), :src, :AbstractArray), (:(::), :sstart, :Integer)), (:block,
        (:line, 587, :none),
        (:(=), :srcinds, (:call, :linearindices, :src)),
        (:line, 588, :none),
        (:||, (:call, :∈, :sstart, :srcinds), (:call, :throw, (:call, :BoundsError, :src, :sstart))),
        (:line, 589, :none),
        (:call, :copy!, :dest, :dstart, :src, :sstart, (:call, :+, (:call, :-, (:call, :last, :srcinds), :sstart), 1))
      )),
    (:line, 592, :none),
    (:function, (:call, :copy!, (:(::), :dest, :AbstractArray), (:(::), :dstart, :Integer), (:(::), :src, :AbstractArray), (:(::), :sstart, :Integer), (:(::), :n, :Integer)), (:block,
        (:line, 595, :none),
        (:&&, (:call, :(==), :n, 0), (:return, :dest)),
        (:line, 596, :none),
        (:&&, (:call, :<, :n, 0), (:call, :throw, (:call, :ArgumentError, (:call, :string, "tried to copy n=", :n, " elements, but n should be nonnegative")))),
        (:line, 597, :none),
        (:(=), (:tuple, :destinds, :srcinds), (:tuple, (:call, :linearindices, :dest), (:call, :linearindices, :src))),
        (:line, 598, :none),
        (:||, (:&&, (:call, :∈, :dstart, :destinds), (:call, :∈, (:call, :-, (:call, :+, :dstart, :n), 1), :destinds)), (:call, :throw, (:call, :BoundsError, :dest, (:(:), :dstart, (:call, :-, (:call, :+, :dstart, :n), 1))))),
        (:line, 599, :none),
        (:||, (:&&, (:call, :∈, :sstart, :srcinds), (:call, :∈, (:call, :-, (:call, :+, :sstart, :n), 1), :srcinds)), (:call, :throw, (:call, :BoundsError, :src, (:(:), :sstart, (:call, :-, (:call, :+, :sstart, :n), 1))))),
        (:line, 600, :none),
        (:macrocall, Symbol("@inbounds"), (:for, (:(=), :i, (:(:), 0, (:call, :-, :n, 1))), (:block,
              (:line, 601, :none),
              (:(=), (:ref, :dest, (:call, :+, :dstart, :i)), (:ref, :src, (:call, :+, :sstart, :i)))
            ))),
        (:line, 603, :none),
        (:return, :dest)
      )),
    (:line, 606, :none),
    (:function, (:call, :copy, (:(::), :a, :AbstractArray)), (:block,
        (:line, 607, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 608, :none),
        (:call, :copymutable, :a)
      )),
    (:line, 611, :none),
    (:function, (:call, (:curly, :copy!, :R, :S), (:(::), :B, (:curly, :AbstractVecOrMat, :R)), (:(::), :ir_dest, (:curly, :Range, :Int)), (:(::), :jr_dest, (:curly, :Range, :Int)), (:(::), :A, (:curly, :AbstractVecOrMat, :S)), (:(::), :ir_src, (:curly, :Range, :Int)), (:(::), :jr_src, (:curly, :Range, :Int))), (:block,
        (:line, 613, :none),
        (:if, (:call, :(!=), (:call, :length, :ir_dest), (:call, :length, :ir_src)), (:block,
            (:line, 614, :none),
            (:call, :throw, (:call, :ArgumentError, (:call, :string, "source and destination must have same size (got ", (:call, :length, :ir_src), " and ", (:call, :length, :ir_dest), ")")))
          )),
        (:line, 617, :none),
        (:if, (:call, :(!=), (:call, :length, :jr_dest), (:call, :length, :jr_src)), (:block,
            (:line, 618, :none),
            (:call, :throw, (:call, :ArgumentError, (:call, :string, "source and destination must have same size (got ", (:call, :length, :jr_src), " and ", (:call, :length, :jr_dest), ")")))
          )),
        (:line, 621, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :B, :ir_dest, :jr_dest)),
        (:line, 622, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, :ir_src, :jr_src)),
        (:line, 623, :none),
        (:(=), :jdest, (:call, :first, :jr_dest)),
        (:line, 624, :none),
        (:for, (:(=), :jsrc, :jr_src), (:block,
            (:line, 625, :none),
            (:(=), :idest, (:call, :first, :ir_dest)),
            (:line, 626, :none),
            (:for, (:(=), :isrc, :ir_src), (:block,
                (:line, 627, :none),
                (:(=), (:ref, :B, :idest, :jdest), (:ref, :A, :isrc, :jsrc)),
                (:line, 628, :none),
                (:+=, :idest, (:call, :step, :ir_dest))
              )),
            (:line, 630, :none),
            (:+=, :jdest, (:call, :step, :jr_dest))
          )),
        (:line, 632, :none),
        (:return, :B)
      )),
    (:line, 635, :none),
    (:function, (:call, (:curly, :copy_transpose!, :R, :S), (:(::), :B, (:curly, :AbstractVecOrMat, :R)), (:(::), :ir_dest, (:curly, :Range, :Int)), (:(::), :jr_dest, (:curly, :Range, :Int)), (:(::), :A, (:curly, :AbstractVecOrMat, :S)), (:(::), :ir_src, (:curly, :Range, :Int)), (:(::), :jr_src, (:curly, :Range, :Int))), (:block,
        (:line, 637, :none),
        (:if, (:call, :(!=), (:call, :length, :ir_dest), (:call, :length, :jr_src)), (:block,
            (:line, 638, :none),
            (:call, :throw, (:call, :ArgumentError, (:call, :string, "source and destination must have same size (got ", (:call, :length, :jr_src), " and ", (:call, :length, :ir_dest), ")")))
          )),
        (:line, 641, :none),
        (:if, (:call, :(!=), (:call, :length, :jr_dest), (:call, :length, :ir_src)), (:block,
            (:line, 642, :none),
            (:call, :throw, (:call, :ArgumentError, (:call, :string, "source and destination must have same size (got ", (:call, :length, :ir_src), " and ", (:call, :length, :jr_dest), ")")))
          )),
        (:line, 645, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :B, :ir_dest, :jr_dest)),
        (:line, 646, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, :ir_src, :jr_src)),
        (:line, 647, :none),
        (:(=), :idest, (:call, :first, :ir_dest)),
        (:line, 648, :none),
        (:for, (:(=), :jsrc, :jr_src), (:block,
            (:line, 649, :none),
            (:(=), :jdest, (:call, :first, :jr_dest)),
            (:line, 650, :none),
            (:for, (:(=), :isrc, :ir_src), (:block,
                (:line, 651, :none),
                (:(=), (:ref, :B, :idest, :jdest), (:ref, :A, :isrc, :jsrc)),
                (:line, 652, :none),
                (:+=, :jdest, (:call, :step, :jr_dest))
              )),
            (:line, 654, :none),
            (:+=, :idest, (:call, :step, :ir_dest))
          )),
        (:line, 656, :none),
        (:return, :B)
      )),
    (:line, 659, :none),
    (:function, (:call, :copymutable, (:(::), :a, :AbstractArray)), (:block,
        (:line, 660, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 661, :none),
        (:call, :copy!, (:call, :similar, :a), :a)
      )),
    (:line, 663, :none),
    (:(=), (:call, :copymutable, :itr), (:block,
        (:line, 663, :none),
        (:call, :collect, :itr)
      )),
    (:line, 664, :none),
    "    copymutable(a)\n\nMake a mutable copy of an array or iterable `a`.  For `a::Array`,\nthis is equivalent to `copy(a)`, but for other array types it may\ndiffer depending on the type of `similar(a)`.  For generic iterables\nthis is equivalent to `collect(a)`.\n",
    (:line, 672, :none),
    :copymutable,
    (:line, 674, :none),
    (:(=), (:call, (:curly, :zero, :T), (:(::), :x, (:curly, :AbstractArray, :T))), (:block,
        (:line, 674, :none),
        (:call, :fill!, (:call, :similar, :x), (:call, :zero, :T))
      )),
    (:line, 682, :none),
    (:(=), (:call, :start, (:(::), :A, :AbstractArray)), (:block,
        (:line, 682, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:(=), :itr, (:call, :eachindex, :A)),
          (:tuple, :itr, (:call, :start, :itr))
        )
      )),
    (:line, 683, :none),
    (:(=), (:call, :next, (:(::), :A, :AbstractArray), :i), (:block,
        (:line, 683, :none),
        (:block,
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:(=), (:tuple, :idx, :s), (:call, :next, (:ref, :i, 1), (:ref, :i, 2))),
          (:tuple, (:ref, :A, :idx), (:tuple, (:ref, :i, 1), :s))
        )
      )),
    (:line, 684, :none),
    (:(=), (:call, :done, (:(::), :A, :AbstractArray), :i), (:block,
        (:line, 684, :none),
        (:block,
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:call, :done, (:ref, :i, 1), (:ref, :i, 2))
        )
      )),
    (:line, 687, :none),
    (:(=), (:call, :eachindex, (:(::), :A, :AbstractVector)), (:block,
        (:line, 687, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :indices1, :A)
        )
      )),
    (:line, 688, :none),
    (:(=), (:call, :eachindex, (:(::), :A, :AbstractArray)), (:block,
        (:line, 688, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :eachindex, (:call, :linearindexing, :A), :A)
        )
      )),
    (:line, 690, :none),
    (:function, (:call, :eachindex, (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 691, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 692, :none),
        (:call, :eachindex, (:call, :linearindexing, :A, :B), :A, :B)
      )),
    (:line, 694, :none),
    (:function, (:call, :eachindex, (:(::), :A, :AbstractArray), (:..., (:(::), :B, :AbstractArray))), (:block,
        (:line, 695, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 696, :none),
        (:call, :eachindex, (:call, :linearindexing, :A, (:..., :B)), :A, (:..., :B))
      )),
    (:line, 698, :none),
    (:(=), (:call, :eachindex, (:(::), :LinearFast), (:(::), :A, :AbstractArray)), (:block,
        (:line, 698, :none),
        (:call, :linearindices, :A)
      )),
    (:line, 699, :none),
    (:function, (:call, :eachindex, (:(::), :LinearFast), (:(::), :A, :AbstractArray), (:..., (:(::), :B, :AbstractArray))), (:block,
        (:line, 700, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 701, :none),
        (:(:), 1, (:call, :_maxlength, :A, (:..., :B)))
      )),
    (:line, 703, :none),
    (:(=), (:call, :_maxlength, :A), (:block,
        (:line, 703, :none),
        (:call, :length, :A)
      )),
    (:line, 704, :none),
    (:function, (:call, :_maxlength, :A, :B, (:..., :C)), (:block,
        (:line, 705, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 706, :none),
        (:call, :max, (:call, :length, :A), (:call, :_maxlength, :B, (:..., :C)))
      )),
    (:line, 709, :none),
    (:(=), (:call, :isempty, (:(::), :a, :AbstractArray)), (:block,
        (:line, 709, :none),
        (:call, :(==), (:call, :_length, :a), 0)
      )),
    (:line, 713, :none),
    (:(=), (:call, (:curly, :convert, :T, :N), (:(::), (:curly, :Type, (:curly, :AbstractArray, :T, :N))), (:(::), :A, (:curly, :AbstractArray, :T, :N))), (:block,
        (:line, 713, :none),
        :A
      )),
    (:line, 714, :none),
    (:(=), (:call, (:curly, :convert, :T, :S, :N), (:(::), (:curly, :Type, (:curly, :AbstractArray, :T, :N))), (:(::), :A, (:curly, :AbstractArray, :S, :N))), (:block,
        (:line, 714, :none),
        (:call, :copy!, (:call, :similar, :A, :T), :A)
      )),
    (:line, 715, :none),
    (:(=), (:call, (:curly, :convert, :T, :S, :N), (:(::), (:curly, :Type, (:curly, :AbstractArray, :T))), (:(::), :A, (:curly, :AbstractArray, :S, :N))), (:block,
        (:line, 715, :none),
        (:call, :convert, (:curly, :AbstractArray, :T, :N), :A)
      )),
    (:line, 717, :none),
    (:(=), (:call, (:curly, :convert, :T, :N), (:(::), (:curly, :Type, :Array)), (:(::), :A, (:curly, :AbstractArray, :T, :N))), (:block,
        (:line, 717, :none),
        (:call, :convert, (:curly, :Array, :T, :N), :A)
      )),
    (:line, 719, :none),
    "   of_indices(x, y)\n\nRepresents the array `y` as an array having the same indices type as `x`.\n",
    (:line, 724, :none),
    (:(=), (:call, :of_indices, :x, :y), (:block,
        (:line, 724, :none),
        (:call, :similar, (:->, :dims, (:block,
              (:line, 724, :none),
              :y
            )), (:call, :oftype, (:call, :indices, :x), (:call, :indices, :y)))
      )),
    (:line, 726, :none),
    (:(=), (:call, :full, (:(::), :x, :AbstractArray)), (:block,
        (:line, 726, :none),
        :x
      )),
    (:line, 730, :none),
    (:(=), (:call, (:curly, :map, (:<:, :T, :Real)), (:(::), (:curly, :Type, :T)), (:(::), :r, :StepRange)), (:block,
        (:line, 730, :none),
        (:(:), (:call, :T, (:., :r, (:quote, #QuoteNode
                :start
              ))), (:call, :T, (:., :r, (:quote, #QuoteNode
                :step
              ))), (:call, :T, (:call, :last, :r)))
      )),
    (:line, 731, :none),
    (:(=), (:call, (:curly, :map, (:<:, :T, :Real)), (:(::), (:curly, :Type, :T)), (:(::), :r, :UnitRange)), (:block,
        (:line, 731, :none),
        (:(:), (:call, :T, (:., :r, (:quote, #QuoteNode
                :start
              ))), (:call, :T, (:call, :last, :r)))
      )),
    (:line, 732, :none),
    (:(=), (:call, (:curly, :map, (:<:, :T, :AbstractFloat)), (:(::), (:curly, :Type, :T)), (:(::), :r, :FloatRange)), (:block,
        (:line, 732, :none),
        (:call, :FloatRange, (:call, :T, (:., :r, (:quote, #QuoteNode
                :start
              ))), (:call, :T, (:., :r, (:quote, #QuoteNode
                :step
              ))), (:., :r, (:quote, #QuoteNode
              :len
            )), (:call, :T, (:., :r, (:quote, #QuoteNode
                :divisor
              ))))
      )),
    (:line, 733, :none),
    (:function, (:call, (:curly, :map, (:<:, :T, :AbstractFloat)), (:(::), (:curly, :Type, :T)), (:(::), :r, :LinSpace)), (:block,
        (:line, 734, :none),
        (:(=), :new_len, (:call, :T, (:., :r, (:quote, #QuoteNode
                :len
              )))),
        (:line, 735, :none),
        (:||, (:call, :(==), :new_len, (:., :r, (:quote, #QuoteNode
                :len
              ))), (:call, :error, (:string, :r, ": too long for ", :T))),
        (:line, 736, :none),
        (:call, :LinSpace, (:call, :T, (:., :r, (:quote, #QuoteNode
                :start
              ))), (:call, :T, (:., :r, (:quote, #QuoteNode
                :stop
              ))), :new_len, (:call, :T, (:., :r, (:quote, #QuoteNode
                :divisor
              ))))
      )),
    (:line, 744, :none),
    (:(=), (:call, (:curly, :pointer, :T), (:(::), :x, (:curly, :AbstractArray, :T))), (:block,
        (:line, 744, :none),
        (:call, :unsafe_convert, (:curly, :Ptr, :T), :x)
      )),
    (:line, 745, :none),
    (:(=), (:call, (:curly, :pointer, :T), (:(::), :x, (:curly, :AbstractArray, :T)), (:(::), :i, :Integer)), (:block,
        (:line, 745, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :+, (:call, :unsafe_convert, (:curly, :Ptr, :T), :x), (:call, :*, (:call, :-, :i, (:call, :first, (:call, :linearindices, :x))), (:call, :elsize, :x)))
        )
      )),
    (:line, 758, :none),
    (:function, (:call, :getindex, (:(::), :A, :AbstractArray), (:..., :I)), (:block,
        (:line, 759, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 760, :none),
        (:call, :_getindex, (:call, :linearindexing, :A), :A, (:..., :I))
      )),
    (:line, 762, :none),
    (:function, (:call, :unsafe_getindex, (:(::), :A, :AbstractArray), (:..., :I)), (:block,
        (:line, 763, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 764, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :getindex, :A, (:..., :I)))),
        (:line, 765, :none),
        :r
      )),
    (:line, 768, :none),
    (:(=), (:call, :_getindex, (:(::), :LinearIndexing), (:(::), :A, :AbstractArray), (:..., :I)), (:block,
        (:line, 768, :none),
        (:call, :error, (:string, "indexing ", (:call, :typeof, :A), " with types ", (:call, :typeof, :I), " is not supported"))
      )),
    (:line, 771, :none),
    (:(=), (:call, :_getindex, (:(::), :LinearFast), (:(::), :A, :AbstractVector), (:(::), :Int)), (:block,
        (:line, 771, :none),
        (:call, :error, "indexing not defined for ", (:call, :typeof, :A))
      )),
    (:line, 772, :none),
    (:(=), (:call, :_getindex, (:(::), :LinearFast), (:(::), :A, :AbstractArray), (:(::), :Int)), (:block,
        (:line, 772, :none),
        (:call, :error, "indexing not defined for ", (:call, :typeof, :A))
      )),
    (:line, 773, :none),
    (:(=), (:call, (:curly, :_getindex, :T), (:(::), :LinearFast), (:(::), :A, (:curly, :AbstractArray, :T, 0))), (:block,
        (:line, 773, :none),
        (:ref, :A, 1)
      )),
    (:line, 774, :none),
    (:(=), (:call, :_getindex, (:(::), :LinearFast), (:(::), :A, :AbstractArray), (:(::), :i, :Real)), (:block,
        (:line, 774, :none),
        (:block,
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:call, :getindex, :A, (:call, :to_index, :i))
        )
      )),
    (:line, 775, :none),
    (:function, (:call, (:curly, :_getindex, :T, :N), (:(::), :LinearFast), (:(::), :A, (:curly, :AbstractArray, :T, :N)), (:(::), :I, (:curly, :Vararg, :Real, :N))), (:block,
        (:line, 777, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 778, :none),
        (:(=), :J, (:call, :to_indexes, (:..., :I))),
        (:line, 779, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, (:..., :J))),
        (:line, 780, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :getindex, :A, (:call, :sub2ind, :A, (:..., :J))))),
        (:line, 781, :none),
        :r
      )),
    (:line, 783, :none),
    (:function, (:call, :_getindex, (:(::), :LinearFast), (:(::), :A, :AbstractVector), (:(::), :I1, :Real), (:..., (:(::), :I, :Real))), (:block,
        (:line, 784, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 785, :none),
        (:(=), :J, (:call, :to_indexes, :I1, (:..., :I))),
        (:line, 786, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, (:..., :J))),
        (:line, 787, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :getindex, :A, (:ref, :J, 1)))),
        (:line, 788, :none),
        :r
      )),
    (:line, 790, :none),
    (:function, (:call, :_getindex, (:(::), :LinearFast), (:(::), :A, :AbstractArray), (:..., (:(::), :I, :Real))), (:block,
        (:line, 791, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 792, :none),
        (:(=), :J, (:call, :to_indexes, (:..., :I))),
        (:line, 793, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, (:..., :J))),
        (:line, 794, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :getindex, :A, (:call, :sub2ind, :A, (:..., :J))))),
        (:line, 795, :none),
        :r
      )),
    (:line, 800, :none),
    (:(=), (:call, (:curly, :_getindex, :T, :N), (:(::), :LinearSlow), (:(::), :A, (:curly, :AbstractArray, :T, :N)), (:(::), (:curly, :Vararg, :Int, :N))), (:block,
        (:line, 800, :none),
        (:call, :error, "indexing not defined for ", (:call, :typeof, :A))
      )),
    (:line, 801, :none),
    (:(=), (:call, (:curly, :_getindex, :T, :N), (:(::), :LinearSlow), (:(::), :A, (:curly, :AbstractArray, :T, :N)), (:(::), :I, (:curly, :Vararg, :Real, :N))), (:block,
        (:line, 801, :none),
        (:block,
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:call, :getindex, :A, (:..., (:call, :to_indexes, (:..., :I))))
        )
      )),
    (:line, 802, :none),
    (:function, (:call, :_getindex, (:(::), :LinearSlow), (:(::), :A, :AbstractArray), (:(::), :i, :Real)), (:block,
        (:line, 804, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 805, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, :i)),
        (:line, 806, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :getindex, :A, (:..., (:call, :ind2sub, :A, (:call, :to_index, :i)))))),
        (:line, 807, :none),
        :r
      )),
    (:line, 809, :none),
    (:macrocall, Symbol("@generated"), (:function, (:call, (:curly, :_getindex, :T, :AN), (:(::), :LinearSlow), (:(::), :A, (:curly, :AbstractArray, :T, :AN)), (:..., (:(::), :I, :Real))), (:block,
          (:line, 810, :none),
          (:(=), :N, (:call, :length, :I)),
          (:line, 811, :none),
          (:if, (:call, :>, :N, :AN), (:block,
              (:line, 813, :none),
              (:(=), :Isplat, (:typed_comprehension, :Expr, (:generator, (:quote, (:ref, :I, (:$, :d))), (:(=), :d, (:(:), 1, :AN))))),
              (:line, 814, :none),
              (:(=), :Osplat, (:typed_comprehension, :Expr, (:generator, (:quote, (:call, :(==), (:call, :to_index, (:ref, :I, (:$, :d))), 1)), (:(=), :d, (:(:), (:call, :+, :AN, 1), :N))))),
              (:line, 815, :none),
              (:quote, (:block,
                  (:line, 816, :none),
                  (:macrocall, Symbol("@_propagate_inbounds_meta")),
                  (:line, 817, :none),
                  (:macrocall, Symbol("@boundscheck"), (:||, (:call, :&, (:$, (:tuple, (:..., :Osplat)))), (:call, :throw_boundserror, :A, :I))),
                  (:line, 818, :none),
                  (:call, :getindex, :A, (:$, (:tuple, (:..., :Isplat))))
                ))
            ), (:block,
              (:line, 822, :none),
              (:(=), :Isplat, (:typed_comprehension, :Expr, (:generator, (:quote, (:ref, :I, (:$, :d))), (:(=), :d, (:(:), 1, (:call, :-, :N, 1)))))),
              (:line, 823, :none),
              (:(=), :sz, (:call, :Expr, (:quote, #QuoteNode
                    :tuple
                  ))),
              (:line, 824, :none),
              (:(=), (:., :sz, (:quote, #QuoteNode
                    :args
                  )), (:typed_comprehension, :Expr, (:generator, (:quote, (:call, :size, :A, (:$, :d))), (:(=), :d, (:(:), (:call, :max, :N, 1), :AN))))),
              (:line, 825, :none),
              (:(=), :szcheck, (:typed_comprehension, :Expr, (:generator, (:quote, (:call, :>, (:call, :size, :A, (:$, :d)), 0)), (:(=), :d, (:(:), (:call, :max, :N, 1), :AN))))),
              (:line, 826, :none),
              (:(=), :last_idx, (:if, (:call, :>, :N, 0), (:quote, (:call, :to_index, (:ref, :I, (:$, :N)))), 1)),
              (:line, 827, :none),
              (:quote, (:block,
                  (:line, 829, :none),
                  (:macrocall, Symbol("@_propagate_inbounds_meta")),
                  (:line, 830, :none),
                  (:macrocall, Symbol("@boundscheck"), (:||, (:call, :&, (:$, (:tuple, (:..., :szcheck)))), (:call, :throw_boundserror, :A, :I))),
                  (:line, 831, :none),
                  (:call, :getindex, :A, (:$, (:tuple, (:..., :Isplat))), (:..., (:call, :ind2sub, (:$, :sz), (:$, :last_idx))))
                ))
            ))
        ))),
    (:line, 838, :none),
    (:function, (:call, :setindex!, (:(::), :A, :AbstractArray), :v, (:..., :I)), (:block,
        (:line, 839, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 840, :none),
        (:call, :_setindex!, (:call, :linearindexing, :A), :A, :v, (:..., :I))
      )),
    (:line, 842, :none),
    (:function, (:call, :unsafe_setindex!, (:(::), :A, :AbstractArray), :v, (:..., :I)), (:block,
        (:line, 843, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 844, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :setindex!, :A, :v, (:..., :I)))),
        (:line, 845, :none),
        :r
      )),
    (:line, 848, :none),
    (:(=), (:call, :_setindex!, (:(::), :LinearIndexing), (:(::), :A, :AbstractArray), :v, (:..., :I)), (:block,
        (:line, 848, :none),
        (:call, :error, (:string, "indexing ", (:call, :typeof, :A), " with types ", (:call, :typeof, :I), " is not supported"))
      )),
    (:line, 851, :none),
    (:(=), (:call, :_setindex!, (:(::), :LinearFast), (:(::), :A, :AbstractVector), :v, (:(::), :Int)), (:block,
        (:line, 851, :none),
        (:call, :error, "indexed assignment not defined for ", (:call, :typeof, :A))
      )),
    (:line, 852, :none),
    (:(=), (:call, :_setindex!, (:(::), :LinearFast), (:(::), :A, :AbstractArray), :v, (:(::), :Int)), (:block,
        (:line, 852, :none),
        (:call, :error, "indexed assignment not defined for ", (:call, :typeof, :A))
      )),
    (:line, 853, :none),
    (:(=), (:call, (:curly, :_setindex!, :T), (:(::), :LinearFast), (:(::), :A, (:curly, :AbstractArray, :T, 0)), :v), (:block,
        (:line, 853, :none),
        (:block,
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:call, :setindex!, :A, :v, 1)
        )
      )),
    (:line, 854, :none),
    (:(=), (:call, :_setindex!, (:(::), :LinearFast), (:(::), :A, :AbstractArray), :v, (:(::), :i, :Real)), (:block,
        (:line, 854, :none),
        (:block,
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:call, :setindex!, :A, :v, (:call, :to_index, :i))
        )
      )),
    (:line, 855, :none),
    (:function, (:call, (:curly, :_setindex!, :T, :N), (:(::), :LinearFast), (:(::), :A, (:curly, :AbstractArray, :T, :N)), :v, (:(::), :I, (:curly, :Vararg, :Real, :N))), (:block,
        (:line, 857, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 858, :none),
        (:(=), :J, (:call, :to_indexes, (:..., :I))),
        (:line, 859, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, (:..., :J))),
        (:line, 860, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :setindex!, :A, :v, (:call, :sub2ind, :A, (:..., :J))))),
        (:line, 861, :none),
        :r
      )),
    (:line, 863, :none),
    (:function, (:call, :_setindex!, (:(::), :LinearFast), (:(::), :A, :AbstractVector), :v, (:(::), :I1, :Real), (:..., (:(::), :I, :Real))), (:block,
        (:line, 864, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 865, :none),
        (:(=), :J, (:call, :to_indexes, :I1, (:..., :I))),
        (:line, 866, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, (:..., :J))),
        (:line, 867, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :setindex!, :A, :v, (:ref, :J, 1)))),
        (:line, 868, :none),
        :r
      )),
    (:line, 870, :none),
    (:function, (:call, :_setindex!, (:(::), :LinearFast), (:(::), :A, :AbstractArray), :v, (:..., (:(::), :I, :Real))), (:block,
        (:line, 871, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 872, :none),
        (:(=), :J, (:call, :to_indexes, (:..., :I))),
        (:line, 873, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, (:..., :J))),
        (:line, 874, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :setindex!, :A, :v, (:call, :sub2ind, :A, (:..., :J))))),
        (:line, 875, :none),
        :r
      )),
    (:line, 879, :none),
    (:(=), (:call, (:curly, :_setindex!, :T, :N), (:(::), :LinearSlow), (:(::), :A, (:curly, :AbstractArray, :T, :N)), :v, (:(::), (:curly, :Vararg, :Int, :N))), (:block,
        (:line, 879, :none),
        (:call, :error, "indexed assignment not defined for ", (:call, :typeof, :A))
      )),
    (:line, 880, :none),
    (:(=), (:call, (:curly, :_setindex!, :T, :N), (:(::), :LinearSlow), (:(::), :A, (:curly, :AbstractArray, :T, :N)), :v, (:(::), :I, (:curly, :Vararg, :Real, :N))), (:block,
        (:line, 880, :none),
        (:block,
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:call, :setindex!, :A, :v, (:..., (:call, :to_indexes, (:..., :I))))
        )
      )),
    (:line, 881, :none),
    (:function, (:call, :_setindex!, (:(::), :LinearSlow), (:(::), :A, :AbstractArray), :v, (:(::), :i, :Real)), (:block,
        (:line, 883, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 884, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, :i)),
        (:line, 885, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :setindex!, :A, :v, (:..., (:call, :ind2sub, :A, (:call, :to_index, :i)))))),
        (:line, 886, :none),
        :r
      )),
    (:line, 888, :none),
    (:macrocall, Symbol("@generated"), (:function, (:call, (:curly, :_setindex!, :T, :AN), (:(::), :LinearSlow), (:(::), :A, (:curly, :AbstractArray, :T, :AN)), :v, (:..., (:(::), :I, :Real))), (:block,
          (:line, 889, :none),
          (:(=), :N, (:call, :length, :I)),
          (:line, 890, :none),
          (:if, (:call, :>, :N, :AN), (:block,
              (:line, 892, :none),
              (:(=), :Isplat, (:typed_comprehension, :Expr, (:generator, (:quote, (:ref, :I, (:$, :d))), (:(=), :d, (:(:), 1, :AN))))),
              (:line, 893, :none),
              (:(=), :Osplat, (:typed_comprehension, :Expr, (:generator, (:quote, (:call, :(==), (:call, :to_index, (:ref, :I, (:$, :d))), 1)), (:(=), :d, (:(:), (:call, :+, :AN, 1), :N))))),
              (:line, 894, :none),
              (:quote, (:block,
                  (:line, 896, :none),
                  (:macrocall, Symbol("@_propagate_inbounds_meta")),
                  (:line, 897, :none),
                  (:macrocall, Symbol("@boundscheck"), (:||, (:call, :&, (:$, (:tuple, (:..., :Osplat)))), (:call, :throw_boundserror, :A, :I))),
                  (:line, 898, :none),
                  (:call, :setindex!, :A, :v, (:$, (:tuple, (:..., :Isplat))))
                ))
            ), (:block,
              (:line, 902, :none),
              (:(=), :Isplat, (:typed_comprehension, :Expr, (:generator, (:quote, (:ref, :I, (:$, :d))), (:(=), :d, (:(:), 1, (:call, :-, :N, 1)))))),
              (:line, 903, :none),
              (:(=), :sz, (:call, :Expr, (:quote, #QuoteNode
                    :tuple
                  ))),
              (:line, 904, :none),
              (:(=), (:., :sz, (:quote, #QuoteNode
                    :args
                  )), (:typed_comprehension, :Expr, (:generator, (:quote, (:call, :size, :A, (:$, :d))), (:(=), :d, (:(:), (:call, :max, :N, 1), :AN))))),
              (:line, 905, :none),
              (:(=), :szcheck, (:typed_comprehension, :Expr, (:generator, (:quote, (:call, :>, (:call, :size, :A, (:$, :d)), 0)), (:(=), :d, (:(:), (:call, :max, :N, 1), :AN))))),
              (:line, 906, :none),
              (:(=), :last_idx, (:if, (:call, :>, :N, 0), (:quote, (:call, :to_index, (:ref, :I, (:$, :N)))), 1)),
              (:line, 907, :none),
              (:quote, (:block,
                  (:line, 909, :none),
                  (:macrocall, Symbol("@_propagate_inbounds_meta")),
                  (:line, 910, :none),
                  (:macrocall, Symbol("@boundscheck"), (:||, (:call, :&, (:$, (:tuple, (:..., :szcheck)))), (:call, :throw_boundserror, :A, :I))),
                  (:line, 911, :none),
                  (:call, :setindex!, :A, :v, (:$, (:tuple, (:..., :Isplat))), (:..., (:call, :ind2sub, (:$, :sz), (:$, :last_idx))))
                ))
            ))
        ))),
    (:line, 918, :none),
    (:typealias, (:curly, :RangeVecIntList, (:<:, :A, (:curly, :AbstractVector, :Int))), (:curly, :Union, (:curly, :Tuple, (:curly, :Vararg, (:curly, :Union, :Range, (:curly, :AbstractVector, :Int)))), (:curly, :AbstractVector, (:curly, :UnitRange, :Int)), (:curly, :AbstractVector, (:curly, :Range, :Int)), (:curly, :AbstractVector, :A))),
    (:line, 920, :none),
    (:(=), (:call, :get, (:(::), :A, :AbstractArray), (:(::), :i, :Integer), :default), (:block,
        (:line, 920, :none),
        (:if, (:call, :checkbounds, :Bool, :A, :i), (:ref, :A, :i), :default)
      )),
    (:line, 921, :none),
    (:(=), (:call, :get, (:(::), :A, :AbstractArray), (:(::), :I, (:curly, :Tuple)), :default), (:block,
        (:line, 921, :none),
        (:call, :similar, :A, (:call, :typeof, :default), 0)
      )),
    (:line, 922, :none),
    (:(=), (:call, :get, (:(::), :A, :AbstractArray), (:(::), :I, :Dims), :default), (:block,
        (:line, 922, :none),
        (:if, (:call, :checkbounds, :Bool, :A, (:..., :I)), (:ref, :A, (:..., :I)), :default)
      )),
    (:line, 924, :none),
    (:function, (:call, (:curly, :get!, :T), (:(::), :X, (:curly, :AbstractVector, :T)), (:(::), :A, :AbstractVector), (:(::), :I, (:curly, :Union, :Range, (:curly, :AbstractVector, :Int))), (:(::), :default, :T)), (:block,
        (:line, 926, :none),
        (:(=), :ind, (:call, :findin, :I, (:call, :indices1, :A))),
        (:line, 927, :none),
        (:(=), (:ref, :X, :ind), (:ref, :A, (:ref, :I, :ind))),
        (:line, 928, :none),
        (:(=), :Xind, (:call, :indices1, :X)),
        (:line, 929, :none),
        (:(=), (:ref, :X, (:(:), (:call, :first, :Xind), (:call, :-, (:call, :first, :ind), 1))), :default),
        (:line, 930, :none),
        (:(=), (:ref, :X, (:(:), (:call, :+, (:call, :last, :ind), 1), (:call, :last, :Xind))), :default),
        (:line, 931, :none),
        :X
      )),
    (:line, 933, :none),
    (:function, (:call, (:curly, :get!, :T), (:(::), :X, (:curly, :AbstractArray, :T)), (:(::), :A, :AbstractArray), (:(::), :I, (:curly, :Union, :Range, (:curly, :AbstractVector, :Int))), (:(::), :default, :T)), (:block,
        (:line, 935, :none),
        (:(=), :ind, (:call, :findin, :I, (:(:), 1, (:call, :length, :A)))),
        (:line, 936, :none),
        (:(=), (:ref, :X, :ind), (:ref, :A, (:ref, :I, :ind))),
        (:line, 937, :none),
        (:(=), (:ref, :X, (:(:), 1, (:call, :-, (:call, :first, :ind), 1))), :default),
        (:line, 938, :none),
        (:(=), (:ref, :X, (:(:), (:call, :+, (:call, :last, :ind), 1), (:call, :length, :X))), :default),
        (:line, 939, :none),
        :X
      )),
    (:line, 942, :none),
    (:(=), (:call, :get, (:(::), :A, :AbstractArray), (:(::), :I, :Range), :default), (:block,
        (:line, 942, :none),
        (:call, :get!, (:call, :similar, :A, (:call, :typeof, :default), (:call, :index_shape, :A, :I)), :A, :I, :default)
      )),
    (:line, 945, :none),
    (:function, (:call, (:curly, :get!, :T), (:(::), :X, (:curly, :AbstractArray, :T)), (:(::), :A, :AbstractArray), (:(::), :I, :RangeVecIntList), (:(::), :default, :T)), (:block,
        (:line, 946, :none),
        (:call, :fill!, :X, :default),
        (:line, 947, :none),
        (:(=), (:tuple, :dst, :src), (:call, :indcopy, (:call, :size, :A), :I)),
        (:line, 948, :none),
        (:(=), (:ref, :X, (:..., :dst)), (:ref, :A, (:..., :src))),
        (:line, 949, :none),
        :X
      )),
    (:line, 952, :none),
    (:(=), (:call, :get, (:(::), :A, :AbstractArray), (:(::), :I, :RangeVecIntList), :default), (:block,
        (:line, 952, :none),
        (:call, :get!, (:call, :similar, :A, (:call, :typeof, :default), (:call, :index_shape, :A, (:..., :I))), :A, :I, :default)
      )),
    (:line, 955, :none),
    (:(=), (:call, :replace_in_print_matrix, (:(::), :A, :AbstractMatrix), (:(::), :i, :Integer), (:(::), :j, :Integer), (:(::), :s, :AbstractString)), (:block,
        (:line, 955, :none),
        :s
      )),
    (:line, 956, :none),
    (:(=), (:call, :replace_in_print_matrix, (:(::), :A, :AbstractVector), (:(::), :i, :Integer), (:(::), :j, :Integer), (:(::), :s, :AbstractString)), (:block,
        (:line, 956, :none),
        :s
      )),
    (:line, 960, :none),
    (:(=), (:call, :promote_eltype), (:block,
        (:line, 960, :none),
        :Bottom
      )),
    (:line, 961, :none),
    (:(=), (:call, :promote_eltype, :v1, (:..., :vs)), (:block,
        (:line, 961, :none),
        (:call, :promote_type, (:call, :eltype, :v1), (:call, :promote_eltype, (:..., :vs)))
      )),
    (:line, 964, :none),
    (:(=), (:call, :cat, (:(::), :catdim, :Integer)), (:block,
        (:line, 964, :none),
        (:call, (:curly, :Array, :Any, 1), 0)
      )),
    (:line, 966, :none),
    (:(=), (:call, :vcat), (:block,
        (:line, 966, :none),
        (:call, (:curly, :Array, :Any, 1), 0)
      )),
    (:line, 967, :none),
    (:(=), (:call, :hcat), (:block,
        (:line, 967, :none),
        (:call, (:curly, :Array, :Any, 1), 0)
      )),
    (:line, 968, :none),
    (:(=), (:call, (:curly, :typed_vcat, :T), (:(::), (:curly, :Type, :T))), (:block,
        (:line, 968, :none),
        (:call, (:curly, :Array, :T, 1), 0)
      )),
    (:line, 969, :none),
    (:(=), (:call, (:curly, :typed_hcat, :T), (:(::), (:curly, :Type, :T))), (:block,
        (:line, 969, :none),
        (:call, (:curly, :Array, :T, 1), 0)
      )),
    (:line, 972, :none),
    (:(=), (:call, (:curly, :vcat, :T), (:..., (:(::), :X, :T))), (:block,
        (:line, 972, :none),
        (:typed_comprehension, :T, (:generator, (:ref, :X, :i), (:(=), :i, (:(:), 1, (:call, :length, :X)))))
      )),
    (:line, 973, :none),
    (:(=), (:call, (:curly, :vcat, (:<:, :T, :Number)), (:..., (:(::), :X, :T))), (:block,
        (:line, 973, :none),
        (:typed_comprehension, :T, (:generator, (:ref, :X, :i), (:(=), :i, (:(:), 1, (:call, :length, :X)))))
      )),
    (:line, 974, :none),
    (:(=), (:call, (:curly, :hcat, :T), (:..., (:(::), :X, :T))), (:block,
        (:line, 974, :none),
        (:typed_comprehension, :T, (:generator, (:ref, :X, :j), (:(=), :i, (:(:), 1, 1)), (:(=), :j, (:(:), 1, (:call, :length, :X)))))
      )),
    (:line, 975, :none),
    (:(=), (:call, (:curly, :hcat, (:<:, :T, :Number)), (:..., (:(::), :X, :T))), (:block,
        (:line, 975, :none),
        (:typed_comprehension, :T, (:generator, (:ref, :X, :j), (:(=), :i, (:(:), 1, 1)), (:(=), :j, (:(:), 1, (:call, :length, :X)))))
      )),
    (:line, 977, :none),
    (:(=), (:call, :vcat, (:..., (:(::), :X, :Number))), (:block,
        (:line, 977, :none),
        (:call, :hvcat_fill, (:call, (:curly, :Array, (:call, :promote_typeof, (:..., :X))), (:call, :length, :X)), :X)
      )),
    (:line, 978, :none),
    (:(=), (:call, :hcat, (:..., (:(::), :X, :Number))), (:block,
        (:line, 978, :none),
        (:call, :hvcat_fill, (:call, (:curly, :Array, (:call, :promote_typeof, (:..., :X))), 1, (:call, :length, :X)), :X)
      )),
    (:line, 979, :none),
    (:(=), (:call, (:curly, :typed_vcat, :T), (:(::), (:curly, :Type, :T)), (:..., (:(::), :X, :Number))), (:block,
        (:line, 979, :none),
        (:call, :hvcat_fill, (:call, (:curly, :Array, :T, 1), (:call, :length, :X)), :X)
      )),
    (:line, 980, :none),
    (:(=), (:call, (:curly, :typed_hcat, :T), (:(::), (:curly, :Type, :T)), (:..., (:(::), :X, :Number))), (:block,
        (:line, 980, :none),
        (:call, :hvcat_fill, (:call, (:curly, :Array, :T, 2), 1, (:call, :length, :X)), :X)
      )),
    (:line, 982, :none),
    (:(=), (:call, :vcat, (:..., (:(::), :V, :AbstractVector))), (:block,
        (:line, 982, :none),
        (:call, :typed_vcat, (:call, :promote_eltype, (:..., :V)), (:..., :V))
      )),
    (:line, 983, :none),
    (:(=), (:call, (:curly, :vcat, :T), (:..., (:(::), :V, (:curly, :AbstractVector, :T)))), (:block,
        (:line, 983, :none),
        (:call, :typed_vcat, :T, (:..., :V))
      )),
    (:line, 985, :none),
    (:function, (:call, (:curly, :typed_vcat, :T), (:(::), (:curly, :Type, :T)), (:..., (:(::), :V, :AbstractVector))), (:block,
        (:line, 986, :none),
        (:(=), (:(::), :n, :Int), 0),
        (:line, 987, :none),
        (:for, (:(=), :Vk, :V), (:block,
            (:line, 988, :none),
            (:+=, :n, (:call, :length, :Vk))
          )),
        (:line, 990, :none),
        (:(=), :a, (:call, :similar, (:call, :full, (:ref, :V, 1)), :T, :n)),
        (:line, 991, :none),
        (:(=), :pos, 1),
        (:line, 992, :none),
        (:for, (:(=), :k, (:(:), 1, (:call, :length, :V))), (:block,
            (:line, 993, :none),
            (:(=), :Vk, (:ref, :V, :k)),
            (:line, 994, :none),
            (:(=), :p1, (:call, :-, (:call, :+, :pos, (:call, :length, :Vk)), 1)),
            (:line, 995, :none),
            (:(=), (:ref, :a, (:(:), :pos, :p1)), :Vk),
            (:line, 996, :none),
            (:(=), :pos, (:call, :+, :p1, 1))
          )),
        (:line, 998, :none),
        :a
      )),
    (:line, 1001, :none),
    (:(=), (:call, :hcat, (:..., (:(::), :A, :AbstractVecOrMat))), (:block,
        (:line, 1001, :none),
        (:call, :typed_hcat, (:call, :promote_eltype, (:..., :A)), (:..., :A))
      )),
    (:line, 1002, :none),
    (:(=), (:call, (:curly, :hcat, :T), (:..., (:(::), :A, (:curly, :AbstractVecOrMat, :T)))), (:block,
        (:line, 1002, :none),
        (:call, :typed_hcat, :T, (:..., :A))
      )),
    (:line, 1004, :none),
    (:function, (:call, (:curly, :typed_hcat, :T), (:(::), (:curly, :Type, :T)), (:..., (:(::), :A, :AbstractVecOrMat))), (:block,
        (:line, 1005, :none),
        (:(=), :nargs, (:call, :length, :A)),
        (:line, 1006, :none),
        (:(=), :nrows, (:call, :size, (:ref, :A, 1), 1)),
        (:line, 1007, :none),
        (:(=), :ncols, 0),
        (:line, 1008, :none),
        (:(=), :dense, true),
        (:line, 1009, :none),
        (:for, (:(=), :j, (:(:), 1, :nargs)), (:block,
            (:line, 1010, :none),
            (:(=), :Aj, (:ref, :A, :j)),
            (:line, 1011, :none),
            (:if, (:call, :(!=), (:call, :size, :Aj, 1), :nrows), (:block,
                (:line, 1012, :none),
                (:call, :throw, (:call, :ArgumentError, (:string, "number of rows of each array must match (got ", (:call, :map, (:->, :x, (:block,
                            (:line, 1012, :none),
                            (:call, :size, :x, 1)
                          )), :A), ")")))
              )),
            (:line, 1014, :none),
            (:&=, :dense, (:call, :isa, :Aj, :Array)),
            (:line, 1015, :none),
            (:(=), :nd, (:call, :ndims, :Aj)),
            (:line, 1016, :none),
            (:+=, :ncols, (:if, (:call, :(==), :nd, 2), (:call, :size, :Aj, 2), 1))
          )),
        (:line, 1018, :none),
        (:(=), :B, (:call, :similar, (:call, :full, (:ref, :A, 1)), :T, :nrows, :ncols)),
        (:line, 1019, :none),
        (:(=), :pos, 1),
        (:line, 1020, :none),
        (:if, :dense, (:block,
            (:line, 1021, :none),
            (:for, (:(=), :k, (:(:), 1, :nargs)), (:block,
                (:line, 1022, :none),
                (:(=), :Ak, (:ref, :A, :k)),
                (:line, 1023, :none),
                (:(=), :n, (:call, :length, :Ak)),
                (:line, 1024, :none),
                (:call, :copy!, :B, :pos, :Ak, 1, :n),
                (:line, 1025, :none),
                (:+=, :pos, :n)
              ))
          ), (:block,
            (:line, 1028, :none),
            (:for, (:(=), :k, (:(:), 1, :nargs)), (:block,
                (:line, 1029, :none),
                (:(=), :Ak, (:ref, :A, :k)),
                (:line, 1030, :none),
                (:(=), :p1, (:call, :-, (:call, :+, :pos, (:if, (:call, :isa, :Ak, :AbstractMatrix), (:call, :size, :Ak, 2), 1)), 1)),
                (:line, 1031, :none),
                (:(=), (:ref, :B, :(:), (:(:), :pos, :p1)), :Ak),
                (:line, 1032, :none),
                (:(=), :pos, (:call, :+, :p1, 1))
              ))
          )),
        (:line, 1035, :none),
        (:return, :B)
      )),
    (:line, 1038, :none),
    (:(=), (:call, :vcat, (:..., (:(::), :A, :AbstractMatrix))), (:block,
        (:line, 1038, :none),
        (:call, :typed_vcat, (:call, :promote_eltype, (:..., :A)), (:..., :A))
      )),
    (:line, 1039, :none),
    (:(=), (:call, (:curly, :vcat, :T), (:..., (:(::), :A, (:curly, :AbstractMatrix, :T)))), (:block,
        (:line, 1039, :none),
        (:call, :typed_vcat, :T, (:..., :A))
      )),
    (:line, 1041, :none),
    (:function, (:call, (:curly, :typed_vcat, :T), (:(::), (:curly, :Type, :T)), (:..., (:(::), :A, :AbstractMatrix))), (:block,
        (:line, 1042, :none),
        (:(=), :nargs, (:call, :length, :A)),
        (:line, 1043, :none),
        (:(=), :nrows, (:(::), (:call, :sum, (:->, :a, (:block,
                  (:line, 1043, :none),
                  (:call, :size, :a, 1)
                )), :A), :Int)),
        (:line, 1044, :none),
        (:(=), :ncols, (:call, :size, (:ref, :A, 1), 2)),
        (:line, 1045, :none),
        (:for, (:(=), :j, (:(:), 2, :nargs)), (:block,
            (:line, 1046, :none),
            (:if, (:call, :(!=), (:call, :size, (:ref, :A, :j), 2), :ncols), (:block,
                (:line, 1047, :none),
                (:call, :throw, (:call, :ArgumentError, (:string, "number of columns of each array must match (got ", (:call, :map, (:->, :x, (:block,
                            (:line, 1047, :none),
                            (:call, :size, :x, 2)
                          )), :A), ")")))
              ))
          )),
        (:line, 1050, :none),
        (:(=), :B, (:call, :similar, (:call, :full, (:ref, :A, 1)), :T, :nrows, :ncols)),
        (:line, 1051, :none),
        (:(=), :pos, 1),
        (:line, 1052, :none),
        (:for, (:(=), :k, (:(:), 1, :nargs)), (:block,
            (:line, 1053, :none),
            (:(=), :Ak, (:ref, :A, :k)),
            (:line, 1054, :none),
            (:(=), :p1, (:call, :-, (:call, :+, :pos, (:call, :size, :Ak, 1)), 1)),
            (:line, 1055, :none),
            (:(=), (:ref, :B, (:(:), :pos, :p1), :(:)), :Ak),
            (:line, 1056, :none),
            (:(=), :pos, (:call, :+, :p1, 1))
          )),
        (:line, 1058, :none),
        (:return, :B)
      )),
    (:line, 1063, :none),
    (:function, (:call, :cat, :catdims, (:..., :X)), (:block,
        (:line, 1064, :none),
        (:(=), :T, (:call, :promote_type, (:..., (:call, :map, (:->, :x, (:block,
                    (:line, 1064, :none),
                    (:if, (:call, :isa, :x, :AbstractArray), (:call, :eltype, :x), (:call, :typeof, :x))
                  )), :X)))),
        (:line, 1065, :none),
        (:call, :cat_t, :catdims, :T, (:..., :X))
      )),
    (:line, 1068, :none),
    (:function, (:call, :cat_t, :catdims, (:(::), :typeC, :Type), (:..., :X)), (:block,
        (:line, 1069, :none),
        (:(=), :catdims, (:call, :collect, :catdims)),
        (:line, 1070, :none),
        (:(=), :nargs, (:call, :length, :X)),
        (:line, 1071, :none),
        (:(=), :ndimsX, (:typed_comprehension, :Int, (:generator, (:if, (:call, :isa, :a, :AbstractArray), (:call, :ndims, :a), 0), (:(=), :a, :X)))),
        (:line, 1072, :none),
        (:(=), :ndimsC, (:call, :max, (:call, :maximum, :ndimsX), (:call, :maximum, :catdims))),
        (:line, 1073, :none),
        (:(=), :catsizes, (:call, :zeros, :Int, (:tuple, :nargs, (:call, :length, :catdims)))),
        (:line, 1074, :none),
        (:(=), :dims2cat, (:call, :zeros, :Int, :ndimsC)),
        (:line, 1075, :none),
        (:for, (:(=), :k, (:(:), 1, (:call, :length, :catdims))), (:block,
            (:line, 1076, :none),
            (:(=), (:ref, :dims2cat, (:ref, :catdims, :k)), :k)
          )),
        (:line, 1079, :none),
        (:(=), :dimsC, (:typed_comprehension, :Int, (:generator, (:if, (:call, :(<=), :d, (:ref, :ndimsX, 1)), (:call, :size, (:ref, :X, 1), :d), 1), (:(=), :d, (:(:), 1, :ndimsC))))),
        (:line, 1080, :none),
        (:for, (:(=), :k, (:(:), 1, (:call, :length, :catdims))), (:block,
            (:line, 1081, :none),
            (:(=), (:ref, :catsizes, 1, :k), (:ref, :dimsC, (:ref, :catdims, :k)))
          )),
        (:line, 1083, :none),
        (:for, (:(=), :i, (:(:), 2, :nargs)), (:block,
            (:line, 1084, :none),
            (:for, (:(=), :d, (:(:), 1, :ndimsC)), (:block,
                (:line, 1085, :none),
                (:(=), :currentdim, (:if, (:call, :(<=), :d, (:ref, :ndimsX, :i)), (:call, :size, (:ref, :X, :i), :d), 1)),
                (:line, 1086, :none),
                (:if, (:call, :(!=), (:ref, :dims2cat, :d), 0), (:block,
                    (:line, 1087, :none),
                    (:+=, (:ref, :dimsC, :d), :currentdim),
                    (:line, 1088, :none),
                    (:(=), (:ref, :catsizes, :i, (:ref, :dims2cat, :d)), :currentdim)
                  ), (:block,
                    (:line, 1089, :none),
                    (:if, (:call, :(!=), (:ref, :dimsC, :d), :currentdim), (:block,
                        (:line, 1090, :none),
                        (:call, :throw, (:call, :DimensionMismatch, (:call, :string, "mismatch in dimension ", :d, " (expected ", (:ref, :dimsC, :d), " got ", :currentdim, ")")))
                      ))
                  ))
              ))
          )),
        (:line, 1097, :none),
        (:(=), :C, (:call, :similar, (:if, (:call, :isa, (:ref, :X, 1), :AbstractArray), (:ref, :X, 1), (:vect, (:ref, :X, 1))), :typeC, (:call, :tuple, (:..., :dimsC)))),
        (:line, 1098, :none),
        (:if, (:call, :>, (:call, :length, :catdims), 1), (:block,
            (:line, 1099, :none),
            (:call, :fill!, :C, 0)
          )),
        (:line, 1102, :none),
        (:(=), :offsets, (:call, :zeros, :Int, (:call, :length, :catdims))),
        (:line, 1103, :none),
        (:for, (:(=), :i, (:(:), 1, :nargs)), (:block,
            (:line, 1104, :none),
            (:(=), :cat_one, (:comprehension, (:generator, (:if, (:call, :(==), (:ref, :dims2cat, :d), 0), (:(:), 1, (:ref, :dimsC, :d)), (:call, :+, (:ref, :offsets, (:ref, :dims2cat, :d)), (:(:), 1, (:ref, :catsizes, :i, (:ref, :dims2cat, :d))))), (:(=), :d, (:(:), 1, :ndimsC))))),
            (:line, 1106, :none),
            (:(=), (:ref, :C, (:..., :cat_one)), (:ref, :X, :i)),
            (:line, 1107, :none),
            (:for, (:(=), :k, (:(:), 1, (:call, :length, :catdims))), (:block,
                (:line, 1108, :none),
                (:+=, (:ref, :offsets, :k), (:ref, :catsizes, :i, :k))
              ))
          )),
        (:line, 1111, :none),
        (:return, :C)
      )),
    (:line, 1114, :none),
    "    vcat(A...)\n\nConcatenate along dimension 1.\n\n```jldoctest\njulia> a = [1 2 3 4 5]\n1×5 Array{Int64,2}:\n 1  2  3  4  5\n\njulia> b = [6 7 8 9 10; 11 12 13 14 15]\n2×5 Array{Int64,2}:\n  6   7   8   9  10\n 11  12  13  14  15\n\njulia> vcat(a,b)\n3×5 Array{Int64,2}:\n  1   2   3   4   5\n  6   7   8   9  10\n 11  12  13  14  15\n\njulia> c = ([1 2 3], [4 5 6])\n(\n[1 2 3],\n<BLANKLINE>\n[4 5 6])\n\njulia> vcat(c...)\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n```\n",
    (:line, 1147, :none),
    (:(=), (:call, :vcat, (:..., :X)), (:block,
        (:line, 1147, :none),
        (:call, :cat, 1, (:..., :X))
      )),
    (:line, 1148, :none),
    "    hcat(A...)\n\nConcatenate along dimension 2.\n\n```jldoctest\njulia> a = [1; 2; 3; 4; 5]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> b = [6 7; 8 9; 10 11; 12 13; 14 15]\n5×2 Array{Int64,2}:\n  6   7\n  8   9\n 10  11\n 12  13\n 14  15\n\njulia> hcat(a,b)\n5×3 Array{Int64,2}:\n 1   6   7\n 2   8   9\n 3  10  11\n 4  12  13\n 5  14  15\n\njulia> c = ([1; 2; 3], [4; 5; 6])\n([1,2,3],[4,5,6])\n\njulia> hcat(c...)\n3×2 Array{Int64,2}:\n 1  4\n 2  5\n 3  6\n```\n",
    (:line, 1188, :none),
    (:(=), (:call, :hcat, (:..., :X)), (:block,
        (:line, 1188, :none),
        (:call, :cat, 2, (:..., :X))
      )),
    (:line, 1190, :none),
    (:(=), (:call, :typed_vcat, (:(::), :T, :Type), (:..., :X)), (:block,
        (:line, 1190, :none),
        (:call, :cat_t, 1, :T, (:..., :X))
      )),
    (:line, 1191, :none),
    (:(=), (:call, :typed_hcat, (:(::), :T, :Type), (:..., :X)), (:block,
        (:line, 1191, :none),
        (:call, :cat_t, 2, :T, (:..., :X))
      )),
    (:line, 1193, :none),
    (:(=), (:call, (:curly, :cat, :T), :catdims, (:..., (:(::), :A, (:curly, :AbstractArray, :T)))), (:block,
        (:line, 1193, :none),
        (:call, :cat_t, :catdims, :T, (:..., :A))
      )),
    (:line, 1195, :none),
    (:(=), (:call, :cat, :catdims, (:..., (:(::), :A, :AbstractArray))), (:block,
        (:line, 1195, :none),
        (:call, :cat_t, :catdims, (:call, :promote_eltype, (:..., :A)), (:..., :A))
      )),
    (:line, 1199, :none),
    (:(=), (:call, :vcat, (:(::), :A, :AbstractArray)), (:block,
        (:line, 1199, :none),
        (:call, :cat, 1, :A)
      )),
    (:line, 1200, :none),
    (:(=), (:call, :vcat, (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1200, :none),
        (:call, :cat, 1, :A, :B)
      )),
    (:line, 1201, :none),
    (:(=), (:call, :vcat, (:..., (:(::), :A, :AbstractArray))), (:block,
        (:line, 1201, :none),
        (:call, :cat, 1, (:..., :A))
      )),
    (:line, 1202, :none),
    (:(=), (:call, :hcat, (:(::), :A, :AbstractArray)), (:block,
        (:line, 1202, :none),
        (:call, :cat, 2, :A)
      )),
    (:line, 1203, :none),
    (:(=), (:call, :hcat, (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1203, :none),
        (:call, :cat, 2, :A, :B)
      )),
    (:line, 1204, :none),
    (:(=), (:call, :hcat, (:..., (:(::), :A, :AbstractArray))), (:block,
        (:line, 1204, :none),
        (:call, :cat, 2, (:..., :A))
      )),
    (:line, 1206, :none),
    (:(=), (:call, :typed_vcat, (:(::), :T, :Type), (:(::), :A, :AbstractArray)), (:block,
        (:line, 1206, :none),
        (:call, :cat_t, 1, :T, :A)
      )),
    (:line, 1207, :none),
    (:(=), (:call, :typed_vcat, (:(::), :T, :Type), (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1207, :none),
        (:call, :cat_t, 1, :T, :A, :B)
      )),
    (:line, 1208, :none),
    (:(=), (:call, :typed_vcat, (:(::), :T, :Type), (:..., (:(::), :A, :AbstractArray))), (:block,
        (:line, 1208, :none),
        (:call, :cat_t, 1, :T, (:..., :A))
      )),
    (:line, 1209, :none),
    (:(=), (:call, :typed_hcat, (:(::), :T, :Type), (:(::), :A, :AbstractArray)), (:block,
        (:line, 1209, :none),
        (:call, :cat_t, 2, :T, :A)
      )),
    (:line, 1210, :none),
    (:(=), (:call, :typed_hcat, (:(::), :T, :Type), (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1210, :none),
        (:call, :cat_t, 2, :T, :A, :B)
      )),
    (:line, 1211, :none),
    (:(=), (:call, :typed_hcat, (:(::), :T, :Type), (:..., (:(::), :A, :AbstractArray))), (:block,
        (:line, 1211, :none),
        (:call, :cat_t, 2, :T, (:..., :A))
      )),
    (:line, 1215, :none),
    (:function, (:call, :hvcat, (:(::), :nbc, :Integer), (:..., :as)), (:block,
        (:line, 1217, :none),
        (:(=), :n, (:call, :length, :as)),
        (:line, 1218, :none),
        (:&&, (:call, :(!=), (:call, :mod, :n, :nbc), 0), (:call, :throw, (:call, :ArgumentError, (:string, "number of arrays ", :n, " is not a multiple of the requested number of block columns ", :nbc)))),
        (:line, 1220, :none),
        (:(=), :nbr, (:call, :div, :n, :nbc)),
        (:line, 1221, :none),
        (:call, :hvcat, (:call, :ntuple, (:->, :i, (:block,
                (:line, 1221, :none),
                :nbc
              )), :nbr), (:..., :as))
      )),
    (:line, 1224, :none),
    "    hvcat(rows::Tuple{Vararg{Int}}, values...)\n\nHorizontal and vertical concatenation in one call. This function is called for block matrix\nsyntax. The first argument specifies the number of arguments to concatenate in each block\nrow.\n\n```jldoctest\njulia> a, b, c, d, e, f = 1, 2, 3, 4, 5, 6\n(1,2,3,4,5,6)\n\njulia> [a b c; d e f]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> hvcat((3,3), a,b,c,d,e,f)\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> [a b;c d; e f]\n3×2 Array{Int64,2}:\n 1  2\n 3  4\n 5  6\n\njulia> hvcat((2,2,2), a,b,c,d,e,f)\n3×2 Array{Int64,2}:\n 1  2\n 3  4\n 5  6\n```\n\nIf the first argument is a single integer `n`, then all block rows are assumed to have `n`\nblock columns.\n",
    (:line, 1261, :none),
    (:(=), (:call, :hvcat, (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., (:(::), :xs, :AbstractMatrix))), (:block,
        (:line, 1261, :none),
        (:call, :typed_hvcat, (:call, :promote_eltype, (:..., :xs)), :rows, (:..., :xs))
      )),
    (:line, 1262, :none),
    (:(=), (:call, (:curly, :hvcat, :T), (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., (:(::), :xs, (:curly, :AbstractMatrix, :T)))), (:block,
        (:line, 1262, :none),
        (:call, :typed_hvcat, :T, :rows, (:..., :xs))
      )),
    (:line, 1264, :none),
    (:function, (:call, (:curly, :typed_hvcat, :T), (:(::), (:curly, :Type, :T)), (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., (:(::), :as, :AbstractMatrix))), (:block,
        (:line, 1265, :none),
        (:(=), :nbr, (:call, :length, :rows)),
        (:line, 1267, :none),
        (:(=), :nc, 0),
        (:line, 1268, :none),
        (:for, (:(=), :i, (:(:), 1, (:ref, :rows, 1))), (:block,
            (:line, 1269, :none),
            (:+=, :nc, (:call, :size, (:ref, :as, :i), 2))
          )),
        (:line, 1272, :none),
        (:(=), :nr, 0),
        (:line, 1273, :none),
        (:(=), :a, 1),
        (:line, 1274, :none),
        (:for, (:(=), :i, (:(:), 1, :nbr)), (:block,
            (:line, 1275, :none),
            (:+=, :nr, (:call, :size, (:ref, :as, :a), 1)),
            (:line, 1276, :none),
            (:+=, :a, (:ref, :rows, :i))
          )),
        (:line, 1279, :none),
        (:(=), :out, (:call, :similar, (:call, :full, (:ref, :as, 1)), :T, :nr, :nc)),
        (:line, 1281, :none),
        (:(=), :a, 1),
        (:line, 1282, :none),
        (:(=), :r, 1),
        (:line, 1283, :none),
        (:for, (:(=), :i, (:(:), 1, :nbr)), (:block,
            (:line, 1284, :none),
            (:(=), :c, 1),
            (:line, 1285, :none),
            (:(=), :szi, (:call, :size, (:ref, :as, :a), 1)),
            (:line, 1286, :none),
            (:for, (:(=), :j, (:(:), 1, (:ref, :rows, :i))), (:block,
                (:line, 1287, :none),
                (:(=), :Aj, (:ref, :as, (:call, :-, (:call, :+, :a, :j), 1))),
                (:line, 1288, :none),
                (:(=), :szj, (:call, :size, :Aj, 2)),
                (:line, 1289, :none),
                (:if, (:call, :(!=), (:call, :size, :Aj, 1), :szi), (:block,
                    (:line, 1290, :none),
                    (:call, :throw, (:call, :ArgumentError, (:string, "mismatched height in block row ", :i, " (expected ", :szi, ", got ", (:call, :size, :Aj, 1), ")")))
                  )),
                (:line, 1292, :none),
                (:if, (:call, :>, (:call, :+, (:call, :-, :c, 1), :szj), :nc), (:block,
                    (:line, 1293, :none),
                    (:call, :throw, (:call, :ArgumentError, (:string, "block row ", :i, " has mismatched number of columns (expected ", :nc, ", got ", (:call, :+, (:call, :-, :c, 1), :szj), ")")))
                  )),
                (:line, 1295, :none),
                (:(=), (:ref, :out, (:(:), :r, (:call, :+, (:call, :-, :r, 1), :szi)), (:(:), :c, (:call, :+, (:call, :-, :c, 1), :szj))), :Aj),
                (:line, 1296, :none),
                (:+=, :c, :szj)
              )),
            (:line, 1298, :none),
            (:if, (:call, :(!=), :c, (:call, :+, :nc, 1)), (:block,
                (:line, 1299, :none),
                (:call, :throw, (:call, :ArgumentError, (:string, "block row ", :i, " has mismatched number of columns (expected ", :nc, ", got ", (:call, :-, :c, 1), ")")))
              )),
            (:line, 1301, :none),
            (:+=, :r, :szi),
            (:line, 1302, :none),
            (:+=, :a, (:ref, :rows, :i))
          )),
        (:line, 1304, :none),
        :out
      )),
    (:line, 1307, :none),
    (:(=), (:call, :hvcat, (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int)))), (:block,
        (:line, 1307, :none),
        (:vect,)
      )),
    (:line, 1308, :none),
    (:(=), (:call, (:curly, :typed_hvcat, :T), (:(::), (:curly, :Type, :T)), (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int)))), (:block,
        (:line, 1308, :none),
        (:call, (:curly, :Array, :T, 1), 0)
      )),
    (:line, 1310, :none),
    (:function, (:call, (:curly, :hvcat, (:<:, :T, :Number)), (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., (:(::), :xs, :T))), (:block,
        (:line, 1311, :none),
        (:(=), :nr, (:call, :length, :rows)),
        (:line, 1312, :none),
        (:(=), :nc, (:ref, :rows, 1)),
        (:line, 1314, :none),
        (:(=), :a, (:call, (:curly, :Array, :T, 2), :nr, :nc)),
        (:line, 1315, :none),
        (:if, (:call, :(!=), (:call, :length, :a), (:call, :length, :xs)), (:block,
            (:line, 1316, :none),
            (:call, :throw, (:call, :ArgumentError, (:string, "argument count does not match specified shape (expected ", (:call, :length, :a), ", got ", (:call, :length, :xs), ")")))
          )),
        (:line, 1318, :none),
        (:(=), :k, 1),
        (:line, 1319, :none),
        (:macrocall, Symbol("@inbounds"), (:for, (:(=), :i, (:(:), 1, :nr)), (:block,
              (:line, 1320, :none),
              (:if, (:call, :(!=), :nc, (:ref, :rows, :i)), (:block,
                  (:line, 1321, :none),
                  (:call, :throw, (:call, :ArgumentError, (:string, "row ", :i, " has mismatched number of columns (expected ", :nc, ", got ", (:ref, :rows, :i), ")")))
                )),
              (:line, 1323, :none),
              (:for, (:(=), :j, (:(:), 1, :nc)), (:block,
                  (:line, 1324, :none),
                  (:(=), (:ref, :a, :i, :j), (:ref, :xs, :k)),
                  (:line, 1325, :none),
                  (:+=, :k, 1)
                ))
            ))),
        (:line, 1328, :none),
        :a
      )),
    (:line, 1331, :none),
    (:function, (:call, :hvcat_fill, (:(::), :a, :Array), (:(::), :xs, :Tuple)), (:block,
        (:line, 1332, :none),
        (:(=), :k, 1),
        (:line, 1333, :none),
        (:(=), (:tuple, :nr, :nc), (:tuple, (:call, :size, :a, 1), (:call, :size, :a, 2))),
        (:line, 1334, :none),
        (:for, (:(=), :i, (:(:), 1, :nr)), (:block,
            (:line, 1335, :none),
            (:macrocall, Symbol("@inbounds"), (:for, (:(=), :j, (:(:), 1, :nc)), (:block,
                  (:line, 1336, :none),
                  (:(=), (:ref, :a, :i, :j), (:ref, :xs, :k)),
                  (:line, 1337, :none),
                  (:+=, :k, 1)
                )))
          )),
        (:line, 1340, :none),
        :a
      )),
    (:line, 1343, :none),
    (:(=), (:call, :hvcat, (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., (:(::), :xs, :Number))), (:block,
        (:line, 1343, :none),
        (:call, :typed_hvcat, (:call, :promote_typeof, (:..., :xs)), :rows, (:..., :xs))
      )),
    (:line, 1345, :none),
    (:function, (:call, (:curly, :typed_hvcat, :T), (:(::), (:curly, :Type, :T)), (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., (:(::), :xs, :Number))), (:block,
        (:line, 1346, :none),
        (:(=), :nr, (:call, :length, :rows)),
        (:line, 1347, :none),
        (:(=), :nc, (:ref, :rows, 1)),
        (:line, 1348, :none),
        (:for, (:(=), :i, (:(:), 2, :nr)), (:block,
            (:line, 1349, :none),
            (:if, (:call, :(!=), :nc, (:ref, :rows, :i)), (:block,
                (:line, 1350, :none),
                (:call, :throw, (:call, :ArgumentError, (:string, "row ", :i, " has mismatched number of columns (expected ", :nc, ", got ", (:ref, :rows, :i), ")")))
              ))
          )),
        (:line, 1353, :none),
        (:(=), :len, (:call, :length, :xs)),
        (:line, 1354, :none),
        (:if, (:call, :(!=), (:call, :*, :nr, :nc), :len), (:block,
            (:line, 1355, :none),
            (:call, :throw, (:call, :ArgumentError, (:string, "argument count ", :len, " does not match specified shape ", (:tuple, :nr, :nc))))
          )),
        (:line, 1357, :none),
        (:call, :hvcat_fill, (:call, (:curly, :Array, :T, 2), :nr, :nc), :xs)
      )),
    (:line, 1361, :none),
    (:function, (:call, :hvcat, (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., :as)), (:block,
        (:line, 1362, :none),
        (:(=), :nbr, (:call, :length, :rows)),
        (:line, 1363, :none),
        (:(=), :rs, (:call, (:curly, :Array, :Any, 1), :nbr)),
        (:line, 1364, :none),
        (:(=), :a, 1),
        (:line, 1365, :none),
        (:for, (:(=), :i, (:(:), 1, :nbr)), (:block,
            (:line, 1366, :none),
            (:(=), (:ref, :rs, :i), (:call, :hcat, (:..., (:ref, :as, (:(:), :a, (:call, :+, (:call, :-, :a, 1), (:ref, :rows, :i))))))),
            (:line, 1367, :none),
            (:+=, :a, (:ref, :rows, :i))
          )),
        (:line, 1369, :none),
        (:call, :vcat, (:..., :rs))
      )),
    (:line, 1372, :none),
    (:function, (:call, (:curly, :typed_hvcat, :T), (:(::), (:curly, :Type, :T)), (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., :as)), (:block,
        (:line, 1373, :none),
        (:(=), :nbr, (:call, :length, :rows)),
        (:line, 1374, :none),
        (:(=), :rs, (:call, (:curly, :Array, :Any, 1), :nbr)),
        (:line, 1375, :none),
        (:(=), :a, 1),
        (:line, 1376, :none),
        (:for, (:(=), :i, (:(:), 1, :nbr)), (:block,
            (:line, 1377, :none),
            (:(=), (:ref, :rs, :i), (:call, :typed_hcat, :T, (:..., (:ref, :as, (:(:), :a, (:call, :+, (:call, :-, :a, 1), (:ref, :rows, :i))))))),
            (:line, 1378, :none),
            (:+=, :a, (:ref, :rows, :i))
          )),
        (:line, 1380, :none),
        (:typed_vcat, :T, (:..., :rs))
      )),
    (:line, 1385, :none),
    (:function, (:call, :isequal, (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1386, :none),
        (:if, (:call, :(===), :A, :B), (:block,
            (:line, 1386, :none),
            (:return, true)
          )),
        (:line, 1387, :none),
        (:if, (:call, :(!=), (:call, :indices, :A), (:call, :indices, :B)), (:block,
            (:line, 1388, :none),
            (:return, false)
          )),
        (:line, 1390, :none),
        (:if, (:call, :(!=), (:call, :isa, :A, :Range), (:call, :isa, :B, :Range)), (:block,
            (:line, 1391, :none),
            (:return, false)
          )),
        (:line, 1393, :none),
        (:for, (:(=), (:tuple, :a, :b), (:call, :zip, :A, :B)), (:block,
            (:line, 1394, :none),
            (:if, (:call, :!, (:call, :isequal, :a, :b)), (:block,
                (:line, 1395, :none),
                (:return, false)
              ))
          )),
        (:line, 1398, :none),
        (:return, true)
      )),
    (:line, 1401, :none),
    (:function, (:call, :lexcmp, (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1402, :none),
        (:for, (:(=), (:tuple, :a, :b), (:call, :zip, :A, :B)), (:block,
            (:line, 1403, :none),
            (:(=), :res, (:call, :lexcmp, :a, :b)),
            (:line, 1404, :none),
            (:||, (:call, :(==), :res, 0), (:return, :res))
          )),
        (:line, 1406, :none),
        (:return, (:call, :cmp, (:call, :length, :A), (:call, :length, :B)))
      )),
    (:line, 1409, :none),
    (:function, (:call, :(==), (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1410, :none),
        (:if, (:call, :(!=), (:call, :indices, :A), (:call, :indices, :B)), (:block,
            (:line, 1411, :none),
            (:return, false)
          )),
        (:line, 1413, :none),
        (:if, (:call, :(!=), (:call, :isa, :A, :Range), (:call, :isa, :B, :Range)), (:block,
            (:line, 1414, :none),
            (:return, false)
          )),
        (:line, 1416, :none),
        (:for, (:(=), (:tuple, :a, :b), (:call, :zip, :A, :B)), (:block,
            (:line, 1417, :none),
            (:if, (:call, :!, (:call, :(==), :a, :b)), (:block,
                (:line, 1418, :none),
                (:return, false)
              ))
          )),
        (:line, 1421, :none),
        (:return, true)
      )),
    (:line, 1426, :none),
    (:function, (:call, :sub2ind, (:(::), :A, :AbstractArray), (:..., :I)), (:block,
        (:line, 1427, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 1428, :none),
        (:call, :sub2ind, (:call, :indices, :A), (:..., :I))
      )),
    (:line, 1430, :none),
    (:function, (:call, :ind2sub, (:(::), :A, :AbstractArray), :ind), (:block,
        (:line, 1431, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 1432, :none),
        (:call, :ind2sub, (:call, :indices, :A), :ind)
      )),
    (:line, 1436, :none),
    (:(=), (:call, :sub2ind, (:(::), (:curly, :Tuple))), (:block,
        (:line, 1436, :none),
        1
      )),
    (:line, 1437, :none),
    (:(=), (:call, :sub2ind, (:(::), :DimsInteger)), (:block,
        (:line, 1437, :none),
        1
      )),
    (:line, 1438, :none),
    (:(=), (:call, :sub2ind, (:(::), :Indices)), (:block,
        (:line, 1438, :none),
        1
      )),
    (:line, 1439, :none),
    (:(=), (:call, :sub2ind, (:(::), (:curly, :Tuple)), (:..., (:(::), :I, :Integer))), (:block,
        (:line, 1439, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_sub2ind, (:tuple,), 1, 1, (:..., :I))
        )
      )),
    (:line, 1441, :none),
    (:(=), (:call, :sub2ind, (:(::), :dims, :DimsInteger), (:..., (:(::), :I, :Integer))), (:block,
        (:line, 1441, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_sub2ind, :dims, 1, 1, (:..., :I))
        )
      )),
    (:line, 1442, :none),
    (:(=), (:call, :sub2ind, (:(::), :inds, :Indices), (:..., (:(::), :I, :Integer))), (:block,
        (:line, 1442, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_sub2ind, :inds, 1, 1, (:..., :I))
        )
      )),
    (:line, 1445, :none),
    (:(=), (:call, :sub2ind, (:(::), :inds, (:curly, :Indices, 1)), (:..., (:(::), :I, :Integer))), (:block,
        (:line, 1445, :none),
        (:call, :throw, (:call, :ArgumentError, "Linear indexing is not defined for one-dimensional arrays"))
      )),
    (:line, 1446, :none),
    (:(=), (:call, :sub2ind, (:(::), :inds, (:curly, :Tuple, :OneTo)), (:..., (:(::), :I, :Integer))), (:block,
        (:line, 1446, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_sub2ind, :inds, 1, 1, (:..., :I))
        )
      )),
    (:line, 1447, :none),
    (:(=), (:call, :sub2ind, (:(::), :inds, (:curly, :Tuple, :OneTo)), (:(::), :i, :Integer)), (:block,
        (:line, 1447, :none),
        :i
      )),
    (:line, 1449, :none),
    (:(=), (:call, :_sub2ind, (:(::), :Any), :L, :ind), (:block,
        (:line, 1449, :none),
        :ind
      )),
    (:line, 1450, :none),
    (:function, (:call, :_sub2ind, (:(::), (:curly, :Tuple)), :L, :ind, (:(::), :i, :Integer), (:..., (:(::), :I, :Integer))), (:block,
        (:line, 1451, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 1452, :none),
        (:call, :_sub2ind, (:tuple,), :L, (:call, :+, :ind, (:call, :*, (:call, :-, :i, 1), :L)), (:..., :I))
      )),
    (:line, 1454, :none),
    (:function, (:call, :_sub2ind, :inds, :L, :ind, (:(::), :i, :Integer), (:..., (:(::), :I, :Integer))), (:block,
        (:line, 1455, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 1456, :none),
        (:(=), :r1, (:ref, :inds, 1)),
        (:line, 1457, :none),
        (:call, :_sub2ind, (:call, :tail, :inds), (:call, :nextL, :L, :r1), (:call, :+, :ind, (:call, :*, (:call, :offsetin, :i, :r1), :L)), (:..., :I))
      )),
    (:line, 1460, :none),
    (:(=), (:call, :nextL, :L, (:(::), :l, :Integer)), (:block,
        (:line, 1460, :none),
        (:call, :*, :L, :l)
      )),
    (:line, 1461, :none),
    (:(=), (:call, :nextL, :L, (:(::), :r, :AbstractUnitRange)), (:block,
        (:line, 1461, :none),
        (:call, :*, :L, (:call, :unsafe_length, :r))
      )),
    (:line, 1462, :none),
    (:(=), (:call, :offsetin, :i, (:(::), :l, :Integer)), (:block,
        (:line, 1462, :none),
        (:call, :-, :i, 1)
      )),
    (:line, 1463, :none),
    (:(=), (:call, :offsetin, :i, (:(::), :r, :AbstractUnitRange)), (:block,
        (:line, 1463, :none),
        (:call, :-, :i, (:call, :first, :r))
      )),
    (:line, 1465, :none),
    (:(=), (:call, :ind2sub, (:(::), (:curly, :Tuple)), (:(::), :ind, :Integer)), (:block,
        (:line, 1465, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:if, (:call, :(==), :ind, 1), (:tuple,), (:call, :throw, (:call, :BoundsError)))
        )
      )),
    (:line, 1466, :none),
    (:(=), (:call, :ind2sub, (:(::), :dims, :DimsInteger), (:(::), :ind, :Integer)), (:block,
        (:line, 1466, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_ind2sub, :dims, (:call, :-, :ind, 1))
        )
      )),
    (:line, 1467, :none),
    (:(=), (:call, :ind2sub, (:(::), :inds, :Indices), (:(::), :ind, :Integer)), (:block,
        (:line, 1467, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_ind2sub, :inds, (:call, :-, :ind, 1))
        )
      )),
    (:line, 1468, :none),
    (:(=), (:call, :ind2sub, (:(::), :inds, (:curly, :Indices, 1)), (:(::), :ind, :Integer)), (:block,
        (:line, 1468, :none),
        (:call, :throw, (:call, :ArgumentError, "Linear indexing is not defined for one-dimensional arrays"))
      )),
    (:line, 1469, :none),
    (:(=), (:call, :ind2sub, (:(::), :inds, (:curly, :Tuple, :OneTo)), (:(::), :ind, :Integer)), (:block,
        (:line, 1469, :none),
        (:tuple, :ind)
      )),
    (:line, 1471, :none),
    (:(=), (:call, :_ind2sub, (:(::), (:curly, :Tuple)), :ind), (:block,
        (:line, 1471, :none),
        (:tuple, (:call, :+, :ind, 1))
      )),
    (:line, 1472, :none),
    (:function, (:call, :_ind2sub, (:(::), :indslast, (:curly, :NTuple, 1)), :ind), (:block,
        (:line, 1473, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 1474, :none),
        (:tuple, (:call, :_lookup, :ind, (:ref, :indslast, 1)))
      )),
    (:line, 1476, :none),
    (:function, (:call, :_ind2sub, :inds, :ind), (:block,
        (:line, 1477, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 1478, :none),
        (:(=), :r1, (:ref, :inds, 1)),
        (:line, 1479, :none),
        (:(=), (:tuple, :indnext, :f, :l), (:call, :_div, :ind, :r1)),
        (:line, 1480, :none),
        (:tuple, (:call, :+, (:call, :-, :ind, (:call, :*, :l, :indnext)), :f), (:..., (:call, :_ind2sub, (:call, :tail, :inds), :indnext)))
      )),
    (:line, 1483, :none),
    (:(=), (:call, :_lookup, :ind, (:(::), :d, :Integer)), (:block,
        (:line, 1483, :none),
        (:call, :+, :ind, 1)
      )),
    (:line, 1484, :none),
    (:(=), (:call, :_lookup, :ind, (:(::), :r, :AbstractUnitRange)), (:block,
        (:line, 1484, :none),
        (:call, :+, :ind, (:call, :first, :r))
      )),
    (:line, 1485, :none),
    (:(=), (:call, :_div, :ind, (:(::), :d, :Integer)), (:block,
        (:line, 1485, :none),
        (:tuple, (:call, :div, :ind, :d), 1, :d)
      )),
    (:line, 1486, :none),
    (:(=), (:call, :_div, :ind, (:(::), :r, :AbstractUnitRange)), (:block,
        (:line, 1486, :none),
        (:block,
          (:(=), :d, (:call, :unsafe_length, :r)),
          (:tuple, (:call, :div, :ind, :d), (:call, :first, :r), :d)
        )
      )),
    (:line, 1489, :none),
    (:function, (:call, (:curly, :sub2ind, (:<:, :T, :Integer)), (:(::), :inds, (:curly, :Indices, 1)), (:(::), :I1, (:curly, :AbstractVector, :T)), (:..., (:(::), :I, (:curly, :AbstractVector, :T)))), (:block,
        (:line, 1490, :none),
        (:call, :throw, (:call, :ArgumentError, "Linear indexing is not defined for one-dimensional arrays"))
      )),
    (:line, 1492, :none),
    (:(=), (:call, (:curly, :sub2ind, (:<:, :T, :Integer)), (:(::), :inds, (:curly, :Tuple, :OneTo)), (:(::), :I1, (:curly, :AbstractVector, :T)), (:..., (:(::), :I, (:curly, :AbstractVector, :T)))), (:block,
        (:line, 1492, :none),
        (:call, :_sub2ind_vecs, :inds, :I1, (:..., :I))
      )),
    (:line, 1493, :none),
    (:(=), (:call, (:curly, :sub2ind, (:<:, :T, :Integer)), (:(::), :inds, (:curly, :Union, :DimsInteger, :Indices)), (:(::), :I1, (:curly, :AbstractVector, :T)), (:..., (:(::), :I, (:curly, :AbstractVector, :T)))), (:block,
        (:line, 1493, :none),
        (:call, :_sub2ind_vecs, :inds, :I1, (:..., :I))
      )),
    (:line, 1494, :none),
    (:function, (:call, :_sub2ind_vecs, :inds, (:..., (:(::), :I, :AbstractVector))), (:block,
        (:line, 1495, :none),
        (:(=), :I1, (:ref, :I, 1)),
        (:line, 1496, :none),
        (:(=), :Iinds, (:call, :indices1, :I1)),
        (:line, 1497, :none),
        (:for, (:(=), :j, (:(:), 2, (:call, :length, :I))), (:block,
            (:line, 1498, :none),
            (:||, (:call, :(==), (:call, :indices1, (:ref, :I, :j)), :Iinds), (:call, :throw, (:call, :DimensionMismatch, (:string, "indices of I[1] (", :Iinds, ") does not match indices of I[", :j, "] (", (:call, :indices1, (:ref, :I, :j)), ")"))))
          )),
        (:line, 1500, :none),
        (:(=), :Iout, (:call, :similar, :I1)),
        (:line, 1501, :none),
        (:call, :_sub2ind!, :Iout, :inds, :Iinds, :I),
        (:line, 1502, :none),
        :Iout
      )),
    (:line, 1505, :none),
    (:function, (:call, :_sub2ind!, :Iout, :inds, :Iinds, :I), (:block,
        (:line, 1506, :none),
        (:macrocall, Symbol("@_noinline_meta")),
        (:line, 1507, :none),
        (:for, (:(=), :i, :Iinds), (:block,
            (:line, 1509, :none),
            (:(=), (:ref, :Iout, :i), (:call, :sub2ind_vec, :inds, :i, :I))
          )),
        (:line, 1511, :none),
        :Iout
      )),
    (:line, 1514, :none),
    (:(=), (:call, :sub2ind_vec, :inds, :i, :I), (:block,
        (:line, 1514, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_sub2ind_vec, :inds, (:tuple,), :i, (:..., :I))
        )
      )),
    (:line, 1515, :none),
    (:(=), (:call, :_sub2ind_vec, :inds, :out, :i, :I1, (:..., :I)), (:block,
        (:line, 1515, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_sub2ind_vec, :inds, (:tuple, (:..., :out), (:ref, :I1, :i)), :i, (:..., :I))
        )
      )),
    (:line, 1516, :none),
    (:(=), (:call, :_sub2ind_vec, :inds, :out, :i), (:block,
        (:line, 1516, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :sub2ind, :inds, (:..., :out))
        )
      )),
    (:line, 1518, :none),
    (:function, (:call, (:curly, :ind2sub, :N, (:<:, :T, :Integer)), (:(::), :inds, (:curly, :Union, (:curly, :DimsInteger, :N), (:curly, :Indices, :N))), (:(::), :ind, (:curly, :AbstractVector, :T))), (:block,
        (:line, 1519, :none),
        (:(=), :M, (:call, :length, :ind)),
        (:line, 1520, :none),
        (:(=), :t, (:call, :ntuple, (:->, :n, (:block,
                (:line, 1520, :none),
                (:call, :similar, :ind)
              )), (:curly, :Val, :N))),
        (:line, 1521, :none),
        (:for, (:(=), (:tuple, :i, :idx), (:call, :enumerate, :ind)), (:block,
            (:line, 1522, :none),
            (:(=), :sub, (:call, :ind2sub, :inds, :idx)),
            (:line, 1523, :none),
            (:for, (:(=), :j, (:(:), 1, :N)), (:block,
                (:line, 1524, :none),
                (:(=), (:ref, (:ref, :t, :j), :i), (:ref, :sub, :j))
              ))
          )),
        (:line, 1527, :none),
        :t
      )),
    (:line, 1530, :none),
    (:function, (:call, (:curly, :ind2sub!, (:<:, :T, :Integer)), (:(::), :sub, (:curly, :Array, :T)), (:(::), :dims, (:curly, :Tuple, (:curly, :Vararg, :T))), (:(::), :ind, :T)), (:block,
        (:line, 1531, :none),
        (:(=), :ndims, (:call, :length, :dims)),
        (:line, 1532, :none),
        (:for, (:(=), :i, (:(:), 1, (:call, :-, :ndims, 1))), (:block,
            (:line, 1533, :none),
            (:(=), :ind2, (:call, :+, (:call, :div, (:call, :-, :ind, 1), (:ref, :dims, :i)), 1)),
            (:line, 1534, :none),
            (:(=), (:ref, :sub, :i), (:call, :-, :ind, (:call, :*, (:ref, :dims, :i), (:call, :-, :ind2, 1)))),
            (:line, 1535, :none),
            (:(=), :ind, :ind2)
          )),
        (:line, 1537, :none),
        (:(=), (:ref, :sub, :ndims), :ind),
        (:line, 1538, :none),
        (:return, :sub)
      )),
    (:line, 1543, :none),
    "    foreach(f, c...) -> Void\n\nCall function `f` on each element of iterable `c`.\nFor multiple iterable arguments, `f` is called elementwise.\n`foreach` should be used instead of `map` when the results of `f` are not\nneeded, for example in `foreach(println, array)`.\n\n```jldoctest\njulia> a = 1:3:7;\n\njulia> foreach(x->println(x^2),a)\n1\n16\n49\n```\n",
    (:line, 1560, :none),
    (:(=), (:call, :foreach, :f), (:block,
        (:line, 1560, :none),
        (:block,
          (:call, :f),
          :nothing
        )
      )),
    (:line, 1561, :none),
    (:(=), (:call, :foreach, :f, :itr), (:block,
        (:line, 1561, :none),
        (:block,
          (:for, (:(=), :x, :itr), (:block,
              (:line, 1561, :none),
              (:call, :f, :x)
            )),
          :nothing
        )
      )),
    (:line, 1562, :none),
    (:(=), (:call, :foreach, :f, (:..., :itrs)), (:block,
        (:line, 1562, :none),
        (:block,
          (:for, (:(=), :z, (:call, :zip, (:..., :itrs))), (:block,
              (:line, 1562, :none),
              (:call, :f, (:..., :z))
            )),
          :nothing
        )
      )),
    (:line, 1569, :none),
    "    mapslices(f, A, dims)\n\nTransform the given dimensions of array `A` using function `f`. `f` is called on each slice\nof `A` of the form `A[...,:,...,:,...]`. `dims` is an integer vector specifying where the\ncolons go in this expression. The results are concatenated along the remaining dimensions.\nFor example, if `dims` is `[1,2]` and `A` is 4-dimensional, `f` is called on `A[:,:,i,j]`\nfor all `i` and `j`.\n\n```jldoctest\njulia> a = reshape(collect(1:16),(2,2,2,2))\n2×2×2×2 Array{Int64,4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n<BLANKLINE>\n[:, :, 2, 1] =\n 5  7\n 6  8\n<BLANKLINE>\n[:, :, 1, 2] =\n  9  11\n 10  12\n<BLANKLINE>\n[:, :, 2, 2] =\n 13  15\n 14  16\n\njulia> mapslices(sum, a, [1,2])\n1×1×2×2 Array{Int64,4}:\n[:, :, 1, 1] =\n 10\n<BLANKLINE>\n[:, :, 2, 1] =\n 26\n<BLANKLINE>\n[:, :, 1, 2] =\n 42\n<BLANKLINE>\n[:, :, 2, 2] =\n 58\n```\n",
    (:line, 1612, :none),
    (:(=), (:call, :mapslices, :f, (:(::), :A, :AbstractArray), :dims), (:block,
        (:line, 1612, :none),
        (:call, :mapslices, :f, :A, (:vect, (:..., :dims)))
      )),
    (:line, 1613, :none),
    (:function, (:call, :mapslices, :f, (:(::), :A, :AbstractArray), (:(::), :dims, :AbstractVector)), (:block,
        (:line, 1614, :none),
        (:if, (:call, :isempty, :dims), (:block,
            (:line, 1615, :none),
            (:return, (:call, :map, :f, :A))
          )),
        (:line, 1618, :none),
        (:(=), :dimsA, (:vect, (:..., (:call, :indices, :A)))),
        (:line, 1619, :none),
        (:(=), :ndimsA, (:call, :ndims, :A)),
        (:line, 1620, :none),
        (:(=), :alldims, (:vcat, (:(:), 1, :ndimsA))),
        (:line, 1622, :none),
        (:(=), :otherdims, (:call, :setdiff, :alldims, :dims)),
        (:line, 1624, :none),
        (:(=), :idx, (:typed_comprehension, :Any, (:generator, (:call, :first, :ind), (:(=), :ind, (:call, :indices, :A))))),
        (:line, 1625, :none),
        (:(=), :itershape, (:call, :tuple, (:..., (:ref, :dimsA, :otherdims)))),
        (:line, 1626, :none),
        (:for, (:(=), :d, :dims), (:block,
            (:line, 1627, :none),
            (:(=), (:ref, :idx, :d), (:call, :Colon))
          )),
        (:line, 1630, :none),
        (:(=), :Aslice, (:ref, :A, (:..., :idx))),
        (:line, 1631, :none),
        (:(=), :r1, (:call, :f, :Aslice)),
        (:line, 1634, :none),
        (:(=), :Rsize, (:call, :copy, :dimsA)),
        (:line, 1636, :none),
        (:if, (:||, (:call, :!, (:call, :isa, :r1, :AbstractArray)), (:call, :(==), (:call, :ndims, :r1), 0)), (:block,
            (:line, 1637, :none),
            (:(=), :r1, (:vect, :r1))
          )),
        (:line, 1639, :none),
        (:(=), :nextra, (:call, :max, 0, (:call, :-, (:call, :length, :dims), (:call, :ndims, :r1)))),
        (:line, 1640, :none),
        (:if, (:call, :(==), (:call, :eltype, :Rsize), :Int), (:block,
            (:line, 1641, :none),
            (:(=), (:ref, :Rsize, :dims), (:vect, (:..., (:call, :size, :r1)), (:..., (:call, :ntuple, (:->, :d, (:block,
                        (:line, 1641, :none),
                        1
                      )), :nextra))))
          ), (:block,
            (:line, 1643, :none),
            (:(=), (:ref, :Rsize, :dims), (:vect, (:..., (:call, :indices, :r1)), (:..., (:call, :ntuple, (:->, :d, (:block,
                        (:line, 1643, :none),
                        (:call, :OneTo, 1)
                      )), :nextra))))
          )),
        (:line, 1645, :none),
        (:(=), :R, (:call, :similar, :r1, (:call, :tuple, (:..., :Rsize)))),
        (:line, 1647, :none),
        (:(=), :ridx, (:ref, :Any, (:..., (:call, :map, :first, (:call, :indices, :R))))),
        (:line, 1648, :none),
        (:for, (:(=), :d, :dims), (:block,
            (:line, 1649, :none),
            (:(=), (:ref, :ridx, :d), (:call, :indices, :R, :d))
          )),
        (:line, 1652, :none),
        (:(=), (:ref, :R, (:..., :ridx)), :r1),
        (:line, 1654, :none),
        (:(=), :isfirst, true),
        (:line, 1655, :none),
        (:(=), :nidx, (:call, :length, :otherdims)),
        (:line, 1656, :none),
        (:for, (:(=), :I, (:call, :CartesianRange, :itershape)), (:block,
            (:line, 1657, :none),
            (:if, :isfirst, (:block,
                (:line, 1658, :none),
                (:(=), :isfirst, false)
              ), (:block,
                (:line, 1660, :none),
                (:for, (:(=), :i, (:(:), 1, :nidx)), (:block,
                    (:line, 1661, :none),
                    (:(=), (:ref, :idx, (:ref, :otherdims, :i)), (:(=), (:ref, :ridx, (:ref, :otherdims, :i)), (:ref, (:., :I, (:quote, #QuoteNode
                              :I
                            )), :i)))
                  )),
                (:line, 1663, :none),
                (:call, :_unsafe_getindex!, :Aslice, :A, (:..., :idx)),
                (:line, 1664, :none),
                (:(=), (:ref, :R, (:..., :ridx)), (:call, :f, :Aslice))
              ))
          )),
        (:line, 1668, :none),
        (:return, :R)
      )),
    (:line, 1672, :none),
    (:(=), (:call, :promote_eltype_op, (:(::), :Any)), (:block,
        (:line, 1672, :none),
        (:block,
          (:macrocall, Symbol("@_pure_meta")),
          :Any
        )
      )),
    (:line, 1673, :none),
    (:(=), (:call, :promote_eltype_op, :op, :A), (:block,
        (:line, 1673, :none),
        (:block,
          (:macrocall, Symbol("@_pure_meta")),
          (:call, :promote_op, :op, (:call, :eltype, :A))
        )
      )),
    (:line, 1674, :none),
    (:(=), (:call, (:curly, :promote_eltype_op, :T), :op, (:(::), (:curly, :AbstractArray, :T))), (:block,
        (:line, 1674, :none),
        (:block,
          (:macrocall, Symbol("@_pure_meta")),
          (:call, :promote_op, :op, :T)
        )
      )),
    (:line, 1675, :none),
    (:(=), (:call, (:curly, :promote_eltype_op, :T), :op, (:(::), (:curly, :AbstractArray, :T)), :A), (:block,
        (:line, 1675, :none),
        (:block,
          (:macrocall, Symbol("@_pure_meta")),
          (:call, :promote_op, :op, :T, (:call, :eltype, :A))
        )
      )),
    (:line, 1676, :none),
    (:(=), (:call, (:curly, :promote_eltype_op, :T), :op, :A, (:(::), (:curly, :AbstractArray, :T))), (:block,
        (:line, 1676, :none),
        (:block,
          (:macrocall, Symbol("@_pure_meta")),
          (:call, :promote_op, :op, (:call, :eltype, :A), :T)
        )
      )),
    (:line, 1677, :none),
    (:(=), (:call, (:curly, :promote_eltype_op, :R, :S), :op, (:(::), (:curly, :AbstractArray, :R)), (:(::), (:curly, :AbstractArray, :S))), (:block,
        (:line, 1677, :none),
        (:block,
          (:macrocall, Symbol("@_pure_meta")),
          (:call, :promote_op, :op, :R, :S)
        )
      )),
    (:line, 1678, :none),
    (:(=), (:call, :promote_eltype_op, :op, :A, :B), (:block,
        (:line, 1678, :none),
        (:block,
          (:macrocall, Symbol("@_pure_meta")),
          (:call, :promote_op, :op, (:call, :eltype, :A), (:call, :eltype, :B))
        )
      )),
    (:line, 1679, :none),
    (:(=), (:call, :promote_eltype_op, :op, :A, :B, :C, (:..., :D)), (:block,
        (:line, 1679, :none),
        (:block,
          (:macrocall, Symbol("@_pure_meta")),
          (:call, :promote_eltype_op, :op, (:call, :promote_eltype_op, :op, :A, :B), :C, (:..., :D))
        )
      )),
    (:line, 1682, :none),
    (:(=), (:call, (:curly, :map!, :F), (:(::), :f, :F), (:(::), :A, :AbstractArray)), (:block,
        (:line, 1682, :none),
        (:call, :map!, :f, :A, :A)
      )),
    (:line, 1683, :none),
    (:function, (:call, (:curly, :map!, :F), (:(::), :f, :F), (:(::), :dest, :AbstractArray), (:(::), :A, :AbstractArray)), (:block,
        (:line, 1684, :none),
        (:for, (:(=), (:tuple, :i, :j), (:call, :zip, (:call, :eachindex, :dest), (:call, :eachindex, :A))), (:block,
            (:line, 1685, :none),
            (:(=), (:ref, :dest, :i), (:call, :f, (:ref, :A, :j)))
          )),
        (:line, 1687, :none),
        (:return, :dest)
      )),
    (:line, 1691, :none),
    (:(=), (:call, :map, :f, (:(::), :A, (:curly, :Union, :AbstractArray, :AbstractSet, :Associative))), (:block,
        (:line, 1691, :none),
        (:call, :collect_similar, :A, (:call, :Generator, :f, :A))
      )),
    (:line, 1694, :none),
    (:(=), (:call, :map, :f, :A), (:block,
        (:line, 1694, :none),
        (:call, :collect, (:call, :Generator, :f, :A))
      )),
    (:line, 1697, :none),
    (:function, (:call, (:curly, :map!, :F), (:(::), :f, :F), (:(::), :dest, :AbstractArray), (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1698, :none),
        (:for, (:(=), (:tuple, :i, :j, :k), (:call, :zip, (:call, :eachindex, :dest), (:call, :eachindex, :A), (:call, :eachindex, :B))), (:block,
            (:line, 1699, :none),
            (:(=), (:ref, :dest, :i), (:call, :f, (:ref, :A, :j), (:ref, :B, :k)))
          )),
        (:line, 1701, :none),
        (:return, :dest)
      )),
    (:line, 1706, :none),
    (:(=), (:call, :ith_all, :i, (:(::), (:curly, :Tuple))), (:block,
        (:line, 1706, :none),
        (:tuple,)
      )),
    (:line, 1707, :none),
    (:(=), (:call, :ith_all, :i, :as), (:block,
        (:line, 1707, :none),
        (:tuple, (:ref, (:ref, :as, 1), :i), (:..., (:call, :ith_all, :i, (:call, :tail, :as))))
      )),
    (:line, 1709, :none),
    (:function, (:call, (:curly, :map_n!, :F), (:(::), :f, :F), (:(::), :dest, :AbstractArray), :As), (:block,
        (:line, 1710, :none),
        (:for, (:(=), :i, (:call, :linearindices, (:ref, :As, 1))), (:block,
            (:line, 1711, :none),
            (:(=), (:ref, :dest, :i), (:call, :f, (:..., (:call, :ith_all, :i, :As))))
          )),
        (:line, 1713, :none),
        (:return, :dest)
      )),
    (:line, 1716, :none),
    (:(=), (:call, (:curly, :map!, :F), (:(::), :f, :F), (:(::), :dest, :AbstractArray), (:..., (:(::), :As, :AbstractArray))), (:block,
        (:line, 1716, :none),
        (:call, :map_n!, :f, :dest, :As)
      )),
    (:line, 1718, :none),
    (:(=), (:call, :map, :f), (:block,
        (:line, 1718, :none),
        (:call, :f)
      )),
    (:line, 1719, :none),
    (:(=), (:call, :map, :f, (:..., :iters)), (:block,
        (:line, 1719, :none),
        (:call, :collect, (:call, :Generator, :f, (:..., :iters)))
      )),
    (:line, 1723, :none),
    (:(=), (:call, :push!, :A, :a, :b), (:block,
        (:line, 1723, :none),
        (:call, :push!, (:call, :push!, :A, :a), :b)
      )),
    (:line, 1724, :none),
    (:(=), (:call, :push!, :A, :a, :b, (:..., :c)), (:block,
        (:line, 1724, :none),
        (:call, :push!, (:call, :push!, :A, :a, :b), (:..., :c))
      )),
    (:line, 1725, :none),
    (:(=), (:call, :unshift!, :A, :a, :b), (:block,
        (:line, 1725, :none),
        (:call, :unshift!, (:call, :unshift!, :A, :b), :a)
      )),
    (:line, 1726, :none),
    (:(=), (:call, :unshift!, :A, :a, :b, (:..., :c)), (:block,
        (:line, 1726, :none),
        (:call, :unshift!, (:call, :unshift!, :A, (:..., :c)), :a, :b)
      )),
    (:line, 1730, :none),
    (:const, (:(=), :hashaa_seed, (:if, (:call, :(===), :UInt, :UInt64), 0x7f53e68ceb575e76, 0xeb575e76))),
    (:line, 1731, :none),
    (:const, (:(=), :hashrle_seed, (:if, (:call, :(==), :UInt, :UInt64), 0x2aab8909bfea414c, 0xbfea414c))),
    (:line, 1732, :none),
    (:function, (:call, :hash, (:(::), :a, :AbstractArray), (:(::), :h, :UInt)), (:block,
        (:line, 1733, :none),
        (:+=, :h, :hashaa_seed),
        (:line, 1734, :none),
        (:+=, :h, (:call, :hash, (:call, :size, :a))),
        (:line, 1736, :none),
        (:(=), :state, (:call, :start, :a)),
        (:line, 1737, :none),
        (:&&, (:call, :done, :a, :state), (:return, :h)),
        (:line, 1738, :none),
        (:(=), (:tuple, :x2, :state), (:call, :next, :a, :state)),
        (:line, 1739, :none),
        (:&&, (:call, :done, :a, :state), (:return, (:call, :hash, :x2, :h))),
        (:line, 1741, :none),
        (:(=), :x1, :x2),
        (:line, 1742, :none),
        (:while, (:call, :!, (:call, :done, :a, :state)), (:block,
            (:line, 1743, :none),
            (:(=), :x1, :x2),
            (:line, 1744, :none),
            (:(=), (:tuple, :x2, :state), (:call, :next, :a, :state)),
            (:line, 1745, :none),
            (:if, (:call, :isequal, :x2, :x1), (:block,
                (:line, 1748, :none),
                (:(=), :runlength, 2),
                (:line, 1749, :none),
                (:while, (:call, :!, (:call, :done, :a, :state)), (:block,
                    (:line, 1750, :none),
                    (:(=), (:tuple, :x2, :state), (:call, :next, :a, :state)),
                    (:line, 1751, :none),
                    (:||, (:call, :isequal, :x1, :x2), (:break,)),
                    (:line, 1752, :none),
                    (:+=, :runlength, 1)
                  )),
                (:line, 1754, :none),
                (:+=, :h, :hashrle_seed),
                (:line, 1755, :none),
                (:(=), :h, (:call, :hash, :runlength, :h))
              )),
            (:line, 1757, :none),
            (:(=), :h, (:call, :hash, :x1, :h))
          )),
        (:line, 1759, :none),
        (:&&, (:call, :!, (:call, :isequal, :x2, :x1)), (:(=), :h, (:call, :hash, :x2, :h))),
        (:line, 1760, :none),
        (:return, :h)
      ))
  ))