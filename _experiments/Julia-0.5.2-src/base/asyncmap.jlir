(:quote, (:block,
    (:line, 4, :none),
    "    AsyncCollector(f, results, c...; ntasks=0) -> iterator\n\nApply `f` to each element of `c` using at most `ntasks` asynchronous\ntasks.\nIf `ntasks` is unspecified, uses `max(100, nworkers())` tasks.\nFor multiple collection arguments, apply `f` elementwise.\nOutput is collected into `results`.\n\nNote: `next(::AsyncCollector, state) -> (nothing, state)`\n\nNote: `for task in AsyncCollector(f, results, c...) end` is equivalent to\n`map!(f, results, c...)`.\n",
    (:line, 18, :none),
    (:type, true, :AsyncCollector, (:block,
        (:line, 19, :none),
        :f,
        (:line, 20, :none),
        :results,
        (:line, 21, :none),
        (:(::), :enumerator, :Enumerate),
        (:line, 22, :none),
        (:(::), :max_tasks, :Function),
        (:line, 23, :none),
        (:(::), :task_chnl, (:curly, :Channel, (:curly, :Tuple, :Int, :Any))),
        (:line, 25, :none),
        (:(=), (:call, :AsyncCollector, :f, :r, (:(::), :en, :Enumerate), (:(::), :mt, :Function), (:(::), :c, :Channel)), (:block,
            (:line, 25, :none),
            (:call, :new, :f, :r, :en, :mt, :c)
          ))
      )),
    (:line, 28, :none),
    (:function, (:call, :AsyncCollector, (:parameters, (:kw, :ntasks, 0)), :f, :results, (:..., :c)), (:block,
        (:line, 29, :none),
        (:if, (:call, :(==), :ntasks, 0), (:block,
            (:line, 30, :none),
            (:(=), :ntasks, (:call, :max, (:call, :nworkers), 100)),
            (:line, 31, :none),
            (:(=), :max_tasks, (:->, (:tuple,), (:block,
                  (:line, 31, :none),
                  :ntasks
                )))
          ), (:block,
            (:line, 32, :none),
            (:if, (:call, :isa, :ntasks, :Integer), (:block,
                (:line, 33, :none),
                (:(=), :max_tasks, (:->, (:tuple,), (:block,
                      (:line, 33, :none),
                      :ntasks
                    )))
              ), (:block,
                (:line, 34, :none),
                (:if, (:call, :isa, :ntasks, :Function), (:block,
                    (:line, 35, :none),
                    (:(=), :max_tasks, :ntasks)
                  ), (:block,
                    (:line, 37, :none),
                    (:call, :throw, (:call, :ArgumentError, "ntasks must be an Integer or a zero-arg function returning the maximum number of tasks allowed."))
                  ))
              ))
          )),
        (:line, 39, :none),
        (:call, :AsyncCollector, :f, :results, (:call, :enumerate, (:call, :zip, (:..., :c))), :max_tasks, (:call, (:curly, :Channel, (:curly, :Tuple, :Int, :Any)), (:call, :typemax, :Int)))
      )),
    (:line, 42, :none),
    (:type, true, :AsyncCollectorState, (:block,
        (:line, 43, :none),
        :enum_state,
        (:line, 44, :none),
        (:(::), :active_count, :Int),
        (:line, 45, :none),
        (:(::), :item_done, :Condition),
        (:line, 46, :none),
        (:(::), :done, :Bool),
        (:line, 47, :none),
        (:(::), :in_error, :Bool),
        (:line, 48, :none),
        (:(::), :nfree, :Int)
      )),
    (:line, 52, :none),
    (:(=), (:call, :isbusy, (:(::), :itr, :AsyncCollector), (:(::), :state, :AsyncCollectorState)), (:block,
        (:line, 52, :none),
        (:call, :(==), (:., :state, (:quote, #QuoteNode
              :nfree
            )), 0)
      )),
    (:line, 55, :none),
    (:(=), (:call, :wait, (:(::), :state, :AsyncCollectorState)), (:block,
        (:line, 55, :none),
        (:call, :wait, (:., :state, (:quote, #QuoteNode
              :item_done
            )))
      )),
    (:line, 57, :none),
    (:function, (:call, :start_collector_task, (:(::), :itr, :AsyncCollector), (:(::), :state, :AsyncCollectorState)), (:block,
        (:line, 58, :none),
        (:(=), :t, (:macrocall, Symbol("@async"), (:block,
              (:line, 59, :none),
              (:try, (:block,
                  (:line, 60, :none),
                  (:for, (:(=), (:tuple, :i, :args), (:., :itr, (:quote, #QuoteNode
                          :task_chnl
                        ))), (:block,
                      (:line, 61, :none),
                      (:-=, (:., :state, (:quote, #QuoteNode
                            :nfree
                          )), 1),
                      (:line, 63, :none),
                      (:(=), (:ref, (:., :itr, (:quote, #QuoteNode
                              :results
                            )), :i), (:call, (:., :itr, (:quote, #QuoteNode
                              :f
                            )), (:..., :args))),
                      (:line, 64, :none),
                      (:call, :notify, (:., :state, (:quote, #QuoteNode
                            :item_done
                          )), :nothing),
                      (:line, 66, :none),
                      (:+=, (:., :state, (:quote, #QuoteNode
                            :nfree
                          )), 1)
                    ))
                ), :e, (:block,
                  (:line, 71, :none),
                  (:(=), (:., :state, (:quote, #QuoteNode
                        :in_error
                      )), true),
                  (:line, 72, :none),
                  (:call, :clear_collector_channel, :itr),
                  (:line, 73, :none),
                  (:call, :notify, (:., :state, (:quote, #QuoteNode
                        :item_done
                      )), :nothing),
                  (:line, 75, :none),
                  (:call, :rethrow, :e)
                ))
            ))),
        (:line, 79, :none),
        (:+=, (:., :state, (:quote, #QuoteNode
              :active_count
            )), 1),
        (:line, 80, :none),
        :t
      )),
    (:line, 83, :none),
    (:function, (:call, :clear_collector_channel, (:(::), :itr, :AsyncCollector)), (:block,
        (:line, 84, :none),
        (:try, (:block,
            (:line, 86, :none),
            (:while, (:call, :isready, (:., :itr, (:quote, #QuoteNode
                    :task_chnl
                  ))), (:block,
                (:line, 87, :none),
                (:call, :take!, (:., :itr, (:quote, #QuoteNode
                      :task_chnl
                    )))
              )),
            (:line, 89, :none),
            (:call, :close, (:., :itr, (:quote, #QuoteNode
                  :task_chnl
                )))
          ), false, (:block,)),
        (:line, 92, :none),
        :nothing
      )),
    (:line, 96, :none),
    (:function, (:call, :start, (:(::), :itr, :AsyncCollector)), (:block,
        (:line, 97, :none),
        (:call, :sync_begin),
        (:line, 99, :none),
        (:(=), :state, (:call, :AsyncCollectorState, (:call, :start, (:., :itr, (:quote, #QuoteNode
                  :enumerator
                ))), 0, (:call, :Condition), false, false, 0)),
        (:line, 101, :none),
        (:for, (:(=), :_, (:(:), 1, (:call, (:., :itr, (:quote, #QuoteNode
                    :max_tasks
                  ))))), (:block,
            (:line, 102, :none),
            (:call, :start_collector_task, :itr, :state),
            (:line, 103, :none),
            (:+=, (:., :state, (:quote, #QuoteNode
                  :nfree
                )), 1)
          )),
        (:line, 105, :none),
        :state
      )),
    (:line, 109, :none),
    (:function, (:call, :done, (:(::), :itr, :AsyncCollector), (:(::), :state, :AsyncCollectorState)), (:block,
        (:line, 110, :none),
        (:if, (:., :state, (:quote, #QuoteNode
              :in_error
            )), (:block,
            (:line, 111, :none),
            (:macrocall, Symbol("@assert"), (:call, :!, (:call, :isopen, (:., :itr, (:quote, #QuoteNode
                      :task_chnl
                    ))))),
            (:line, 113, :none),
            (:call, :sync_end),
            (:line, 118, :none),
            (:macrocall, Symbol("@assert"), false, "Error should have been captured and thrown previously.")
          )),
        (:line, 121, :none),
        (:if, (:&&, (:call, :!, (:., :state, (:quote, #QuoteNode
                  :done
                ))), (:call, :done, (:., :itr, (:quote, #QuoteNode
                  :enumerator
                )), (:., :state, (:quote, #QuoteNode
                  :enum_state
                )))), (:block,
            (:line, 122, :none),
            (:(=), (:., :state, (:quote, #QuoteNode
                  :done
                )), true),
            (:line, 123, :none),
            (:call, :close, (:., :itr, (:quote, #QuoteNode
                  :task_chnl
                ))),
            (:line, 124, :none),
            (:call, :sync_end)
          )),
        (:line, 126, :none),
        (:return, (:., :state, (:quote, #QuoteNode
              :done
            )))
      )),
    (:line, 129, :none),
    (:function, (:call, :next, (:(::), :itr, :AsyncCollector), (:(::), :state, :AsyncCollectorState)), (:block,
        (:line, 132, :none),
        (:if, (:call, :<, (:., :state, (:quote, #QuoteNode
                :active_count
              )), (:call, (:., :itr, (:quote, #QuoteNode
                  :max_tasks
                )))), (:block,
            (:line, 133, :none),
            (:call, :start_collector_task, :itr, :state)
          )),
        (:line, 136, :none),
        (:while, (:call, :isbusy, :itr, :state), (:block,
            (:line, 137, :none),
            (:call, :wait, :state),
            (:line, 138, :none),
            (:if, (:., :state, (:quote, #QuoteNode
                  :in_error
                )), (:block,
                (:line, 140, :none),
                (:return, (:tuple, :nothing, :state))
              ))
          )),
        (:line, 145, :none),
        (:(=), (:tuple, (:tuple, :i, :args), (:., :state, (:quote, #QuoteNode
                :enum_state
              ))), (:call, :next, (:., :itr, (:quote, #QuoteNode
                :enumerator
              )), (:., :state, (:quote, #QuoteNode
                :enum_state
              )))),
        (:line, 146, :none),
        (:call, :put!, (:., :itr, (:quote, #QuoteNode
              :task_chnl
            )), (:tuple, :i, :args)),
        (:line, 148, :none),
        (:return, (:tuple, :nothing, :state))
      )),
    (:line, 151, :none),
    "    AsyncGenerator(f, c...; ntasks=0) -> iterator\n\nApply `f` to each element of `c` using at most `ntasks` asynchronous tasks.\nIf `ntasks` is unspecified, uses `max(100, nworkers())` tasks.\nFor multiple collection arguments, apply f elementwise.\nResults are returned by the iterator as they become available.\nNote: `collect(AsyncGenerator(f, c...; ntasks=1))` is equivalent to\n`map(f, c...)`.\n",
    (:line, 161, :none),
    (:type, true, :AsyncGenerator, (:block,
        (:line, 162, :none),
        (:(::), :collector, :AsyncCollector)
      )),
    (:line, 165, :none),
    (:function, (:call, :AsyncGenerator, (:parameters, (:kw, :ntasks, 0)), :f, (:..., :c)), (:block,
        (:line, 166, :none),
        (:call, :AsyncGenerator, (:call, :AsyncCollector, (:parameters, (:kw, :ntasks, :ntasks)), :f, (:call, (:curly, :Dict, :Int, :Any)), (:..., :c)))
      )),
    (:line, 170, :none),
    (:type, true, :AsyncGeneratorState, (:block,
        (:line, 171, :none),
        (:(::), :i, :Int),
        (:line, 172, :none),
        (:(::), :async_state, :AsyncCollectorState)
      )),
    (:line, 176, :none),
    (:(=), (:call, :start, (:(::), :itr, :AsyncGenerator)), (:block,
        (:line, 176, :none),
        (:call, :AsyncGeneratorState, 0, (:call, :start, (:., :itr, (:quote, #QuoteNode
                :collector
              ))))
      )),
    (:line, 179, :none),
    (:function, (:call, :done, (:(::), :itr, :AsyncGenerator), (:(::), :state, :AsyncGeneratorState)), (:block,
        (:line, 180, :none),
        (:&&, (:call, :done, (:., :itr, (:quote, #QuoteNode
                :collector
              )), (:., :state, (:quote, #QuoteNode
                :async_state
              ))), (:call, :isempty, (:., (:., :itr, (:quote, #QuoteNode
                  :collector
                )), (:quote, #QuoteNode
                :results
              ))))
      )),
    (:line, 184, :none),
    (:function, (:call, :pump_source, (:(::), :itr, :AsyncGenerator), (:(::), :state, :AsyncGeneratorState)), (:block,
        (:line, 185, :none),
        (:if, (:&&, (:call, :!, (:call, :isbusy, (:., :itr, (:quote, #QuoteNode
                    :collector
                  )), (:., :state, (:quote, #QuoteNode
                    :async_state
                  )))), (:call, :!, (:call, :done, (:., :itr, (:quote, #QuoteNode
                    :collector
                  )), (:., :state, (:quote, #QuoteNode
                    :async_state
                  ))))), (:block,
            (:line, 187, :none),
            (:(=), (:tuple, :ignored, (:., :state, (:quote, #QuoteNode
                    :async_state
                  ))), (:call, :next, (:., :itr, (:quote, #QuoteNode
                    :collector
                  )), (:., :state, (:quote, #QuoteNode
                    :async_state
                  )))),
            (:line, 188, :none),
            (:return, true)
          ), (:block,
            (:line, 190, :none),
            (:return, false)
          ))
      )),
    (:line, 194, :none),
    (:function, (:call, :next, (:(::), :itr, :AsyncGenerator), (:(::), :state, :AsyncGeneratorState)), (:block,
        (:line, 195, :none),
        (:+=, (:., :state, (:quote, #QuoteNode
              :i
            )), 1),
        (:line, 197, :none),
        (:(=), :results, (:., (:., :itr, (:quote, #QuoteNode
                :collector
              )), (:quote, #QuoteNode
              :results
            ))),
        (:line, 198, :none),
        (:while, (:call, :!, (:call, :haskey, :results, (:., :state, (:quote, #QuoteNode
                  :i
                )))), (:block,
            (:line, 201, :none),
            (:if, (:&&, (:call, :!, (:call, :pump_source, :itr, :state)), (:call, :!, (:call, :haskey, :results, (:., :state, (:quote, #QuoteNode
                        :i
                      ))))), (:block,
                (:line, 202, :none),
                (:call, :wait, (:., :state, (:quote, #QuoteNode
                      :async_state
                    )))
              ))
          )),
        (:line, 205, :none),
        (:(=), :r, (:ref, :results, (:., :state, (:quote, #QuoteNode
                :i
              )))),
        (:line, 206, :none),
        (:call, :delete!, :results, (:., :state, (:quote, #QuoteNode
              :i
            ))),
        (:line, 208, :none),
        (:return, (:tuple, :r, :state))
      )),
    (:line, 211, :none),
    (:(=), (:call, :iteratorsize, (:(::), (:curly, :Type, :AsyncGenerator))), (:block,
        (:line, 211, :none),
        (:call, :SizeUnknown)
      )),
    (:line, 214, :none),
    "    asyncmap(f, c...) -> collection\n\nTransform collection `c` by applying `@async f` to each element.\n\nFor multiple collection arguments, apply f elementwise.\n",
    (:line, 221, :none),
    (:(=), (:call, :asyncmap, :f, (:..., :c)), (:block,
        (:line, 221, :none),
        (:call, :collect, (:call, :AsyncGenerator, :f, (:..., :c)))
      )),
    (:line, 224, :none),
    "    asyncmap!(f, c)\n\nIn-place version of `asyncmap()`.\n",
    (:line, 229, :none),
    (:(=), (:call, :asyncmap!, :f, :c), (:block,
        (:line, 229, :none),
        (:block,
          (:for, (:(=), :x, (:call, :AsyncCollector, :f, :c, :c)), (:block,
              (:line, 229, :none)
            )),
          :c
        )
      )),
    (:line, 232, :none),
    "    asyncmap!(f, results, c...)\n\nLike `asyncmap()`, but stores output in `results` rather returning a collection.\n",
    (:line, 237, :none),
    (:(=), (:call, :asyncmap!, :f, :r, :c1, (:..., :c)), (:block,
        (:line, 237, :none),
        (:block,
          (:for, (:(=), :x, (:call, :AsyncCollector, :f, :r, :c1, (:..., :c))), (:block,
              (:line, 237, :none)
            )),
          :r
        )
      ))
  ))