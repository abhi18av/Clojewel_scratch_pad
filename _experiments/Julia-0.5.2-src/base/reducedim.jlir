(:quote, (:block,
    (:line, 5, :none),
    (:function, (:call, :reduced_dims, (:(::), :a, :AbstractArray), :region), (:block,
        (:line, 6, :none),
        (:call, :to_shape, (:call, :reduced_indices, :a, :region))
      )),
    (:line, 9, :none),
    (:function, (:call, :reduced_dims0, (:(::), :a, :AbstractArray), :region), (:block,
        (:line, 10, :none),
        (:call, :to_shape, (:call, :reduced_indices0, :a, :region))
      )),
    (:line, 14, :none),
    (:(=), (:call, :reduced_indices, (:(::), :a, :AbstractArray), :region), (:block,
        (:line, 14, :none),
        (:call, :reduced_indices, (:call, :indices, :a), :region)
      )),
    (:line, 17, :none),
    (:(=), (:call, :reduced_indices0, (:(::), :a, :AbstractArray), :region), (:block,
        (:line, 17, :none),
        (:call, :reduced_indices0, (:call, :indices, :a), :region)
      )),
    (:line, 19, :none),
    (:function, (:call, (:curly, :reduced_indices, :N), (:(::), :inds, (:curly, :Indices, :N)), (:(::), :d, :Int), (:(::), :rd, :AbstractUnitRange)), (:block,
        (:line, 20, :none),
        (:&&, (:call, :<, :d, 1), (:call, :throw, (:call, :ArgumentError, (:string, "dimension must be ≥ 1, got ", :d)))),
        (:line, 21, :none),
        (:if, (:call, :(==), :d, 1), (:block,
            (:line, 22, :none),
            (:return, (:tuple, (:call, :oftype, (:ref, :inds, 1), :rd), (:..., (:call, :tail, :inds))))
          ), (:block,
            (:line, 23, :none),
            (:if, (:comparison, 1, :<, :d, :(<=), :N), (:block,
                (:line, 24, :none),
                (:return, (:(::), (:call, :tuple, (:..., (:ref, :inds, (:(:), 1, (:call, :-, :d, 1)))), (:call, :oftype, (:ref, :inds, :d), :rd), (:..., (:ref, :inds, (:(:), (:call, :+, :d, 1), :N)))), (:call, :typeof, :inds)))
              ), (:block,
                (:line, 26, :none),
                (:return, :inds)
              ))
          ))
      )),
    (:line, 29, :none),
    (:(=), (:call, (:curly, :reduced_indices, :N), (:(::), :inds, (:curly, :Indices, :N)), (:(::), :d, :Int)), (:block,
        (:line, 29, :none),
        (:call, :reduced_indices, :inds, :d, (:call, :OneTo, 1))
      )),
    (:line, 31, :none),
    (:function, (:call, (:curly, :reduced_indices0, :N), (:(::), :inds, (:curly, :Indices, :N)), (:(::), :d, :Int)), (:block,
        (:line, 32, :none),
        (:&&, (:call, :<, :d, 1), (:call, :throw, (:call, :ArgumentError, (:string, "dimension must be ≥ 1, got ", :d)))),
        (:line, 33, :none),
        (:if, (:call, :(<=), :d, :N), (:block,
            (:line, 34, :none),
            (:return, (:call, :reduced_indices, :inds, :d, (:if, (:call, :(==), (:ref, :inds, :d), (:call, :OneTo, 0)), (:call, :OneTo, 0), (:call, :OneTo, 1))))
          ), (:block,
            (:line, 36, :none),
            (:return, :inds)
          ))
      )),
    (:line, 40, :none),
    (:function, (:call, (:curly, :reduced_indices, :N), (:(::), :inds, (:curly, :Indices, :N)), :region), (:block,
        (:line, 41, :none),
        (:(=), :rinds, (:vect, (:..., :inds))),
        (:line, 42, :none),
        (:for, (:(=), :i, :region), (:block,
            (:line, 43, :none),
            (:||, (:call, :isa, :i, :Integer), (:call, :throw, (:call, :ArgumentError, "reduced dimension(s) must be integers"))),
            (:line, 44, :none),
            (:(=), :d, (:call, :Int, :i)),
            (:line, 45, :none),
            (:if, (:call, :<, :d, 1), (:block,
                (:line, 46, :none),
                (:call, :throw, (:call, :ArgumentError, (:string, "region dimension(s) must be ≥ 1, got ", :d)))
              ), (:block,
                (:line, 47, :none),
                (:if, (:call, :(<=), :d, :N), (:block,
                    (:line, 48, :none),
                    (:(=), (:ref, :rinds, :d), (:call, :oftype, (:ref, :rinds, :d), (:call, :OneTo, 1)))
                  ))
              ))
          )),
        (:line, 51, :none),
        (:(::), (:call, :tuple, (:..., :rinds)), (:call, :typeof, :inds))
      )),
    (:line, 54, :none),
    (:function, (:call, (:curly, :reduced_indices0, :N), (:(::), :inds, (:curly, :Indices, :N)), :region), (:block,
        (:line, 55, :none),
        (:(=), :rinds, (:vect, (:..., :inds))),
        (:line, 56, :none),
        (:for, (:(=), :i, :region), (:block,
            (:line, 57, :none),
            (:||, (:call, :isa, :i, :Integer), (:call, :throw, (:call, :ArgumentError, "reduced dimension(s) must be integers"))),
            (:line, 58, :none),
            (:(=), :d, (:call, :Int, :i)),
            (:line, 59, :none),
            (:if, (:call, :<, :d, 1), (:block,
                (:line, 60, :none),
                (:call, :throw, (:call, :ArgumentError, (:string, "region dimension(s) must be ≥ 1, got ", :d)))
              ), (:block,
                (:line, 61, :none),
                (:if, (:call, :(<=), :d, :N), (:block,
                    (:line, 62, :none),
                    (:(=), (:ref, :rinds, :d), (:call, :oftype, (:ref, :rinds, :d), (:if, (:call, :(==), (:ref, :rinds, :d), (:call, :OneTo, 0)), (:call, :OneTo, 0), (:call, :OneTo, 1))))
                  ))
              ))
          )),
        (:line, 65, :none),
        (:(::), (:call, :tuple, (:..., :rinds)), (:call, :typeof, :inds))
      )),
    (:line, 69, :none),
    (:function, (:call, :reduced_dims, (:(::), (:curly, :Tuple)), (:(::), :d, :Int)), (:block,
        (:line, 70, :none),
        (:&&, (:call, :<, :d, 1), (:call, :throw, (:call, :ArgumentError, (:string, "dimension must be ≥ 1, got ", :d)))),
        (:line, 71, :none),
        (:tuple,)
      )),
    (:line, 73, :none),
    (:(=), (:call, :reduced_dims, (:(::), (:curly, :Tuple)), :region), (:block,
        (:line, 73, :none),
        (:tuple,)
      )),
    (:line, 74, :none),
    (:function, (:call, :reduced_dims, (:(::), :dims, :Dims), :region), (:block,
        (:line, 75, :none),
        (:call, :map, :last, (:call, :reduced_indices, (:call, :map, :OneTo, :dims), :region))
      )),
    (:line, 78, :none),
    (:function, (:call, :reduced_dims0, (:(::), (:curly, :Tuple)), (:(::), :d, :Int)), (:block,
        (:line, 79, :none),
        (:&&, (:call, :<, :d, 1), (:call, :throw, (:call, :ArgumentError, (:string, "dimension must be ≥ 1, got ", :d)))),
        (:line, 80, :none),
        (:tuple,)
      )),
    (:line, 82, :none),
    (:(=), (:call, :reduced_dims0, (:(::), (:curly, :Tuple)), :region), (:block,
        (:line, 82, :none),
        (:tuple,)
      )),
    (:line, 83, :none),
    (:function, (:call, :reduced_dims0, (:(::), :dims, :Dims), :region), (:block,
        (:line, 84, :none),
        (:call, :map, :last, (:call, :reduced_indices0, (:call, :map, :OneTo, :dims), :region))
      )),
    (:line, 92, :none),
    (:for, (:(=), (:tuple, :Op, :initfun), (:tuple, (:tuple, (:quote, (:call, :typeof, :+)), (:quote, #QuoteNode
              :zero
            )), (:tuple, (:quote, (:call, :typeof, :*)), (:quote, #QuoteNode
              :one
            )), (:tuple, (:quote, (:call, :typeof, :scalarmax)), (:quote, #QuoteNode
              :typemin
            )), (:tuple, (:quote, (:call, :typeof, :scalarmin)), (:quote, #QuoteNode
              :typemax
            )), (:tuple, (:quote, (:call, :typeof, :max)), (:quote, #QuoteNode
              :typemin
            )), (:tuple, (:quote, (:call, :typeof, :min)), (:quote, #QuoteNode
              :typemax
            )))), (:block,
        (:line, 93, :none),
        (:macrocall, Symbol("@eval"), (:(=), (:call, (:curly, :initarray!, :T), (:(::), :a, (:curly, :AbstractArray, :T)), (:(::), (:$, :Op)), (:(::), :init, :Bool)), (:block,
              (:line, 93, :none),
              (:block,
                (:&&, :init, (:call, :fill!, :a, (:call, (:$, :initfun), :T))),
                :a
              )
            )))
      )),
    (:line, 96, :none),
    (:for, (:(=), (:tuple, :Op, :initval), (:tuple, (:tuple, (:quote, (:call, :typeof, :&)), true), (:tuple, (:quote, (:call, :typeof, :|)), false))), (:block,
        (:line, 97, :none),
        (:macrocall, Symbol("@eval"), (:(=), (:call, :initarray!, (:(::), :a, :AbstractArray), (:(::), (:$, :Op)), (:(::), :init, :Bool)), (:block,
              (:line, 97, :none),
              (:block,
                (:&&, :init, (:call, :fill!, :a, (:$, :initval))),
                :a
              )
            )))
      )),
    (:line, 100, :none),
    (:(=), (:call, (:curly, :reducedim_initarray, :R), (:(::), :A, :AbstractArray), :region, :v0, (:(::), (:curly, :Type, :R))), (:block,
        (:line, 100, :none),
        (:call, :fill!, (:call, :similar, :A, :R, (:call, :reduced_indices, :A, :region)), :v0)
      )),
    (:line, 101, :none),
    (:(=), (:call, (:curly, :reducedim_initarray, :T), (:(::), :A, :AbstractArray), :region, (:(::), :v0, :T)), (:block,
        (:line, 101, :none),
        (:call, :reducedim_initarray, :A, :region, :v0, :T)
      )),
    (:line, 103, :none),
    (:(=), (:call, (:curly, :reducedim_initarray0, :R), (:(::), :A, :AbstractArray), :region, :v0, (:(::), (:curly, :Type, :R))), (:block,
        (:line, 103, :none),
        (:call, :fill!, (:call, :similar, :A, :R, (:call, :reduced_indices0, :A, :region)), :v0)
      )),
    (:line, 104, :none),
    (:(=), (:call, (:curly, :reducedim_initarray0, :T), (:(::), :A, :AbstractArray), :region, (:(::), :v0, :T)), (:block,
        (:line, 104, :none),
        (:call, :reducedim_initarray0, :A, :region, :v0, :T)
      )),
    (:line, 110, :none),
    (:(=), (:call, :promote_union, (:(::), :T, :Union)), (:block,
        (:line, 110, :none),
        (:call, :promote_type, (:..., (:., :T, (:quote, #QuoteNode
                :types
              ))))
      )),
    (:line, 111, :none),
    (:(=), (:call, :promote_union, :T), (:block,
        (:line, 111, :none),
        :T
      )),
    (:line, 113, :none),
    (:function, (:call, (:curly, :reducedim_init, :S), :f, (:(::), :op, (:call, :typeof, :+)), (:(::), :A, (:curly, :AbstractArray, :S)), :region), (:block,
        (:line, 114, :none),
        (:call, :_reducedim_init, :f, :op, :zero, :sum, :A, :region)
      )),
    (:line, 116, :none),
    (:function, (:call, (:curly, :reducedim_init, :S), :f, (:(::), :op, (:call, :typeof, :*)), (:(::), :A, (:curly, :AbstractArray, :S)), :region), (:block,
        (:line, 117, :none),
        (:call, :_reducedim_init, :f, :op, :one, :prod, :A, :region)
      )),
    (:line, 119, :none),
    (:function, (:call, :_reducedim_init, :f, :op, :fv, :fop, :A, :region), (:block,
        (:line, 120, :none),
        (:(=), :T, (:call, :promote_union, (:call, :eltype, :A))),
        (:line, 121, :none),
        (:if, (:call, :method_exists, :zero, (:curly, :Tuple, (:curly, :Type, :T))), (:block,
            (:line, 122, :none),
            (:(=), :x, (:call, :f, (:call, :zero, :T))),
            (:line, 123, :none),
            (:(=), :z, (:call, :op, (:call, :fv, :x), (:call, :fv, :x))),
            (:line, 124, :none),
            (:(=), :Tr, (:if, (:&&, (:call, :(==), (:call, :typeof, :z), (:call, :typeof, :x)), (:call, :!, (:call, :isbits, :T))), :T, (:call, :typeof, :z)))
          ), (:block,
            (:line, 126, :none),
            (:(=), :z, (:call, :fv, (:call, :fop, :f, :A))),
            (:line, 127, :none),
            (:(=), :Tr, (:call, :typeof, :z))
          )),
        (:line, 129, :none),
        (:return, (:call, :reducedim_initarray, :A, :region, :z, :Tr))
      )),
    (:line, 132, :none),
    (:(=), (:call, (:curly, :reducedim_init, :T), :f, (:(::), :op, (:call, :typeof, :max)), (:(::), :A, (:curly, :AbstractArray, :T)), :region), (:block,
        (:line, 132, :none),
        (:call, :reducedim_init, :f, :scalarmax, :A, :region)
      )),
    (:line, 133, :none),
    (:(=), (:call, (:curly, :reducedim_init, :T), :f, (:(::), :op, (:call, :typeof, :min)), (:(::), :A, (:curly, :AbstractArray, :T)), :region), (:block,
        (:line, 133, :none),
        (:call, :reducedim_init, :f, :scalarmin, :A, :region)
      )),
    (:line, 134, :none),
    (:(=), (:call, (:curly, :reducedim_init, :T), (:(::), :f, (:curly, :Union, (:call, :typeof, :abs), (:call, :typeof, :abs2))), (:(::), :op, (:call, :typeof, :max)), (:(::), :A, (:curly, :AbstractArray, :T)), :region), (:block,
        (:line, 134, :none),
        (:call, :reducedim_init, :f, :scalarmax, :A, :region)
      )),
    (:line, 136, :none),
    (:(=), (:call, (:curly, :reducedim_init, :T), :f, (:(::), :op, (:call, :typeof, :scalarmax)), (:(::), :A, (:curly, :AbstractArray, :T)), :region), (:block,
        (:line, 136, :none),
        (:call, :reducedim_initarray0, :A, :region, (:call, :typemin, (:call, :f, (:call, :zero, :T))))
      )),
    (:line, 137, :none),
    (:(=), (:call, (:curly, :reducedim_init, :T), :f, (:(::), :op, (:call, :typeof, :scalarmin)), (:(::), :A, (:curly, :AbstractArray, :T)), :region), (:block,
        (:line, 137, :none),
        (:call, :reducedim_initarray0, :A, :region, (:call, :typemax, (:call, :f, (:call, :zero, :T))))
      )),
    (:line, 138, :none),
    (:(=), (:call, (:curly, :reducedim_init, :T), (:(::), :f, (:curly, :Union, (:call, :typeof, :abs), (:call, :typeof, :abs2))), (:(::), :op, (:call, :typeof, :scalarmax)), (:(::), :A, (:curly, :AbstractArray, :T)), :region), (:block,
        (:line, 138, :none),
        (:call, :reducedim_initarray, :A, :region, (:call, :zero, (:call, :f, (:call, :zero, :T))))
      )),
    (:line, 141, :none),
    (:(=), (:call, :reducedim_init, :f, (:(::), :op, (:call, :typeof, :&)), (:(::), :A, :AbstractArray), :region), (:block,
        (:line, 141, :none),
        (:call, :reducedim_initarray, :A, :region, true)
      )),
    (:line, 142, :none),
    (:(=), (:call, :reducedim_init, :f, (:(::), :op, (:call, :typeof, :|)), (:(::), :A, :AbstractArray), :region), (:block,
        (:line, 142, :none),
        (:call, :reducedim_initarray, :A, :region, false)
      )),
    (:line, 146, :none),
    (:for, (:(=), (:tuple, :IT, :RT), (:tuple, (:tuple, :CommonReduceResult, (:quote, (:call, :eltype, :A))), (:tuple, :SmallSigned, (:quote, #QuoteNode
              :Int
            )), (:tuple, :SmallUnsigned, (:quote, #QuoteNode
              :UInt
            )))), (:block,
        (:line, 147, :none),
        (:(=), :T, (:curly, :Union, (:..., (:comprehension, (:generator, (:curly, :AbstractArray, :t), (:(=), :t, (:., :IT, (:quote, #QuoteNode
                        :types
                      )))))), (:..., (:comprehension, (:generator, (:curly, :AbstractArray, (:curly, :Complex, :t)), (:(=), :t, (:., :IT, (:quote, #QuoteNode
                        :types
                      )))))))),
        (:line, 148, :none),
        (:macrocall, Symbol("@eval"), (:block,
            (:line, 149, :none),
            (:(=), (:call, :reducedim_init, (:(::), :f, (:call, :typeof, :identity)), (:(::), :op, (:call, :typeof, :+)), (:(::), :A, (:$, :T)), :region), (:block,
                (:line, 149, :none),
                (:call, :reducedim_initarray, :A, :region, (:call, :zero, (:$, :RT)))
              )),
            (:line, 151, :none),
            (:(=), (:call, :reducedim_init, (:(::), :f, (:call, :typeof, :identity)), (:(::), :op, (:call, :typeof, :*)), (:(::), :A, (:$, :T)), :region), (:block,
                (:line, 151, :none),
                (:call, :reducedim_initarray, :A, :region, (:call, :one, (:$, :RT)))
              )),
            (:line, 153, :none),
            (:(=), (:call, :reducedim_init, (:(::), :f, (:curly, :Union, (:call, :typeof, :abs), (:call, :typeof, :abs2))), (:(::), :op, (:call, :typeof, :+)), (:(::), :A, (:$, :T)), :region), (:block,
                (:line, 153, :none),
                (:call, :reducedim_initarray, :A, :region, (:call, :real, (:call, :zero, (:$, :RT))))
              )),
            (:line, 155, :none),
            (:(=), (:call, :reducedim_init, (:(::), :f, (:curly, :Union, (:call, :typeof, :abs), (:call, :typeof, :abs2))), (:(::), :op, (:call, :typeof, :*)), (:(::), :A, (:$, :T)), :region), (:block,
                (:line, 155, :none),
                (:call, :reducedim_initarray, :A, :region, (:call, :real, (:call, :one, (:$, :RT))))
              ))
          ))
      )),
    (:line, 159, :none),
    (:(=), (:call, :reducedim_init, (:(::), :f, (:curly, :Union, (:call, :typeof, :identity), (:call, :typeof, :abs), (:call, :typeof, :abs2))), (:(::), :op, (:call, :typeof, :+)), (:(::), :A, (:curly, :AbstractArray, :Bool)), :region), (:block,
        (:line, 159, :none),
        (:call, :reducedim_initarray, :A, :region, 0)
      )),
    (:line, 165, :none),
    (:(=), (:call, :has_fast_linear_indexing, (:(::), :a, :AbstractArray)), (:block,
        (:line, 165, :none),
        false
      )),
    (:line, 166, :none),
    (:(=), (:call, :has_fast_linear_indexing, (:(::), :a, :Array)), (:block,
        (:line, 166, :none),
        true
      )),
    (:line, 168, :none),
    (:function, (:call, :check_reducedims, :R, :A), (:block,
        (:line, 177, :none),
        (:||, (:call, :(<=), (:call, :ndims, :R), (:call, :ndims, :A)), (:call, :throw, (:call, :DimensionMismatch, (:string, "cannot reduce ", (:call, :ndims, :A), "-dimensional array to ", (:call, :ndims, :R), " dimensions")))),
        (:line, 178, :none),
        (:(=), :lsiz, 1),
        (:line, 179, :none),
        (:(=), :had_nonreduc, false),
        (:line, 180, :none),
        (:for, (:(=), :i, (:(:), 1, (:call, :ndims, :A))), (:block,
            (:line, 181, :none),
            (:(=), (:tuple, :Ri, :Ai), (:tuple, (:call, :indices, :R, :i), (:call, :indices, :A, :i))),
            (:line, 182, :none),
            (:(=), (:tuple, :sRi, :sAi), (:tuple, (:call, :length, :Ri), (:call, :length, :Ai))),
            (:line, 183, :none),
            (:if, (:call, :(==), :sRi, 1), (:block,
                (:line, 184, :none),
                (:if, (:call, :>, :sAi, 1), (:block,
                    (:line, 185, :none),
                    (:if, :had_nonreduc, (:block,
                        (:line, 186, :none),
                        (:(=), :lsiz, 0)
                      ), (:block,
                        (:line, 188, :none),
                        (:*=, :lsiz, :sAi)
                      ))
                  ))
              ), (:block,
                (:line, 192, :none),
                (:||, (:call, :(==), :Ri, :Ai), (:call, :throw, (:call, :DimensionMismatch, (:string, "reduction on array with indices ", (:call, :indices, :A), " with output with indices ", (:call, :indices, :R))))),
                (:line, 193, :none),
                (:(=), :had_nonreduc, true)
              ))
          )),
        (:line, 196, :none),
        (:return, :lsiz)
      )),
    (:line, 199, :none),
    (:function, (:call, (:curly, :_mapreducedim!, :T, :N), :f, :op, (:(::), :R, :AbstractArray), (:(::), :A, (:curly, :AbstractArray, :T, :N))), (:block,
        (:line, 200, :none),
        (:(=), :lsiz, (:call, :check_reducedims, :R, :A)),
        (:line, 201, :none),
        (:&&, (:call, :isempty, :A), (:return, :R)),
        (:line, 203, :none),
        (:if, (:&&, (:call, :has_fast_linear_indexing, :A), (:call, :>, :lsiz, 16)), (:block,
            (:line, 205, :none),
            (:(=), :nslices, (:call, :div, (:call, :_length, :A), :lsiz)),
            (:line, 206, :none),
            (:(=), :ibase, (:call, :-, (:call, :first, (:call, :linearindices, :A)), 1)),
            (:line, 207, :none),
            (:for, (:(=), :i, (:(:), 1, :nslices)), (:block,
                (:line, 208, :none),
                (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :R, :i), (:call, :op, (:ref, :R, :i), (:call, :mapreduce_impl, :f, :op, :A, (:call, :+, :ibase, 1), (:call, :+, :ibase, :lsiz))))),
                (:line, 209, :none),
                (:+=, :ibase, :lsiz)
              )),
            (:line, 211, :none),
            (:return, :R)
          )),
        (:line, 213, :none),
        (:(=), (:tuple, :indsAt, :indsRt), (:tuple, (:call, :safe_tail, (:call, :indices, :A)), (:call, :safe_tail, (:call, :indices, :R)))),
        (:line, 214, :none),
        (:(=), (:tuple, :keep, :Idefault), (:call, (:., :Broadcast, (:quote, #QuoteNode
                :newindexer
              )), :indsAt, :indsRt)),
        (:line, 215, :none),
        (:if, (:call, :reducedim1, :R, :A), (:block,
            (:line, 217, :none),
            (:(=), :i1, (:call, :first, (:call, :indices1, :R))),
            (:line, 218, :none),
            (:macrocall, Symbol("@inbounds"), (:for, (:(=), :IA, (:call, :CartesianRange, :indsAt)), (:block,
                  (:line, 219, :none),
                  (:(=), :IR, (:call, (:., :Broadcast, (:quote, #QuoteNode
                          :newindex
                        )), :IA, :keep, :Idefault)),
                  (:line, 220, :none),
                  (:(=), :r, (:ref, :R, :i1, :IR)),
                  (:line, 221, :none),
                  (:macrocall, Symbol("@simd"), (:for, (:(=), :i, (:call, :indices, :A, 1)), (:block,
                        (:line, 222, :none),
                        (:(=), :r, (:call, :op, :r, (:call, :f, (:ref, :A, :i, :IA))))
                      ))),
                  (:line, 224, :none),
                  (:(=), (:ref, :R, :i1, :IR), :r)
                )))
          ), (:block,
            (:line, 227, :none),
            (:macrocall, Symbol("@inbounds"), (:for, (:(=), :IA, (:call, :CartesianRange, :indsAt)), (:block,
                  (:line, 228, :none),
                  (:(=), :IR, (:call, (:., :Broadcast, (:quote, #QuoteNode
                          :newindex
                        )), :IA, :keep, :Idefault)),
                  (:line, 229, :none),
                  (:macrocall, Symbol("@simd"), (:for, (:(=), :i, (:call, :indices, :A, 1)), (:block,
                        (:line, 230, :none),
                        (:(=), (:ref, :R, :i, :IR), (:call, :op, (:ref, :R, :i, :IR), (:call, :f, (:ref, :A, :i, :IA))))
                      )))
                )))
          )),
        (:line, 234, :none),
        (:return, :R)
      )),
    (:line, 237, :none),
    (:(=), (:call, :mapreducedim!, :f, :op, (:(::), :R, :AbstractArray), (:(::), :A, :AbstractArray)), (:block,
        (:line, 237, :none),
        (:block,
          (:call, :_mapreducedim!, :f, :op, :R, :A),
          :R
        )
      )),
    (:line, 240, :none),
    (:(=), (:call, (:curly, :reducedim!, :RT), :op, (:(::), :R, (:curly, :AbstractArray, :RT)), (:(::), :A, :AbstractArray)), (:block,
        (:line, 240, :none),
        (:call, :mapreducedim!, :identity, :op, :R, :A, (:call, :zero, :RT))
      )),
    (:line, 243, :none),
    "    mapreducedim(f, op, A, region[, v0])\n\nEvaluates to the same as `reducedim(op, map(f, A), region, f(v0))`, but is generally\nfaster because the intermediate array is avoided.\n\n```jldoctest\njulia> a = reshape(collect(1:16), (4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> mapreducedim(isodd, *, a, 1)\n1×4 Array{Bool,2}:\n false  false  false  false\n\njulia> mapreducedim(isodd, |, a, 1, true)\n1×4 Array{Bool,2}:\n true  true  true  true\n```\n",
    (:line, 266, :none),
    (:(=), (:call, :mapreducedim, :f, :op, (:(::), :A, :AbstractArray), :region, :v0), (:block,
        (:line, 266, :none),
        (:call, :mapreducedim!, :f, :op, (:call, :reducedim_initarray, :A, :region, :v0), :A)
      )),
    (:line, 268, :none),
    (:(=), (:call, (:curly, :mapreducedim, :T), :f, :op, (:(::), :A, (:curly, :AbstractArray, :T)), :region), (:block,
        (:line, 268, :none),
        (:call, :mapreducedim!, :f, :op, (:call, :reducedim_init, :f, :op, :A, :region), :A)
      )),
    (:line, 271, :none),
    "    reducedim(f, A, region[, v0])\n\nReduce 2-argument function `f` along dimensions of `A`. `region` is a vector specifying the\ndimensions to reduce, and `v0` is the initial value to use in the reductions. For `+`, `*`,\n`max` and `min` the `v0` argument is optional.\n\nThe associativity of the reduction is implementation-dependent; if you need a particular\nassociativity, e.g. left-to-right, you should write your own loop. See documentation for\n[`reduce`](:func:`reduce`).\n\n```jldoctest\njulia> a = reshape(collect(1:16), (4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> reducedim(max, a, 2)\n4×1 Array{Int64,2}:\n 13\n 14\n 15\n 16\n\njulia> reducedim(max, a, 1)\n1×4 Array{Int64,2}:\n 4  8  12  16\n```\n",
    (:line, 302, :none),
    (:(=), (:call, :reducedim, :op, (:(::), :A, :AbstractArray), :region, :v0), (:block,
        (:line, 302, :none),
        (:call, :mapreducedim, :identity, :op, :A, :region, :v0)
      )),
    (:line, 303, :none),
    (:(=), (:call, :reducedim, :op, (:(::), :A, :AbstractArray), :region), (:block,
        (:line, 303, :none),
        (:call, :mapreducedim, :identity, :op, :A, :region)
      )),
    (:line, 308, :none),
    (:for, (:(=), (:tuple, :fname, :op), (:vect, (:tuple, (:quote, #QuoteNode
              :sum
            ), (:quote, #QuoteNode
              :+
            )), (:tuple, (:quote, #QuoteNode
              :prod
            ), (:quote, #QuoteNode
              :*
            )), (:tuple, (:quote, #QuoteNode
              :maximum
            ), (:quote, #QuoteNode
              :scalarmax
            )), (:tuple, (:quote, #QuoteNode
              :minimum
            ), (:quote, #QuoteNode
              :scalarmin
            )), (:tuple, (:quote, #QuoteNode
              :all
            ), (:quote, #QuoteNode
              :&
            )), (:tuple, (:quote, #QuoteNode
              :any
            ), (:quote, #QuoteNode
              :|
            )))), (:block,
        (:line, 312, :none),
        (:(=), :fname!, (:call, :Symbol, :fname, '!')),
        (:line, 313, :none),
        (:macrocall, Symbol("@eval"), (:block,
            (:line, 314, :none),
            (:(=), (:call, (:$, :fname!), (:parameters, (:kw, (:(::), :init, :Bool), true)), (:(::), :f, :Function), (:(::), :r, :AbstractArray), (:(::), :A, :AbstractArray)), (:block,
                (:line, 314, :none),
                (:call, :mapreducedim!, :f, (:$, :op), (:call, :initarray!, :r, (:$, :op), :init), :A)
              )),
            (:line, 316, :none),
            (:(=), (:call, (:$, :fname!), (:parameters, (:kw, (:(::), :init, :Bool), true)), (:(::), :r, :AbstractArray), (:(::), :A, :AbstractArray)), (:block,
                (:line, 316, :none),
                (:call, (:$, :fname!), (:parameters, (:kw, :init, :init)), :identity, :r, :A)
              )),
            (:line, 318, :none),
            (:(=), (:call, (:$, :fname), (:(::), :f, :Function), (:(::), :A, :AbstractArray), :region), (:block,
                (:line, 318, :none),
                (:call, :mapreducedim, :f, (:$, :op), :A, :region)
              )),
            (:line, 320, :none),
            (:(=), (:call, (:$, :fname), (:(::), :A, :AbstractArray), :region), (:block,
                (:line, 320, :none),
                (:call, (:$, :fname), :identity, :A, :region)
              ))
          ))
      )),
    (:line, 324, :none),
    (:for, (:(=), (:tuple, :fname, :fbase, :fun), (:vect, (:tuple, (:quote, #QuoteNode
              :sumabs
            ), (:quote, #QuoteNode
              :sum
            ), (:quote, #QuoteNode
              :abs
            )), (:tuple, (:quote, #QuoteNode
              :sumabs2
            ), (:quote, #QuoteNode
              :sum
            ), (:quote, #QuoteNode
              :abs2
            )), (:tuple, (:quote, #QuoteNode
              :maxabs
            ), (:quote, #QuoteNode
              :maximum
            ), (:quote, #QuoteNode
              :abs
            )), (:tuple, (:quote, #QuoteNode
              :minabs
            ), (:quote, #QuoteNode
              :minimum
            ), (:quote, #QuoteNode
              :abs
            )))), (:block,
        (:line, 328, :none),
        (:(=), :fname!, (:call, :Symbol, :fname, '!')),
        (:line, 329, :none),
        (:(=), :fbase!, (:call, :Symbol, :fbase, '!')),
        (:line, 330, :none),
        (:macrocall, Symbol("@eval"), (:block,
            (:line, 331, :none),
            (:(=), (:call, (:$, :fname!), (:parameters, (:kw, (:(::), :init, :Bool), true)), (:(::), :r, :AbstractArray), (:(::), :A, :AbstractArray)), (:block,
                (:line, 331, :none),
                (:call, (:$, :fbase!), (:parameters, (:kw, :init, :init)), (:$, :fun), :r, :A)
              )),
            (:line, 333, :none),
            (:(=), (:call, (:$, :fname), (:(::), :A, :AbstractArray), :region), (:block,
                (:line, 333, :none),
                (:call, (:$, :fbase), (:$, :fun), :A, :region)
              ))
          ))
      )),
    (:line, 340, :none),
    (:function, (:call, (:curly, :findminmax!, :T, :N), :f, :Rval, :Rind, (:(::), :A, (:curly, :AbstractArray, :T, :N))), (:block,
        (:line, 341, :none),
        (:&&, (:||, (:call, :isempty, :Rval), (:call, :isempty, :A)), (:return, (:tuple, :Rval, :Rind))),
        (:line, 342, :none),
        (:(=), :lsiz, (:call, :check_reducedims, :Rval, :A)),
        (:line, 343, :none),
        (:for, (:(=), :i, (:(:), 1, :N)), (:block,
            (:line, 344, :none),
            (:||, (:call, :(==), (:call, :indices, :Rval, :i), (:call, :indices, :Rind, :i)), (:call, :throw, (:call, :DimensionMismatch, "Find-reduction: outputs must have the same indices")))
          )),
        (:line, 348, :none),
        (:(=), (:tuple, :indsAt, :indsRt), (:tuple, (:call, :safe_tail, (:call, :indices, :A)), (:call, :safe_tail, (:call, :indices, :Rval)))),
        (:line, 349, :none),
        (:(=), (:tuple, :keep, :Idefault), (:call, (:., :Broadcast, (:quote, #QuoteNode
                :newindexer
              )), :indsAt, :indsRt)),
        (:line, 350, :none),
        (:(=), :k, 0),
        (:line, 351, :none),
        (:if, (:call, :reducedim1, :Rval, :A), (:block,
            (:line, 352, :none),
            (:(=), :i1, (:call, :first, (:call, :indices1, :Rval))),
            (:line, 353, :none),
            (:macrocall, Symbol("@inbounds"), (:for, (:(=), :IA, (:call, :CartesianRange, :indsAt)), (:block,
                  (:line, 354, :none),
                  (:(=), :IR, (:call, (:., :Broadcast, (:quote, #QuoteNode
                          :newindex
                        )), :IA, :keep, :Idefault)),
                  (:line, 355, :none),
                  (:(=), :tmpRv, (:ref, :Rval, :i1, :IR)),
                  (:line, 356, :none),
                  (:(=), :tmpRi, (:ref, :Rind, :i1, :IR)),
                  (:line, 357, :none),
                  (:for, (:(=), :i, (:call, :indices, :A, 1)), (:block,
                      (:line, 358, :none),
                      (:+=, :k, 1),
                      (:line, 359, :none),
                      (:(=), :tmpAv, (:ref, :A, :i, :IA)),
                      (:line, 360, :none),
                      (:if, (:call, :f, :tmpAv, :tmpRv), (:block,
                          (:line, 361, :none),
                          (:(=), :tmpRv, :tmpAv),
                          (:line, 362, :none),
                          (:(=), :tmpRi, :k)
                        ))
                    )),
                  (:line, 365, :none),
                  (:(=), (:ref, :Rval, :i1, :IR), :tmpRv),
                  (:line, 366, :none),
                  (:(=), (:ref, :Rind, :i1, :IR), :tmpRi)
                )))
          ), (:block,
            (:line, 369, :none),
            (:macrocall, Symbol("@inbounds"), (:for, (:(=), :IA, (:call, :CartesianRange, :indsAt)), (:block,
                  (:line, 370, :none),
                  (:(=), :IR, (:call, (:., :Broadcast, (:quote, #QuoteNode
                          :newindex
                        )), :IA, :keep, :Idefault)),
                  (:line, 371, :none),
                  (:for, (:(=), :i, (:call, :indices, :A, 1)), (:block,
                      (:line, 372, :none),
                      (:+=, :k, 1),
                      (:line, 373, :none),
                      (:(=), :tmpAv, (:ref, :A, :i, :IA)),
                      (:line, 374, :none),
                      (:if, (:call, :f, :tmpAv, (:ref, :Rval, :i, :IR)), (:block,
                          (:line, 375, :none),
                          (:(=), (:ref, :Rval, :i, :IR), :tmpAv),
                          (:line, 376, :none),
                          (:(=), (:ref, :Rind, :i, :IR), :k)
                        ))
                    ))
                )))
          )),
        (:line, 381, :none),
        (:tuple, :Rval, :Rind)
      )),
    (:line, 385, :none),
    "    findmin!(rval, rind, A, [init=true]) -> (minval, index)\n\nFind the minimum of `A` and the corresponding linear index along singleton\ndimensions of `rval` and `rind`, and store the results in `rval` and `rind`.\n",
    (:line, 391, :none),
    (:function, (:call, (:curly, :findmin!, :R), (:parameters, (:kw, (:(::), :init, :Bool), true)), (:(::), :rval, (:curly, :AbstractArray, :R)), (:(::), :rind, :AbstractArray), (:(::), :A, :AbstractArray)), (:block,
        (:line, 395, :none),
        (:call, :findminmax!, :<, (:call, :initarray!, :rval, :scalarmin, :init), :rind, :A)
      )),
    (:line, 398, :none),
    "    findmin(A, region) -> (minval, index)\n\nFor an array input, returns the value and index of the minimum over the given region.\n",
    (:line, 403, :none),
    (:function, (:call, (:curly, :findmin, :T), (:(::), :A, (:curly, :AbstractArray, :T)), :region), (:block,
        (:line, 404, :none),
        (:if, (:call, :isempty, :A), (:block,
            (:line, 405, :none),
            (:return, (:tuple, (:call, :similar, :A, (:call, :reduced_indices0, :A, :region)), (:call, :similar, (:->, :dims, (:block,
                      (:line, 406, :none),
                      (:call, :zeros, :Int, :dims)
                    )), (:call, :reduced_indices0, :A, :region))))
          )),
        (:line, 408, :none),
        (:return, (:call, :findminmax!, :<, (:call, :reducedim_initarray0, :A, :region, (:call, :typemax, :T)), (:call, :similar, (:->, :dims, (:block,
                  (:line, 409, :none),
                  (:call, :zeros, :Int, :dims)
                )), (:call, :reduced_indices0, :A, :region)), :A))
      )),
    (:line, 412, :none),
    "    findmax!(rval, rind, A, [init=true]) -> (maxval, index)\n\nFind the maximum of `A` and the corresponding linear index along singleton\ndimensions of `rval` and `rind`, and store the results in `rval` and `rind`.\n",
    (:line, 418, :none),
    (:function, (:call, (:curly, :findmax!, :R), (:parameters, (:kw, (:(::), :init, :Bool), true)), (:(::), :rval, (:curly, :AbstractArray, :R)), (:(::), :rind, :AbstractArray), (:(::), :A, :AbstractArray)), (:block,
        (:line, 422, :none),
        (:call, :findminmax!, :>, (:call, :initarray!, :rval, :scalarmax, :init), :rind, :A)
      )),
    (:line, 425, :none),
    "    findmax(A, region) -> (maxval, index)\n\nFor an array input, returns the value and index of the maximum over the given region.\n",
    (:line, 430, :none),
    (:function, (:call, (:curly, :findmax, :T), (:(::), :A, (:curly, :AbstractArray, :T)), :region), (:block,
        (:line, 431, :none),
        (:if, (:call, :isempty, :A), (:block,
            (:line, 432, :none),
            (:return, (:tuple, (:call, :similar, :A, (:call, :reduced_indices0, :A, :region)), (:call, :similar, (:->, :dims, (:block,
                      (:line, 433, :none),
                      (:call, :zeros, :Int, :dims)
                    )), (:call, :reduced_indices0, :A, :region))))
          )),
        (:line, 435, :none),
        (:return, (:call, :findminmax!, :>, (:call, :reducedim_initarray0, :A, :region, (:call, :typemin, :T)), (:call, :similar, (:->, :dims, (:block,
                  (:line, 436, :none),
                  (:call, :zeros, :Int, :dims)
                )), (:call, :reduced_indices0, :A, :region)), :A))
      )),
    (:line, 439, :none),
    (:(=), (:call, :reducedim1, :R, :A), (:block,
        (:line, 439, :none),
        (:call, :(==), (:call, :length, (:call, :indices1, :R)), 1)
      ))
  ))