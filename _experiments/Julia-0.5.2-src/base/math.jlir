(:quote, (:block,
    (:line, 3, :none),
    (:module, true, :Math, (:block,
        (:line, 3, :none),
        (:line, 5, :none),
        (:export, :sin, :cos, :tan, :sinh, :cosh, :tanh, :asin, :acos, :atan, :asinh, :acosh, :atanh, :sec, :csc, :cot, :asec, :acsc, :acot, :sech, :csch, :coth, :asech, :acsch, :acoth, :sinpi, :cospi, :sinc, :cosc, :cosd, :cotd, :cscd, :secd, :sind, :tand, :acosd, :acotd, :acscd, :asecd, :asind, :atand, :atan2, :rad2deg, :deg2rad, :log, :log2, :log10, :log1p, :exponent, :exp, :exp2, :exp10, :expm1, :cbrt, :sqrt, :erf, :erfc, :erfcx, :erfi, :dawson, :significand, :lgamma, :hypot, :gamma, :lfact, :max, :min, :minmax, :ldexp, :frexp, :clamp, :clamp!, :modf, :^, :mod2pi, :airy, :airyai, :airyprime, :airyaiprime, :airybi, :airybiprime, :airyx, :besselj0, :besselj1, :besselj, :besseljx, :bessely0, :bessely1, :bessely, :besselyx, :hankelh1, :hankelh2, :hankelh1x, :hankelh2x, :besseli, :besselix, :besselk, :besselkx, :besselh, :besselhx, :beta, :lbeta, :eta, :zeta, :polygamma, :invdigamma, :digamma, :trigamma, :erfinv, :erfcinv, Symbol("@evalpoly")),
        (:line, 25, :none),
        (:toplevel, (:import, :Base, :log), (:import, :Base, :exp), (:import, :Base, :sin), (:import, :Base, :cos), (:import, :Base, :tan), (:import, :Base, :sinh), (:import, :Base, :cosh), (:import, :Base, :tanh), (:import, :Base, :asin), (:import, :Base, :acos), (:import, :Base, :atan), (:import, :Base, :asinh), (:import, :Base, :acosh), (:import, :Base, :atanh), (:import, :Base, :sqrt), (:import, :Base, :log2), (:import, :Base, :log10), (:import, :Base, :max), (:import, :Base, :min), (:import, :Base, :minmax), (:import, :Base, :^), (:import, :Base, :exp2), (:import, :Base, :muladd), (:import, :Base, :exp10), (:import, :Base, :expm1), (:import, :Base, :log1p), (:import, :Base, :sign_mask), (:import, :Base, :exponent_mask), (:import, :Base, :exponent_one), (:import, :Base, :exponent_half), (:import, :Base, :significand_mask), (:import, :Base, :significand_bits), (:import, :Base, :exponent_bits), (:import, :Base, :exponent_bias)),
        (:line, 33, :none),
        (:toplevel, (:import, :Core, :Intrinsics, :sqrt_llvm), (:import, :Core, :Intrinsics, :box), (:import, :Core, :Intrinsics, :unbox), (:import, :Core, :Intrinsics, :powi_llvm)),
        (:line, 37, :none),
        (:macrocall, :(Core.@doc), "    clamp(x, lo, hi)\n\nReturn `x` if `lo <= x <= hi`. If `x < lo`, return `lo`. If `x > hi`, return `hi`. Arguments\nare promoted to a common type. Operates elementwise over `x` if `x` is an array.\n\n```jldoctest\njulia> clamp([pi, 1.0, big(10.)], 2., 9.)\n3-element Array{BigFloat,1}:\n 3.141592653589793238462643383279502884197169399375105820974944592307816406286198\n 2.000000000000000000000000000000000000000000000000000000000000000000000000000000\n 9.000000000000000000000000000000000000000000000000000000000000000000000000000000\n```\n", (:(=), (:call, (:curly, :clamp, :X, :L, :H), (:(::), :x, :X), (:(::), :lo, :L), (:(::), :hi, :H)), (:block,
              (:line, 51, :none),
              (:call, :ifelse, (:call, :>, :x, :hi), (:call, :convert, (:call, :promote_type, :X, :L, :H), :hi), (:call, :ifelse, (:call, :<, :x, :lo), (:call, :convert, (:call, :promote_type, :X, :L, :H), :lo), (:call, :convert, (:call, :promote_type, :X, :L, :H), :x)))
            ))),
        (:line, 57, :none),
        (:(=), (:call, (:curly, :clamp, :T), (:(::), :x, (:curly, :AbstractArray, :T, 1)), :lo, :hi), (:block,
            (:line, 57, :none),
            (:comprehension, (:generator, (:call, :clamp, :xx, :lo, :hi), (:(=), :xx, :x)))
          )),
        (:line, 58, :none),
        (:(=), (:call, (:curly, :clamp, :T), (:(::), :x, (:curly, :AbstractArray, :T, 2)), :lo, :hi), (:block,
            (:line, 58, :none),
            (:comprehension, (:generator, (:call, :clamp, (:ref, :x, :i, :j), :lo, :hi), (:(=), :i, (:call, :indices, :x, 1)), (:(=), :j, (:call, :indices, :x, 2))))
          )),
        (:line, 61, :none),
        (:(=), (:call, (:curly, :clamp, :T), (:(::), :x, (:curly, :AbstractArray, :T)), :lo, :hi), (:block,
            (:line, 61, :none),
            (:call, :reshape, (:comprehension, (:generator, (:call, :clamp, :xx, :lo, :hi), (:(=), :xx, :x))), (:call, :size, :x))
          )),
        (:line, 64, :none),
        (:macrocall, :(Core.@doc), "    clamp!(array::AbstractArray, lo, hi)\n\nRestrict values in `array` to the specified range, in-place.\nSee also [`clamp`](:func:`clamp`).\n", (:function, (:call, (:curly, :clamp!, :T), (:(::), :x, (:curly, :AbstractArray, :T)), :lo, :hi), (:block,
              (:line, 71, :none),
              (:macrocall, Symbol("@inbounds"), (:for, (:(=), :i, (:call, :eachindex, :x)), (:block,
                    (:line, 72, :none),
                    (:(=), (:ref, :x, :i), (:call, :clamp, (:ref, :x, :i), :lo, :hi))
                  ))),
              (:line, 74, :none),
              :x
            ))),
        (:line, 78, :none),
        (:macro, (:call, :horner, :x, (:..., :p)), (:block,
            (:line, 79, :none),
            (:(=), :ex, (:call, :esc, (:ref, :p, :end))),
            (:line, 80, :none),
            (:for, (:(=), :i, (:(:), (:call, :-, (:call, :length, :p), 1), -1, 1)), (:block,
                (:line, 81, :none),
                (:(=), :ex, (:quote, (:call, :muladd, :t, (:$, :ex), (:$, (:call, :esc, (:ref, :p, :i))))))
              )),
            (:line, 83, :none),
            (:call, :Expr, (:quote, #QuoteNode
                :block
              ), (:quote, (:(=), :t, (:$, (:call, :esc, :x)))), :ex)
          )),
        (:line, 90, :none),
        (:macro, (:call, :evalpoly, :z, (:..., :p)), (:block,
            (:line, 91, :none),
            (:(=), :a, (:quote, (:$, (:call, :esc, (:ref, :p, :end))))),
            (:line, 92, :none),
            (:(=), :b, (:quote, (:$, (:call, :esc, (:ref, :p, (:call, :-, :end, 1)))))),
            (:line, 93, :none),
            (:(=), :as, (:vect,)),
            (:line, 94, :none),
            (:for, (:(=), :i, (:(:), (:call, :-, (:call, :length, :p), 2), -1, 1)), (:block,
                (:line, 95, :none),
                (:(=), :ai, (:call, :Symbol, "a", :i)),
                (:line, 96, :none),
                (:call, :push!, :as, (:quote, (:(=), (:$, :ai), (:$, :a)))),
                (:line, 97, :none),
                (:(=), :a, (:quote, (:call, :muladd, :r, (:$, :ai), (:$, :b)))),
                (:line, 98, :none),
                (:(=), :b, (:quote, (:call, :-, (:$, (:call, :esc, (:ref, :p, :i))), (:call, :*, :s, (:$, :ai)))))
              )),
            (:line, 100, :none),
            (:(=), :ai, (:quote, #QuoteNode
                :a0
              )),
            (:line, 101, :none),
            (:call, :push!, :as, (:quote, (:(=), (:$, :ai), (:$, :a)))),
            (:line, 102, :none),
            (:(=), :C, (:call, :Expr, (:quote, #QuoteNode
                  :block
                ), (:quote, (:(=), :x, (:call, :real, :tt))), (:quote, (:(=), :y, (:call, :imag, :tt))), (:quote, (:(=), :r, (:call, :+, :x, :x))), (:quote, (:(=), :s, (:call, :muladd, :x, :x, (:call, :*, :y, :y)))), (:..., :as), (:quote, (:call, :muladd, (:$, :ai), :tt, (:$, :b))))),
            (:line, 109, :none),
            (:(=), :R, (:call, :Expr, (:quote, #QuoteNode
                  :macrocall
                ), (:call, :Symbol, "@horner"), (:quote, #QuoteNode
                  :tt
                ), (:..., (:call, :map, :esc, :p)))),
            (:line, 110, :none),
            (:quote, (:let, (:block,
                  (:line, 111, :none),
                  (:if, (:call, :isa, :tt, :Complex), (:$, :C), (:$, :R))
                ), (:(=), :tt, (:$, (:call, :esc, :z)))))
          )),
        (:line, 115, :none),
        (:(=), (:call, :rad2deg, (:(::), :z, :AbstractFloat)), (:block,
            (:line, 115, :none),
            (:call, :*, :z, (:call, :/, 180, (:call, :oftype, :z, :pi)))
          )),
        (:line, 116, :none),
        (:(=), (:call, :deg2rad, (:(::), :z, :AbstractFloat)), (:block,
            (:line, 116, :none),
            (:call, :*, :z, (:call, :/, (:call, :oftype, :z, :pi), 180))
          )),
        (:line, 117, :none),
        (:(=), (:call, :rad2deg, (:(::), :z, :Real)), (:block,
            (:line, 117, :none),
            (:call, :rad2deg, (:call, :float, :z))
          )),
        (:line, 118, :none),
        (:(=), (:call, :deg2rad, (:(::), :z, :Real)), (:block,
            (:line, 118, :none),
            (:call, :deg2rad, (:call, :float, :z))
          )),
        (:line, 119, :none),
        (:macrocall, Symbol("@vectorize_1arg"), :Real, :rad2deg),
        (:line, 120, :none),
        (:macrocall, Symbol("@vectorize_1arg"), :Real, :deg2rad),
        (:line, 122, :none),
        (:(=), (:call, (:curly, :log, (:<:, :T, :Number)), (:(::), :b, :T), (:(::), :x, :T)), (:block,
            (:line, 122, :none),
            (:call, :/, (:call, :log, :x), (:call, :log, :b))
          )),
        (:line, 124, :none),
        (:macrocall, :(Core.@doc), "    log(b,x)\n\nCompute the base `b` logarithm of `x`. Throws `DomainError` for negative `Real` arguments.\n\n```jldoctest\njulia> log(4,8)\n1.5\n\njulia> log(4,2)\n0.5\n```\n\n!!! note\n    If `b` is a power of 2 or 10, `log2` or `log10` should be used, as these will\n    typically be faster and more accurate. For example,\n\n    ```jldoctest\n    julia> log(100,1000000)\n    2.9999999999999996\n\n    julia> log10(1000000)/2\n    3.0\n    ```\n", (:(=), (:call, :log, (:(::), :b, :Number), (:(::), :x, :Number)), (:block,
              (:line, 149, :none),
              (:call, :log, (:..., (:call, :promote, :b, :x)))
            ))),
        (:line, 150, :none),
        (:macrocall, Symbol("@vectorize_2arg"), :Number, :log),
        (:line, 154, :none),
        (:const, (:(=), :libm, (:., :Base, (:quote, #QuoteNode
                :libm_name
              )))),
        (:line, 155, :none),
        (:const, (:(=), :openspecfun, "libopenspecfun")),
        (:line, 158, :none),
        (:for, (:(=), :f, (:tuple, (:quote, #QuoteNode
                :cbrt
              ), (:quote, #QuoteNode
                :sinh
              ), (:quote, #QuoteNode
                :cosh
              ), (:quote, #QuoteNode
                :tanh
              ), (:quote, #QuoteNode
                :atan
              ), (:quote, #QuoteNode
                :asinh
              ), (:quote, #QuoteNode
                :exp
              ), (:quote, #QuoteNode
                :erf
              ), (:quote, #QuoteNode
                :erfc
              ), (:quote, #QuoteNode
                :exp2
              ), (:quote, #QuoteNode
                :expm1
              ))), (:block,
            (:line, 159, :none),
            (:macrocall, Symbol("@eval"), (:block,
                (:line, 160, :none),
                (:(=), (:call, (:$, :f), (:(::), :x, :Float64)), (:block,
                    (:line, 160, :none),
                    (:ccall, (:tuple, (:$, (:call, :string, :f)), :libm), :Float64, (:tuple, :Float64), :x)
                  )),
                (:line, 161, :none),
                (:(=), (:call, (:$, :f), (:(::), :x, :Float32)), (:block,
                    (:line, 161, :none),
                    (:ccall, (:tuple, (:$, (:call, :string, :f, "f")), :libm), :Float32, (:tuple, :Float32), :x)
                  )),
                (:line, 162, :none),
                (:(=), (:call, (:$, :f), (:(::), :x, :Real)), (:block,
                    (:line, 162, :none),
                    (:call, (:$, :f), (:call, :float, :x))
                  )),
                (:line, 163, :none),
                (:macrocall, Symbol("@vectorize_1arg"), :Number, (:$, :f))
              ))
          )),
        (:line, 168, :none),
        (:(=), (:call, :cbrt, (:(::), :x, :AbstractFloat)), (:block,
            (:line, 168, :none),
            (:call, :^, :x, (:call, ://, 1, 3))
          )),
        (:line, 169, :none),
        (:(=), (:call, :exp2, (:(::), :x, :AbstractFloat)), (:block,
            (:line, 169, :none),
            (:call, :^, 2, :x)
          )),
        (:line, 170, :none),
        (:for, (:(=), :f, (:tuple, (:quote, #QuoteNode
                :sinh
              ), (:quote, #QuoteNode
                :cosh
              ), (:quote, #QuoteNode
                :tanh
              ), (:quote, #QuoteNode
                :atan
              ), (:quote, #QuoteNode
                :asinh
              ), (:quote, #QuoteNode
                :exp
              ), (:quote, #QuoteNode
                :erf
              ), (:quote, #QuoteNode
                :erfc
              ), (:quote, #QuoteNode
                :expm1
              ))), (:block,
            (:line, 171, :none),
            (:macrocall, Symbol("@eval"), (:(=), (:call, (:$, :f), (:(::), :x, :AbstractFloat)), (:block,
                  (:line, 171, :none),
                  (:call, :error, "not implemented for ", (:call, :typeof, :x))
                )))
          )),
        (:line, 175, :none),
        (:macrocall, Symbol("@inline"), (:function, (:call, :exp2, (:(::), :x, (:., :Base, (:quote, #QuoteNode
                    :BitInteger
                  )))), (:block,
              (:line, 176, :none),
              (:if, (:call, :>, :x, 1023), (:block,
                  (:line, 177, :none),
                  :Inf64
                ), (:block,
                  (:line, 178, :none),
                  (:if, (:call, :(<=), :x, -1023), (:block,
                      (:line, 181, :none),
                      (:call, :reinterpret, :Float64, (:call, :<<, 0x0000000000000001, (:call, :%, (:call, :+, :x, 1074), :UInt)))
                    ), (:block,
                      (:line, 185, :none),
                      (:call, :reinterpret, :Float64, (:call, :<<, (:call, :+, (:call, :exponent_bias, :Float64), (:call, :%, :x, :Int64)), (:call, :%, (:call, :significand_bits, :Float64), :UInt)))
                    ))
                ))
            ))),
        (:line, 190, :none),
        (:(=), (:call, :exp10, (:(::), :x, :Float64)), (:block,
            (:line, 190, :none),
            (:call, :^, 10.0, :x)
          )),
        (:line, 191, :none),
        (:(=), (:call, :exp10, (:(::), :x, :Float32)), (:block,
            (:line, 191, :none),
            (:call, :^, 10.0f0, :x)
          )),
        (:line, 192, :none),
        (:(=), (:call, :exp10, (:(::), :x, :Integer)), (:block,
            (:line, 192, :none),
            (:call, :exp10, (:call, :float, :x))
          )),
        (:line, 193, :none),
        (:macrocall, Symbol("@vectorize_1arg"), :Number, :exp10),
        (:line, 196, :none),
        (:macrocall, Symbol("@inline"), (:(=), (:call, :nan_dom_err, :f, :x), (:block,
              (:line, 196, :none),
              (:if, (:call, :&, (:call, :isnan, :f), (:call, :!, (:call, :isnan, :x))), (:call, :throw, (:call, :DomainError)), :f)
            ))),
        (:line, 199, :none),
        (:for, (:(=), :f, (:tuple, (:quote, #QuoteNode
                :sin
              ), (:quote, #QuoteNode
                :cos
              ), (:quote, #QuoteNode
                :tan
              ), (:quote, #QuoteNode
                :asin
              ), (:quote, #QuoteNode
                :acos
              ), (:quote, #QuoteNode
                :acosh
              ), (:quote, #QuoteNode
                :atanh
              ), (:quote, #QuoteNode
                :log
              ), (:quote, #QuoteNode
                :log2
              ), (:quote, #QuoteNode
                :log10
              ), (:quote, #QuoteNode
                :lgamma
              ), (:quote, #QuoteNode
                :log1p
              ))), (:block,
            (:line, 201, :none),
            (:macrocall, Symbol("@eval"), (:block,
                (:line, 202, :none),
                (:(=), (:call, (:$, :f), (:(::), :x, :Float64)), (:block,
                    (:line, 202, :none),
                    (:call, :nan_dom_err, (:ccall, (:tuple, (:$, (:call, :string, :f)), :libm), :Float64, (:tuple, :Float64), :x), :x)
                  )),
                (:line, 203, :none),
                (:(=), (:call, (:$, :f), (:(::), :x, :Float32)), (:block,
                    (:line, 203, :none),
                    (:call, :nan_dom_err, (:ccall, (:tuple, (:$, (:call, :string, :f, "f")), :libm), :Float32, (:tuple, :Float32), :x), :x)
                  )),
                (:line, 204, :none),
                (:(=), (:call, (:$, :f), (:(::), :x, :Real)), (:block,
                    (:line, 204, :none),
                    (:call, (:$, :f), (:call, :float, :x))
                  )),
                (:line, 205, :none),
                (:macrocall, Symbol("@vectorize_1arg"), :Number, (:$, :f))
              ))
          )),
        (:line, 209, :none),
        (:(=), (:call, :sqrt, (:(::), :x, :Float64)), (:block,
            (:line, 209, :none),
            (:call, :box, :Float64, (:call, :sqrt_llvm, (:call, :unbox, :Float64, :x)))
          )),
        (:line, 210, :none),
        (:(=), (:call, :sqrt, (:(::), :x, :Float32)), (:block,
            (:line, 210, :none),
            (:call, :box, :Float32, (:call, :sqrt_llvm, (:call, :unbox, :Float32, :x)))
          )),
        (:line, 211, :none),
        (:(=), (:call, :sqrt, (:(::), :x, :Real)), (:block,
            (:line, 211, :none),
            (:call, :sqrt, (:call, :float, :x))
          )),
        (:line, 212, :none),
        (:macrocall, Symbol("@vectorize_1arg"), :Number, :sqrt),
        (:line, 214, :none),
        (:macrocall, :(Core.@doc), "    hypot(x, y)\n\nCompute the hypotenuse ``\\sqrt{x^2+y^2}`` avoiding overflow and underflow.\n", (:(=), (:call, :hypot, (:(::), :x, :Number), (:(::), :y, :Number)), (:block,
              (:line, 219, :none),
              (:call, :hypot, (:..., (:call, :promote, :x, :y)))
            ))),
        (:line, 220, :none),
        (:function, (:call, (:curly, :hypot, (:<:, :T, :Number)), (:(::), :x, :T), (:(::), :y, :T)), (:block,
            (:line, 221, :none),
            (:(=), :ax, (:call, :abs, :x)),
            (:line, 222, :none),
            (:(=), :ay, (:call, :abs, :y)),
            (:line, 223, :none),
            (:if, (:call, :<, :ax, :ay), (:block,
                (:line, 224, :none),
                (:(=), (:tuple, :ax, :ay), (:tuple, :ay, :ax))
              )),
            (:line, 226, :none),
            (:if, (:call, :(==), :ax, 0), (:block,
                (:line, 227, :none),
                (:(=), :r, (:call, :/, :ay, (:call, :one, :ax)))
              ), (:block,
                (:line, 229, :none),
                (:(=), :r, (:call, :/, :ay, :ax))
              )),
            (:line, 232, :none),
            (:(=), :rr, (:call, :*, :ax, (:call, :sqrt, (:call, :+, 1, (:call, :*, :r, :r))))),
            (:line, 236, :none),
            (:if, (:call, :isnan, :r), (:block,
                (:line, 237, :none),
                (:&&, (:call, :isinf, :ax), (:return, (:call, :oftype, :rr, :Inf))),
                (:line, 238, :none),
                (:&&, (:call, :isinf, :ay), (:return, (:call, :oftype, :rr, :Inf))),
                (:line, 239, :none),
                (:return, (:call, :oftype, :rr, :r))
              ), (:block,
                (:line, 241, :none),
                (:return, :rr)
              ))
          )),
        (:line, 244, :none),
        (:macrocall, Symbol("@vectorize_2arg"), :Number, :hypot),
        (:line, 246, :none),
        (:macrocall, :(Core.@doc), "    hypot(x...)\n\nCompute the hypotenuse ``\\sqrt{\\sum x_i^2}`` avoiding overflow and underflow.\n", (:(=), (:call, :hypot, (:..., (:(::), :x, :Number))), (:block,
              (:line, 251, :none),
              (:call, :vecnorm, :x)
            ))),
        (:line, 253, :none),
        (:(=), (:call, :atan2, (:(::), :y, :Real), (:(::), :x, :Real)), (:block,
            (:line, 253, :none),
            (:call, :atan2, (:..., (:call, :promote, (:call, :float, :y), (:call, :float, :x))))
          )),
        (:line, 254, :none),
        (:(=), (:call, (:curly, :atan2, (:<:, :T, :AbstractFloat)), (:(::), :y, :T), (:(::), :x, :T)), (:block,
            (:line, 254, :none),
            (:call, (:., :Base, (:quote, #QuoteNode
                  :no_op_err
                )), "atan2", :T)
          )),
        (:line, 256, :none),
        (:(=), (:call, :atan2, (:(::), :y, :Float64), (:(::), :x, :Float64)), (:block,
            (:line, 256, :none),
            (:ccall, (:tuple, (:quote, #QuoteNode
                  :atan2
                ), :libm), :Float64, (:tuple, :Float64, :Float64), :y, :x)
          )),
        (:line, 257, :none),
        (:(=), (:call, :atan2, (:(::), :y, :Float32), (:(::), :x, :Float32)), (:block,
            (:line, 257, :none),
            (:ccall, (:tuple, (:quote, #QuoteNode
                  :atan2f
                ), :libm), :Float32, (:tuple, :Float32, :Float32), :y, :x)
          )),
        (:line, 258, :none),
        (:macrocall, Symbol("@vectorize_2arg"), :Number, :atan2),
        (:line, 260, :none),
        (:(=), (:call, (:curly, :max, (:<:, :T, :AbstractFloat)), (:(::), :x, :T), (:(::), :y, :T)), (:block,
            (:line, 260, :none),
            (:call, :ifelse, (:call, :|, (:call, :>, :y, :x), (:call, :<, (:call, :signbit, :y), (:call, :signbit, :x))), (:call, :ifelse, (:call, :isnan, :y), :x, :y), (:call, :ifelse, (:call, :isnan, :x), :y, :x))
          )),
        (:line, 263, :none),
        (:macrocall, Symbol("@vectorize_2arg"), :Real, :max),
        (:line, 265, :none),
        (:(=), (:call, (:curly, :min, (:<:, :T, :AbstractFloat)), (:(::), :x, :T), (:(::), :y, :T)), (:block,
            (:line, 265, :none),
            (:call, :ifelse, (:call, :|, (:call, :<, :y, :x), (:call, :>, (:call, :signbit, :y), (:call, :signbit, :x))), (:call, :ifelse, (:call, :isnan, :y), :x, :y), (:call, :ifelse, (:call, :isnan, :x), :y, :x))
          )),
        (:line, 267, :none),
        (:macrocall, Symbol("@vectorize_2arg"), :Real, :min),
        (:line, 269, :none),
        (:(=), (:call, (:curly, :minmax, (:<:, :T, :AbstractFloat)), (:(::), :x, :T), (:(::), :y, :T)), (:block,
            (:line, 269, :none),
            (:call, :ifelse, (:call, :isnan, (:call, :-, :x, :y)), (:call, :ifelse, (:call, :isnan, :x), (:tuple, :y, :y), (:tuple, :x, :x)), (:call, :ifelse, (:call, :|, (:call, :<, :y, :x), (:call, :>, (:call, :signbit, :y), (:call, :signbit, :x))), (:tuple, :y, :x), (:call, :ifelse, (:call, :|, (:call, :>, :y, :x), (:call, :<, (:call, :signbit, :y), (:call, :signbit, :x))), (:tuple, :x, :y), (:call, :ifelse, (:call, :(==), :x, :x), (:tuple, :x, :x), (:tuple, :y, :y)))))
          )),
        (:line, 274, :none),
        (:(=), (:call, :ldexp, (:(::), :x, :Float64), (:(::), :e, :Integer)), (:block,
            (:line, 274, :none),
            (:ccall, (:tuple, (:quote, #QuoteNode
                  :scalbn
                ), :libm), :Float64, (:tuple, :Float64, :Int32), :x, (:call, :Int32, :e))
          )),
        (:line, 275, :none),
        (:(=), (:call, :ldexp, (:(::), :x, :Float32), (:(::), :e, :Integer)), (:block,
            (:line, 275, :none),
            (:ccall, (:tuple, (:quote, #QuoteNode
                  :scalbnf
                ), :libm), :Float32, (:tuple, :Float32, :Int32), :x, (:call, :Int32, :e))
          )),
        (:line, 278, :none),
        (:function, (:call, (:curly, :exponent, (:<:, :T, :AbstractFloat)), (:(::), :x, :T)), (:block,
            (:line, 279, :none),
            (:(=), :xu, (:call, :reinterpret, :Unsigned, :x)),
            (:line, 280, :none),
            (:(=), :xe, (:call, :&, :xu, (:call, :exponent_mask, :T))),
            (:line, 281, :none),
            (:(=), :k, (:call, :Int, (:call, :>>, :xe, (:call, :significand_bits, :T)))),
            (:line, 282, :none),
            (:if, (:call, :(==), :xe, 0), (:block,
                (:line, 283, :none),
                (:&&, (:call, :(==), :x, 0), (:call, :throw, (:call, :DomainError))),
                (:line, 284, :none),
                (:&=, :xu, (:call, :significand_mask, :T)),
                (:line, 285, :none),
                (:(=), :m, (:call, :-, (:call, :leading_zeros, :xu), (:call, :exponent_bits, :T))),
                (:line, 286, :none),
                (:(=), :k, (:call, :-, 1, :m))
              ), (:block,
                (:line, 287, :none),
                (:if, (:call, :(==), :xe, (:call, :exponent_mask, :T)), (:block,
                    (:line, 288, :none),
                    (:call, :throw, (:call, :DomainError))
                  ))
              )),
            (:line, 290, :none),
            (:call, :-, :k, (:call, :exponent_bias, :T))
          )),
        (:line, 292, :none),
        (:macrocall, Symbol("@vectorize_1arg"), :Real, :exponent),
        (:line, 294, :none),
        (:function, (:call, (:curly, :significand, (:<:, :T, :AbstractFloat)), (:(::), :x, :T)), (:block,
            (:line, 295, :none),
            (:(=), :xu, (:call, :reinterpret, :Unsigned, :x)),
            (:line, 296, :none),
            (:(=), :xe, (:call, :&, :xu, (:call, :exponent_mask, :T))),
            (:line, 297, :none),
            (:if, (:call, :(==), :xe, 0), (:block,
                (:line, 298, :none),
                (:&&, (:call, :(==), :x, 0), (:return, :x)),
                (:line, 299, :none),
                (:(=), :xs, (:call, :&, :xu, (:call, :sign_mask, :T))),
                (:line, 300, :none),
                (:$=, :xu, :xs),
                (:line, 301, :none),
                (:(=), :m, (:call, :-, (:call, :leading_zeros, :xu), (:call, :exponent_bits, :T))),
                (:line, 302, :none),
                (:<<=, :xu, :m),
                (:line, 303, :none),
                (:$=, :xu, :xs)
              ), (:block,
                (:line, 304, :none),
                (:if, (:call, :(==), :xe, (:call, :exponent_mask, :T)), (:block,
                    (:line, 305, :none),
                    (:return, :x)
                  ))
              )),
            (:line, 307, :none),
            (:(=), :xu, (:call, :|, (:call, :&, :xu, (:call, :~, (:call, :exponent_mask, :T))), (:call, :exponent_one, :T))),
            (:line, 308, :none),
            (:call, :reinterpret, :T, :xu)
          )),
        (:line, 310, :none),
        (:macrocall, Symbol("@vectorize_1arg"), :Real, :significand),
        (:line, 312, :none),
        (:function, (:call, (:curly, :frexp, (:<:, :T, :AbstractFloat)), (:(::), :x, :T)), (:block,
            (:line, 313, :none),
            (:(=), :xu, (:call, :reinterpret, :Unsigned, :x)),
            (:line, 314, :none),
            (:(=), :xe, (:call, :&, :xu, (:call, :exponent_mask, :T))),
            (:line, 315, :none),
            (:(=), :k, (:call, :Int, (:call, :>>, :xe, (:call, :significand_bits, :T)))),
            (:line, 316, :none),
            (:if, (:call, :(==), :xe, 0), (:block,
                (:line, 317, :none),
                (:&&, (:call, :(==), :x, 0), (:return, (:tuple, :x, 0))),
                (:line, 318, :none),
                (:(=), :xs, (:call, :&, :xu, (:call, :sign_mask, :T))),
                (:line, 319, :none),
                (:$=, :xu, :xs),
                (:line, 320, :none),
                (:(=), :m, (:call, :-, (:call, :leading_zeros, :xu), (:call, :exponent_bits, :T))),
                (:line, 321, :none),
                (:<<=, :xu, :m),
                (:line, 322, :none),
                (:$=, :xu, :xs),
                (:line, 323, :none),
                (:(=), :k, (:call, :-, 1, :m))
              ), (:block,
                (:line, 324, :none),
                (:if, (:call, :(==), :xe, (:call, :exponent_mask, :T)), (:block,
                    (:line, 325, :none),
                    (:return, (:tuple, :x, 0))
                  ))
              )),
            (:line, 327, :none),
            (:-=, :k, (:call, :-, (:call, :exponent_bias, :T), 1)),
            (:line, 328, :none),
            (:(=), :xu, (:call, :|, (:call, :&, :xu, (:call, :~, (:call, :exponent_mask, :T))), (:call, :exponent_half, :T))),
            (:line, 329, :none),
            (:tuple, (:call, :reinterpret, :T, :xu), :k)
          )),
        (:line, 332, :none),
        (:function, (:call, (:curly, :frexp, (:<:, :T, :AbstractFloat)), (:(::), :A, (:curly, :Array, :T))), (:block,
            (:line, 333, :none),
            (:(=), :F, (:call, :similar, :A)),
            (:line, 334, :none),
            (:(=), :E, (:call, (:curly, :Array, :Int), (:call, :size, :A))),
            (:line, 335, :none),
            (:for, (:(=), (:tuple, :iF, :iE, :iA), (:call, :zip, (:call, :eachindex, :F), (:call, :eachindex, :E), (:call, :eachindex, :A))), (:block,
                (:line, 336, :none),
                (:(=), (:tuple, (:ref, :F, :iF), (:ref, :E, :iE)), (:call, :frexp, (:ref, :A, :iA)))
              )),
            (:line, 338, :none),
            (:return, (:tuple, :F, :E))
          )),
        (:line, 341, :none),
        (:(=), (:call, :modf, :x), (:block,
            (:line, 341, :none),
            (:tuple, (:call, :rem, :x, (:call, :one, :x)), (:call, :trunc, :x))
          )),
        (:line, 343, :none),
        (:const, (:(=), :_modff_temp, (:call, (:curly, :Ref, :Float32)))),
        (:line, 344, :none),
        (:function, (:call, :modf, (:(::), :x, :Float32)), (:block,
            (:line, 345, :none),
            (:(=), :f, (:ccall, (:tuple, (:quote, #QuoteNode
                    :modff
                  ), :libm), :Float32, (:tuple, :Float32, (:curly, :Ptr, :Float32)), :x, :_modff_temp)),
            (:line, 346, :none),
            (:tuple, :f, (:ref, :_modff_temp))
          )),
        (:line, 349, :none),
        (:const, (:(=), :_modf_temp, (:call, (:curly, :Ref, :Float64)))),
        (:line, 350, :none),
        (:function, (:call, :modf, (:(::), :x, :Float64)), (:block,
            (:line, 351, :none),
            (:(=), :f, (:ccall, (:tuple, (:quote, #QuoteNode
                    :modf
                  ), :libm), :Float64, (:tuple, :Float64, (:curly, :Ptr, :Float64)), :x, :_modf_temp)),
            (:line, 352, :none),
            (:tuple, :f, (:ref, :_modf_temp))
          )),
        (:line, 355, :none),
        (:(=), (:call, :^, (:(::), :x, :Float64), (:(::), :y, :Float64)), (:block,
            (:line, 355, :none),
            (:call, :nan_dom_err, (:ccall, (:tuple, (:quote, #QuoteNode
                    :pow
                  ), :libm), :Float64, (:tuple, :Float64, :Float64), :x, :y), (:call, :+, :x, :y))
          )),
        (:line, 356, :none),
        (:(=), (:call, :^, (:(::), :x, :Float32), (:(::), :y, :Float32)), (:block,
            (:line, 356, :none),
            (:call, :nan_dom_err, (:ccall, (:tuple, (:quote, #QuoteNode
                    :powf
                  ), :libm), :Float32, (:tuple, :Float32, :Float32), :x, :y), (:call, :+, :x, :y))
          )),
        (:line, 358, :none),
        (:(=), (:call, :^, (:(::), :x, :Float64), (:(::), :y, :Integer)), (:block,
            (:line, 358, :none),
            (:call, :box, :Float64, (:call, :powi_llvm, (:call, :unbox, :Float64, :x), (:call, :unbox, :Int32, (:call, :Int32, :y))))
          )),
        (:line, 360, :none),
        (:(=), (:call, :^, (:(::), :x, :Float32), (:(::), :y, :Integer)), (:block,
            (:line, 360, :none),
            (:call, :box, :Float32, (:call, :powi_llvm, (:call, :unbox, :Float32, :x), (:call, :unbox, :Int32, (:call, :Int32, :y))))
          )),
        (:line, 363, :none),
        (:function, (:call, :angle_restrict_symm, :theta), (:block,
            (:line, 364, :none),
            (:const, (:(=), :P1, (:call, :*, 4, 0.7853981256484985))),
            (:line, 365, :none),
            (:const, (:(=), :P2, (:call, :*, 4, 3.774894707930798e-8))),
            (:line, 366, :none),
            (:const, (:(=), :P3, (:call, :*, 4, 2.6951514290790595e-15))),
            (:line, 368, :none),
            (:(=), :y, (:call, :*, 2, (:call, :floor, (:call, :/, :theta, (:call, :*, 2, :pi))))),
            (:line, 369, :none),
            (:(=), :r, (:call, :-, (:call, :-, (:call, :-, :theta, (:call, :*, :y, :P1)), (:call, :*, :y, :P2)), (:call, :*, :y, :P3))),
            (:line, 370, :none),
            (:if, (:call, :>, :r, :pi), (:block,
                (:line, 371, :none),
                (:-=, :r, (:call, :*, 2, :pi))
              )),
            (:line, 373, :none),
            (:return, :r)
          )),
        (:line, 378, :none),
        (:function, (:call, :add22condh, (:(::), :xh, :Float64), (:(::), :xl, :Float64), (:(::), :yh, :Float64), (:(::), :yl, :Float64)), (:block,
            (:line, 380, :none),
            (:(=), :r, (:call, :+, :xh, :yh)),
            (:line, 381, :none),
            (:(=), :s, (:if, (:call, :>, (:call, :abs, :xh), (:call, :abs, :yh)), (:call, :+, (:call, :-, :xh, :r), :yh, :yl, :xl), (:call, :+, (:call, :-, :yh, :r), :xh, :xl, :yl))),
            (:line, 382, :none),
            (:(=), :zh, (:call, :+, :r, :s)),
            (:line, 383, :none),
            (:return, :zh)
          )),
        (:line, 386, :none),
        (:function, (:call, :ieee754_rem_pio2, (:(::), :x, :Float64)), (:block,
            (:line, 400, :none),
            (:(=), :y, (:vect, 0.0, 0.0)),
            (:line, 401, :none),
            (:(=), :n, (:ccall, (:tuple, (:quote, #QuoteNode
                    :__ieee754_rem_pio2
                  ), :openspecfun), :Cint, (:tuple, :Float64, (:curly, :Ptr, :Float64)), :x, :y)),
            (:line, 402, :none),
            (:return, (:tuple, :n, :y))
          )),
        (:line, 406, :none),
        (:const, (:(=), :pi1o2_h, 1.5707963267948966)),
        (:line, 407, :none),
        (:const, (:(=), :pi1o2_l, 6.123233995736766e-17)),
        (:line, 409, :none),
        (:const, (:(=), :pi2o2_h, 3.141592653589793)),
        (:line, 410, :none),
        (:const, (:(=), :pi2o2_l, 1.2246467991473532e-16)),
        (:line, 412, :none),
        (:const, (:(=), :pi3o2_h, 4.71238898038469)),
        (:line, 413, :none),
        (:const, (:(=), :pi3o2_l, 1.8369701987210297e-16)),
        (:line, 415, :none),
        (:const, (:(=), :pi4o2_h, 6.283185307179586)),
        (:line, 416, :none),
        (:const, (:(=), :pi4o2_l, 2.4492935982947064e-16)),
        (:line, 418, :none),
        (:macrocall, :(Core.@doc), "    mod2pi(x)\n\nModulus after division by `2π`, returning in the range ``[0,2π)``.\n\nThis function computes a floating point representation of the modulus after division by\nnumerically exact `2π`, and is therefore not exactly the same as `mod(x,2π)`, which would\ncompute the modulus of `x` relative to division by the floating-point number `2π`.\n", (:function, (:call, :mod2pi, (:(::), :x, :Float64)), (:block,
              (:line, 435, :none),
              (:if, (:call, :<, :x, :pi4o2_h), (:block,
                  (:line, 436, :none),
                  (:if, (:call, :(<=), 0.0, :x), (:block,
                      (:line, 436, :none),
                      (:return, :x)
                    )),
                  (:line, 437, :none),
                  (:if, (:call, :>, :x, (:call, :-, :pi4o2_h)), (:block,
                      (:line, 438, :none),
                      (:return, (:call, :add22condh, :x, 0.0, :pi4o2_h, :pi4o2_l))
                    ))
                )),
              (:line, 442, :none),
              (:(=), (:tuple, :n, :y), (:call, :ieee754_rem_pio2, :x)),
              (:line, 444, :none),
              (:if, (:call, :iseven, :n), (:block,
                  (:line, 445, :none),
                  (:if, (:call, :(==), (:call, :&, :n, 2), 2), (:block,
                      (:line, 446, :none),
                      (:return, (:call, :add22condh, (:ref, :y, 1), (:ref, :y, 2), :pi2o2_h, :pi2o2_l))
                    ), (:block,
                      (:line, 448, :none),
                      (:if, (:call, :>, (:ref, :y, 1), 0.0), (:block,
                          (:line, 449, :none),
                          (:return, (:ref, :y, 1))
                        ), (:block,
                          (:line, 451, :none),
                          (:return, (:call, :add22condh, (:ref, :y, 1), (:ref, :y, 2), :pi4o2_h, :pi4o2_l))
                        ))
                    ))
                ), (:block,
                  (:line, 455, :none),
                  (:if, (:call, :(==), (:call, :&, :n, 2), 2), (:block,
                      (:line, 456, :none),
                      (:return, (:call, :add22condh, (:ref, :y, 1), (:ref, :y, 2), :pi3o2_h, :pi3o2_l))
                    ), (:block,
                      (:line, 458, :none),
                      (:return, (:call, :add22condh, (:ref, :y, 1), (:ref, :y, 2), :pi1o2_h, :pi1o2_l))
                    ))
                ))
            ))),
        (:line, 463, :none),
        (:(=), (:call, :mod2pi, (:(::), :x, :Float32)), (:block,
            (:line, 463, :none),
            (:call, :Float32, (:call, :mod2pi, (:call, :Float64, :x)))
          )),
        (:line, 464, :none),
        (:(=), (:call, :mod2pi, (:(::), :x, :Int32)), (:block,
            (:line, 464, :none),
            (:call, :mod2pi, (:call, :Float64, :x))
          )),
        (:line, 465, :none),
        (:function, (:call, :mod2pi, (:(::), :x, :Int64)), (:block,
            (:line, 466, :none),
            (:(=), :fx, (:call, :Float64, :x)),
            (:line, 467, :none),
            (:||, (:call, :(==), :fx, :x), (:call, :throw, (:call, :ArgumentError, (:string, "Int64 argument to mod2pi is too large: ", :x)))),
            (:line, 468, :none),
            (:call, :mod2pi, :fx)
          )),
        (:line, 472, :none),
        (:(=), (:call, :muladd, :x, :y, :z), (:block,
            (:line, 472, :none),
            (:call, :+, (:call, :*, :x, :y), :z)
          )),
        (:line, 476, :none),
        (:for, (:(=), :func, (:tuple, (:quote, #QuoteNode
                :sin
              ), (:quote, #QuoteNode
                :cos
              ), (:quote, #QuoteNode
                :tan
              ), (:quote, #QuoteNode
                :asin
              ), (:quote, #QuoteNode
                :acos
              ), (:quote, #QuoteNode
                :atan
              ), (:quote, #QuoteNode
                :sinh
              ), (:quote, #QuoteNode
                :cosh
              ), (:quote, #QuoteNode
                :tanh
              ), (:quote, #QuoteNode
                :asinh
              ), (:quote, #QuoteNode
                :acosh
              ), (:quote, #QuoteNode
                :atanh
              ), (:quote, #QuoteNode
                :exp
              ), (:quote, #QuoteNode
                :log
              ), (:quote, #QuoteNode
                :log2
              ), (:quote, #QuoteNode
                :log10
              ), (:quote, #QuoteNode
                :sqrt
              ), (:quote, #QuoteNode
                :lgamma
              ), (:quote, #QuoteNode
                :log1p
              ), (:quote, #QuoteNode
                :erf
              ), (:quote, #QuoteNode
                :erfc
              ))), (:block,
            (:line, 478, :none),
            (:macrocall, Symbol("@eval"), (:block,
                (:line, 479, :none),
                (:(=), (:call, (:$, :func), (:(::), :a, :Float16)), (:block,
                    (:line, 479, :none),
                    (:call, :Float16, (:call, (:$, :func), (:call, :Float32, :a)))
                  )),
                (:line, 480, :none),
                (:(=), (:call, (:$, :func), (:(::), :a, :Complex32)), (:block,
                    (:line, 480, :none),
                    (:call, :Complex32, (:call, (:$, :func), (:call, :Complex64, :a)))
                  ))
              ))
          )),
        (:line, 484, :none),
        (:for, (:(=), :func, (:tuple, (:quote, #QuoteNode
                :atan2
              ), (:quote, #QuoteNode
                :hypot
              ))), (:block,
            (:line, 485, :none),
            (:macrocall, Symbol("@eval"), (:block,
                (:line, 486, :none),
                (:(=), (:call, (:$, :func), (:(::), :a, :Float16), (:(::), :b, :Float16)), (:block,
                    (:line, 486, :none),
                    (:call, :Float16, (:call, (:$, :func), (:call, :Float32, :a), (:call, :Float32, :b)))
                  ))
              ))
          )),
        (:line, 490, :none),
        (:(=), (:call, :ldexp, (:(::), :a, :Float16), (:(::), :b, :Integer)), (:block,
            (:line, 490, :none),
            (:call, :Float16, (:call, :ldexp, (:call, :Float32, :a), :b))
          )),
        (:line, 493, :none),
        (:call, :include, "special/trig.jl"),
        (:line, 494, :none),
        (:call, :include, "special/bessel.jl"),
        (:line, 495, :none),
        (:call, :include, "special/erf.jl"),
        (:line, 496, :none),
        (:call, :include, "special/gamma.jl"),
        (:line, 498, :none),
        (:module, true, :JuliaLibm, (:block,
            (:line, 498, :none),
            (:line, 499, :none),
            (:call, :include, "special/log.jl")
          ))
      ))
  ))