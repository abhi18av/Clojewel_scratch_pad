(:quote, (:block,
    (:line, 7, :none),
    (:if, (:call, :(===), :Int, :Int32), (:block,
        (:line, 8, :none),
        (:typealias, :SmallSigned, (:curly, :Union, :Int8, :Int16)),
        (:line, 9, :none),
        (:typealias, :SmallUnsigned, (:curly, :Union, :UInt8, :UInt16))
      ), (:block,
        (:line, 11, :none),
        (:typealias, :SmallSigned, (:curly, :Union, :Int8, :Int16, :Int32)),
        (:line, 12, :none),
        (:typealias, :SmallUnsigned, (:curly, :Union, :UInt8, :UInt16, :UInt32))
      )),
    (:line, 15, :none),
    (:typealias, :CommonReduceResult, (:curly, :Union, :UInt64, :UInt128, :Int64, :Int128, :Float32, :Float64)),
    (:line, 16, :none),
    (:typealias, :WidenReduceResult, (:curly, :Union, :SmallSigned, :SmallUnsigned, :Float16)),
    (:line, 19, :none),
    (:(=), (:call, :r_promote, :op, (:(::), :x, :WidenReduceResult)), (:block,
        (:line, 19, :none),
        (:call, :widen, :x)
      )),
    (:line, 20, :none),
    (:(=), (:call, :r_promote, :op, :x), (:block,
        (:line, 20, :none),
        :x
      )),
    (:line, 21, :none),
    (:(=), (:call, :r_promote, (:(::), (:call, :typeof, :+)), (:(::), :x, :WidenReduceResult)), (:block,
        (:line, 21, :none),
        (:call, :widen, :x)
      )),
    (:line, 22, :none),
    (:(=), (:call, :r_promote, (:(::), (:call, :typeof, :*)), (:(::), :x, :WidenReduceResult)), (:block,
        (:line, 22, :none),
        (:call, :widen, :x)
      )),
    (:line, 23, :none),
    (:(=), (:call, :r_promote, (:(::), (:call, :typeof, :+)), (:(::), :x, :Number)), (:block,
        (:line, 23, :none),
        (:call, :oftype, (:call, :+, :x, (:call, :zero, :x)), :x)
      )),
    (:line, 24, :none),
    (:(=), (:call, :r_promote, (:(::), (:call, :typeof, :*)), (:(::), :x, :Number)), (:block,
        (:line, 24, :none),
        (:call, :oftype, (:call, :*, :x, (:call, :one, :x)), :x)
      )),
    (:line, 25, :none),
    (:(=), (:call, :r_promote, (:(::), (:call, :typeof, :+)), :x), (:block,
        (:line, 25, :none),
        :x
      )),
    (:line, 26, :none),
    (:(=), (:call, :r_promote, (:(::), (:call, :typeof, :*)), :x), (:block,
        (:line, 26, :none),
        :x
      )),
    (:line, 27, :none),
    (:(=), (:call, :r_promote, (:(::), (:call, :typeof, :scalarmax)), (:(::), :x, :WidenReduceResult)), (:block,
        (:line, 27, :none),
        :x
      )),
    (:line, 28, :none),
    (:(=), (:call, :r_promote, (:(::), (:call, :typeof, :scalarmin)), (:(::), :x, :WidenReduceResult)), (:block,
        (:line, 28, :none),
        :x
      )),
    (:line, 29, :none),
    (:(=), (:call, :r_promote, (:(::), (:call, :typeof, :scalarmax)), :x), (:block,
        (:line, 29, :none),
        :x
      )),
    (:line, 30, :none),
    (:(=), (:call, :r_promote, (:(::), (:call, :typeof, :scalarmin)), :x), (:block,
        (:line, 30, :none),
        :x
      )),
    (:line, 31, :none),
    (:(=), (:call, :r_promote, (:(::), (:call, :typeof, :max)), (:(::), :x, :WidenReduceResult)), (:block,
        (:line, 31, :none),
        (:call, :r_promote, :scalarmax, :x)
      )),
    (:line, 32, :none),
    (:(=), (:call, :r_promote, (:(::), (:call, :typeof, :min)), (:(::), :x, :WidenReduceResult)), (:block,
        (:line, 32, :none),
        (:call, :r_promote, :scalarmin, :x)
      )),
    (:line, 33, :none),
    (:(=), (:call, :r_promote, (:(::), (:call, :typeof, :max)), :x), (:block,
        (:line, 33, :none),
        (:call, :r_promote, :scalarmax, :x)
      )),
    (:line, 34, :none),
    (:(=), (:call, :r_promote, (:(::), (:call, :typeof, :min)), :x), (:block,
        (:line, 34, :none),
        (:call, :r_promote, :scalarmin, :x)
      )),
    (:line, 39, :none),
    (:function, (:call, :mapfoldl_impl, :f, :op, :v0, :itr, :i), (:block,
        (:line, 42, :none),
        (:if, (:call, :done, :itr, :i), (:block,
            (:line, 43, :none),
            (:return, (:call, :r_promote, :op, :v0))
          ), (:block,
            (:line, 45, :none),
            (:(=), (:tuple, :x, :i), (:call, :next, :itr, :i)),
            (:line, 46, :none),
            (:(=), :v, (:call, :op, (:call, :r_promote, :op, :v0), (:call, :f, :x))),
            (:line, 47, :none),
            (:while, (:call, :!, (:call, :done, :itr, :i)), (:block,
                (:line, 48, :none),
                (:macrocall, Symbol("@inbounds"), (:(=), (:tuple, :x, :i), (:call, :next, :itr, :i))),
                (:line, 49, :none),
                (:(=), :v, (:call, :op, :v, (:call, :f, :x)))
              )),
            (:line, 51, :none),
            (:return, :v)
          ))
      )),
    (:line, 55, :none),
    (:(=), (:call, :mapfoldl, :f, :op, :v0, :itr), (:block,
        (:line, 55, :none),
        (:call, :mapfoldl_impl, :f, :op, :v0, :itr, (:call, :start, :itr))
      )),
    (:line, 57, :none),
    (:function, (:call, :mapfoldl, :f, :op, :itr), (:block,
        (:line, 58, :none),
        (:(=), :i, (:call, :start, :itr)),
        (:line, 59, :none),
        (:if, (:call, :done, :itr, :i), (:block,
            (:line, 60, :none),
            (:return, (:call, (:., :Base, (:quote, #QuoteNode
                    :mr_empty_iter
                  )), :f, :op, :itr, (:call, :iteratoreltype, :itr)))
          )),
        (:line, 62, :none),
        (:(=), (:tuple, :x, :i), (:call, :next, :itr, :i)),
        (:line, 63, :none),
        (:(=), :v0, (:call, :f, :x)),
        (:line, 64, :none),
        (:call, :mapfoldl_impl, :f, :op, :v0, :itr, :i)
      )),
    (:line, 67, :none),
    (:(=), (:call, :foldl, :op, :v0, :itr), (:block,
        (:line, 67, :none),
        (:call, :mapfoldl, :identity, :op, :v0, :itr)
      )),
    (:line, 68, :none),
    (:(=), (:call, :foldl, :op, :itr), (:block,
        (:line, 68, :none),
        (:call, :mapfoldl, :identity, :op, :itr)
      )),
    (:line, 72, :none),
    (:function, (:call, :mapfoldr_impl, :f, :op, :v0, :itr, (:(::), :i, :Integer)), (:block,
        (:line, 75, :none),
        (:if, (:call, :(==), :i, 0), (:block,
            (:line, 76, :none),
            (:return, (:call, :r_promote, :op, :v0))
          ), (:block,
            (:line, 78, :none),
            (:(=), :x, (:ref, :itr, :i)),
            (:line, 79, :none),
            (:(=), :v, (:call, :op, (:call, :f, :x), (:call, :r_promote, :op, :v0))),
            (:line, 80, :none),
            (:while, (:call, :>, :i, 1), (:block,
                (:line, 81, :none),
                (:(=), :x, (:ref, :itr, (:-=, :i, 1))),
                (:line, 82, :none),
                (:(=), :v, (:call, :op, (:call, :f, :x), :v))
              )),
            (:line, 84, :none),
            (:return, :v)
          ))
      )),
    (:line, 88, :none),
    (:(=), (:call, :mapfoldr, :f, :op, :v0, :itr), (:block,
        (:line, 88, :none),
        (:call, :mapfoldr_impl, :f, :op, :v0, :itr, (:call, :endof, :itr))
      )),
    (:line, 89, :none),
    (:(=), (:call, :mapfoldr, :f, :op, :itr), (:block,
        (:line, 89, :none),
        (:block,
          (:(=), :i, (:call, :endof, :itr)),
          (:call, :mapfoldr_impl, :f, :op, (:call, :f, (:ref, :itr, :i)), :itr, (:call, :-, :i, 1))
        )
      )),
    (:line, 91, :none),
    (:(=), (:call, :foldr, :op, :v0, :itr), (:block,
        (:line, 91, :none),
        (:call, :mapfoldr, :identity, :op, :v0, :itr)
      )),
    (:line, 92, :none),
    (:(=), (:call, :foldr, :op, :itr), (:block,
        (:line, 92, :none),
        (:call, :mapfoldr, :identity, :op, :itr)
      )),
    (:line, 103, :none),
    (:function, (:call, :mapreduce_impl, :f, :op, (:(::), :A, :AbstractArray), (:(::), :ifirst, :Integer), (:(::), :ilast, :Integer), (:kw, (:(::), :blksize, :Int), (:call, :pairwise_blocksize, :f, :op))), (:block,
        (:line, 104, :none),
        (:if, (:call, :(==), :ifirst, :ilast), (:block,
            (:line, 105, :none),
            (:macrocall, Symbol("@inbounds"), (:(=), :a1, (:ref, :A, :ifirst))),
            (:line, 106, :none),
            (:return, (:call, :r_promote, :op, (:call, :f, :a1)))
          ), (:block,
            (:line, 107, :none),
            (:if, (:call, :>, (:call, :+, :ifirst, :blksize), :ilast), (:block,
                (:line, 109, :none),
                (:macrocall, Symbol("@inbounds"), (:(=), :a1, (:ref, :A, :ifirst))),
                (:line, 110, :none),
                (:macrocall, Symbol("@inbounds"), (:(=), :a2, (:ref, :A, (:call, :+, :ifirst, 1)))),
                (:line, 111, :none),
                (:(=), :v, (:call, :op, (:call, :r_promote, :op, (:call, :f, :a1)), (:call, :r_promote, :op, (:call, :f, :a2)))),
                (:line, 112, :none),
                (:macrocall, Symbol("@simd"), (:for, (:(=), :i, (:(:), (:call, :+, :ifirst, 2), :ilast)), (:block,
                      (:line, 113, :none),
                      (:macrocall, Symbol("@inbounds"), (:(=), :ai, (:ref, :A, :i))),
                      (:line, 114, :none),
                      (:(=), :v, (:call, :op, :v, (:call, :f, :ai)))
                    ))),
                (:line, 116, :none),
                (:return, :v)
              ), (:block,
                (:line, 119, :none),
                (:(=), :imid, (:call, :>>, (:call, :+, :ifirst, :ilast), 1)),
                (:line, 120, :none),
                (:(=), :v1, (:call, :mapreduce_impl, :f, :op, :A, :ifirst, :imid, :blksize)),
                (:line, 121, :none),
                (:(=), :v2, (:call, :mapreduce_impl, :f, :op, :A, (:call, :+, :imid, 1), :ilast, :blksize)),
                (:line, 122, :none),
                (:return, (:call, :op, :v1, :v2))
              ))
          ))
      )),
    (:line, 126, :none),
    (:(=), (:call, :mapreduce, :f, :op, :itr), (:block,
        (:line, 126, :none),
        (:call, :mapfoldl, :f, :op, :itr)
      )),
    (:line, 127, :none),
    (:(=), (:call, :mapreduce, :f, :op, :v0, :itr), (:block,
        (:line, 127, :none),
        (:call, :mapfoldl, :f, :op, :v0, :itr)
      )),
    (:line, 131, :none),
    (:(=), (:call, :pairwise_blocksize, :f, :op), (:block,
        (:line, 131, :none),
        1024
      )),
    (:line, 134, :none),
    (:(=), (:call, :pairwise_blocksize, (:(::), (:call, :typeof, :abs2)), (:(::), (:call, :typeof, :+))), (:block,
        (:line, 134, :none),
        4096
      )),
    (:line, 138, :none),
    (:(=), (:call, :_empty_reduce_error), (:block,
        (:line, 138, :none),
        (:call, :throw, (:call, :ArgumentError, "reducing over an empty collection is not allowed"))
      )),
    (:line, 139, :none),
    (:(=), (:call, :mr_empty, :f, :op, :T), (:block,
        (:line, 139, :none),
        (:call, :_empty_reduce_error)
      )),
    (:line, 141, :none),
    (:(=), (:call, :mr_empty, (:(::), (:call, :typeof, :identity)), (:(::), :op, (:call, :typeof, :+)), :T), (:block,
        (:line, 141, :none),
        (:call, :r_promote, :op, (:(::), (:call, :zero, :T), :T))
      )),
    (:line, 142, :none),
    (:(=), (:call, :mr_empty, (:(::), (:call, :typeof, :abs)), (:(::), :op, (:call, :typeof, :+)), :T), (:block,
        (:line, 142, :none),
        (:call, :r_promote, :op, (:call, :abs, (:(::), (:call, :zero, :T), :T)))
      )),
    (:line, 143, :none),
    (:(=), (:call, :mr_empty, (:(::), (:call, :typeof, :abs2)), (:(::), :op, (:call, :typeof, :+)), :T), (:block,
        (:line, 143, :none),
        (:call, :r_promote, :op, (:call, :abs2, (:(::), (:call, :zero, :T), :T)))
      )),
    (:line, 144, :none),
    (:(=), (:call, :mr_empty, (:(::), (:call, :typeof, :identity)), (:(::), :op, (:call, :typeof, :*)), :T), (:block,
        (:line, 144, :none),
        (:call, :r_promote, :op, (:(::), (:call, :one, :T), :T))
      )),
    (:line, 145, :none),
    (:(=), (:call, :mr_empty, (:(::), (:call, :typeof, :abs)), (:(::), :op, (:call, :typeof, :scalarmax)), :T), (:block,
        (:line, 145, :none),
        (:call, :abs, (:(::), (:call, :zero, :T), :T))
      )),
    (:line, 146, :none),
    (:(=), (:call, :mr_empty, (:(::), (:call, :typeof, :abs2)), (:(::), :op, (:call, :typeof, :scalarmax)), :T), (:block,
        (:line, 146, :none),
        (:call, :abs2, (:(::), (:call, :zero, :T), :T))
      )),
    (:line, 147, :none),
    (:(=), (:call, :mr_empty, (:(::), (:call, :typeof, :abs)), (:(::), :op, (:call, :typeof, :max)), :T), (:block,
        (:line, 147, :none),
        (:call, :mr_empty, :abs, :scalarmax, :T)
      )),
    (:line, 148, :none),
    (:(=), (:call, :mr_empty, (:(::), (:call, :typeof, :abs2)), (:(::), :op, (:call, :typeof, :max)), :T), (:block,
        (:line, 148, :none),
        (:call, :mr_empty, :abs2, :scalarmax, :T)
      )),
    (:line, 149, :none),
    (:(=), (:call, :mr_empty, :f, (:(::), :op, (:call, :typeof, :&)), :T), (:block,
        (:line, 149, :none),
        true
      )),
    (:line, 150, :none),
    (:(=), (:call, :mr_empty, :f, (:(::), :op, (:call, :typeof, :|)), :T), (:block,
        (:line, 150, :none),
        false
      )),
    (:line, 152, :none),
    (:(=), (:call, :mr_empty_iter, :f, :op, :itr, (:(::), :HasEltype)), (:block,
        (:line, 152, :none),
        (:call, :mr_empty, :f, :op, (:call, :eltype, :itr))
      )),
    (:line, 153, :none),
    (:(=), (:call, :mr_empty_iter, :f, (:(::), :op, (:call, :typeof, :&)), :itr, (:(::), :EltypeUnknown)), (:block,
        (:line, 153, :none),
        true
      )),
    (:line, 154, :none),
    (:(=), (:call, :mr_empty_iter, :f, (:(::), :op, (:call, :typeof, :|)), :itr, (:(::), :EltypeUnknown)), (:block,
        (:line, 154, :none),
        false
      )),
    (:line, 155, :none),
    (:(=), (:call, :mr_empty_iter, :f, :op, :itr, (:(::), :EltypeUnknown)), (:block,
        (:line, 155, :none),
        (:call, :_empty_reduce_error)
      )),
    (:line, 157, :none),
    (:(=), (:call, :_mapreduce, :f, :op, (:(::), :A, :AbstractArray)), (:block,
        (:line, 157, :none),
        (:call, :_mapreduce, :f, :op, (:call, :linearindexing, :A), :A)
      )),
    (:line, 159, :none),
    (:function, (:call, (:curly, :_mapreduce, :T), :f, :op, (:(::), :LinearFast), (:(::), :A, (:curly, :AbstractArray, :T))), (:block,
        (:line, 160, :none),
        (:(=), :inds, (:call, :linearindices, :A)),
        (:line, 161, :none),
        (:(=), :n, (:call, :length, :inds)),
        (:line, 162, :none),
        (:if, (:call, :(==), :n, 0), (:block,
            (:line, 163, :none),
            (:return, (:call, :mr_empty, :f, :op, :T))
          ), (:block,
            (:line, 164, :none),
            (:if, (:call, :(==), :n, 1), (:block,
                (:line, 165, :none),
                (:macrocall, Symbol("@inbounds"), (:(=), :a1, (:ref, :A, (:ref, :inds, 1)))),
                (:line, 166, :none),
                (:return, (:call, :r_promote, :op, (:call, :f, :a1)))
              ), (:block,
                (:line, 167, :none),
                (:if, (:call, :<, :n, 16), (:block,
                    (:line, 168, :none),
                    (:macrocall, Symbol("@inbounds"), (:(=), :i, (:ref, :inds, 1))),
                    (:line, 169, :none),
                    (:macrocall, Symbol("@inbounds"), (:(=), :a1, (:ref, :A, :i))),
                    (:line, 170, :none),
                    (:macrocall, Symbol("@inbounds"), (:(=), :a2, (:ref, :A, (:+=, :i, 1)))),
                    (:line, 171, :none),
                    (:(=), :s, (:call, :op, (:call, :r_promote, :op, (:call, :f, :a1)), (:call, :r_promote, :op, (:call, :f, :a2)))),
                    (:line, 172, :none),
                    (:while, (:call, :<, :i, (:call, :last, :inds)), (:block,
                        (:line, 173, :none),
                        (:macrocall, Symbol("@inbounds"), (:(=), :Ai, (:ref, :A, (:+=, :i, 1)))),
                        (:line, 174, :none),
                        (:(=), :s, (:call, :op, :s, (:call, :f, :Ai)))
                      )),
                    (:line, 176, :none),
                    (:return, :s)
                  ), (:block,
                    (:line, 178, :none),
                    (:return, (:call, :mapreduce_impl, :f, :op, :A, (:call, :first, :inds), (:call, :last, :inds)))
                  ))
              ))
          ))
      )),
    (:line, 182, :none),
    (:(=), (:call, (:curly, :_mapreduce, :T), :f, :op, (:(::), :LinearSlow), (:(::), :A, (:curly, :AbstractArray, :T))), (:block,
        (:line, 182, :none),
        (:call, :mapfoldl, :f, :op, :A)
      )),
    (:line, 184, :none),
    (:(=), (:call, :mapreduce, :f, :op, (:(::), :A, :AbstractArray)), (:block,
        (:line, 184, :none),
        (:call, :_mapreduce, :f, :op, (:call, :linearindexing, :A), :A)
      )),
    (:line, 185, :none),
    (:(=), (:call, :mapreduce, :f, :op, (:(::), :a, :Number)), (:block,
        (:line, 185, :none),
        (:call, :f, :a)
      )),
    (:line, 187, :none),
    (:(=), (:call, :reduce, :op, :v0, :itr), (:block,
        (:line, 187, :none),
        (:call, :mapreduce, :identity, :op, :v0, :itr)
      )),
    (:line, 188, :none),
    (:(=), (:call, :reduce, :op, :itr), (:block,
        (:line, 188, :none),
        (:call, :mapreduce, :identity, :op, :itr)
      )),
    (:line, 189, :none),
    (:(=), (:call, :reduce, :op, (:(::), :a, :Number)), (:block,
        (:line, 189, :none),
        :a
      )),
    (:line, 195, :none),
    (:type, false, (:curly, :Predicate, :F), (:block,
        (:line, 196, :none),
        (:(::), :f, :F)
      )),
    (:line, 198, :none),
    (:(=), (:call, (:(::), :pred, :Predicate), :x), (:block,
        (:line, 198, :none),
        (:(::), (:call, (:., :pred, (:quote, #QuoteNode
                :f
              )), :x), :Bool)
      )),
    (:line, 200, :none),
    (:const, (:(=), :ShortCircuiting, (:curly, :Union, (:call, :typeof, :&), (:call, :typeof, :|)))),
    (:line, 204, :none),
    (:function, (:call, :mapreduce_sc_impl, :f, (:(::), :op, (:call, :typeof, :&)), :itr), (:block,
        (:line, 205, :none),
        (:for, (:(=), :x, :itr), (:block,
            (:line, 206, :none),
            (:||, (:call, :f, :x), (:return, false))
          )),
        (:line, 208, :none),
        (:return, true)
      )),
    (:line, 211, :none),
    (:function, (:call, :mapreduce_sc_impl, :f, (:(::), :op, (:call, :typeof, :|)), :itr), (:block,
        (:line, 212, :none),
        (:for, (:(=), :x, :itr), (:block,
            (:line, 213, :none),
            (:&&, (:call, :f, :x), (:return, true))
          )),
        (:line, 215, :none),
        (:return, false)
      )),
    (:line, 223, :none),
    (:(=), (:call, :mapreduce_no_sc, :f, :op, (:(::), :itr, :Any)), (:block,
        (:line, 223, :none),
        (:call, :mapfoldl, :f, :op, :itr)
      )),
    (:line, 224, :none),
    (:(=), (:call, :mapreduce_no_sc, :f, :op, (:(::), :itr, :AbstractArray)), (:block,
        (:line, 224, :none),
        (:call, :_mapreduce, :f, :op, :itr)
      )),
    (:line, 226, :none),
    (:(=), (:call, :mapreduce_sc, (:(::), :f, :Function), :op, :itr), (:block,
        (:line, 226, :none),
        (:call, :mapreduce_no_sc, :f, :op, :itr)
      )),
    (:line, 227, :none),
    (:(=), (:call, :mapreduce_sc, (:(::), :f, :Predicate), :op, :itr), (:block,
        (:line, 227, :none),
        (:call, :mapreduce_sc_impl, :f, :op, :itr)
      )),
    (:line, 229, :none),
    (:(=), (:call, :mapreduce_sc, (:(::), :f, (:call, :typeof, :identity)), :op, :itr), (:block,
        (:line, 229, :none),
        (:if, (:<:, (:call, :eltype, :itr), :Bool), (:call, :mapreduce_sc_impl, :f, :op, :itr), (:call, :mapreduce_no_sc, :f, :op, :itr))
      )),
    (:line, 234, :none),
    (:(=), (:call, :mapreduce, :f, (:(::), :op, :ShortCircuiting), (:(::), :n, :Number)), (:block,
        (:line, 234, :none),
        :n
      )),
    (:line, 235, :none),
    (:(=), (:call, :mapreduce, :f, (:(::), :op, :ShortCircuiting), (:(::), :itr, :AbstractArray)), (:block,
        (:line, 235, :none),
        (:call, :mapreduce_sc, :f, :op, :itr)
      )),
    (:line, 236, :none),
    (:(=), (:call, :mapreduce, :f, (:(::), :op, :ShortCircuiting), (:(::), :itr, :Any)), (:block,
        (:line, 236, :none),
        (:call, :mapreduce_sc, :f, :op, :itr)
      )),
    (:line, 243, :none),
    (:(=), (:call, :sum, (:(::), :f, :Callable), :a), (:block,
        (:line, 243, :none),
        (:call, :mapreduce, :f, :+, :a)
      )),
    (:line, 244, :none),
    (:(=), (:call, :sum, :a), (:block,
        (:line, 244, :none),
        (:call, :mapreduce, :identity, :+, :a)
      )),
    (:line, 245, :none),
    (:(=), (:call, :sum, (:(::), :a, (:curly, :AbstractArray, :Bool))), (:block,
        (:line, 245, :none),
        (:call, :countnz, :a)
      )),
    (:line, 246, :none),
    (:(=), (:call, :sumabs, :a), (:block,
        (:line, 246, :none),
        (:call, :mapreduce, :abs, :+, :a)
      )),
    (:line, 247, :none),
    (:(=), (:call, :sumabs2, :a), (:block,
        (:line, 247, :none),
        (:call, :mapreduce, :abs2, :+, :a)
      )),
    (:line, 251, :none),
    (:function, (:call, (:curly, :sum_kbn, (:<:, :T, :AbstractFloat)), (:(::), :A, (:curly, :AbstractArray, :T))), (:block,
        (:line, 252, :none),
        (:(=), :c, (:call, :r_promote, :+, (:(::), (:call, :zero, :T), :T))),
        (:line, 253, :none),
        (:if, (:call, :isempty, :A), (:block,
            (:line, 254, :none),
            (:return, :c)
          )),
        (:line, 256, :none),
        (:(=), :inds, (:call, :linearindices, :A)),
        (:line, 257, :none),
        (:(=), :s, (:call, :+, (:ref, :A, (:call, :first, :inds)), :c)),
        (:line, 258, :none),
        (:for, (:(=), :i, (:(:), (:call, :+, (:call, :first, :inds), 1), (:call, :last, :inds))), (:block,
            (:line, 259, :none),
            (:macrocall, Symbol("@inbounds"), (:(=), :Ai, (:ref, :A, :i))),
            (:line, 260, :none),
            (:(=), :t, (:call, :+, :s, :Ai)),
            (:line, 261, :none),
            (:if, (:call, :(>=), (:call, :abs, :s), (:call, :abs, :Ai)), (:block,
                (:line, 262, :none),
                (:+=, :c, (:call, :+, (:call, :-, :s, :t), :Ai))
              ), (:block,
                (:line, 264, :none),
                (:+=, :c, (:call, :+, (:call, :-, :Ai, :t), :s))
              )),
            (:line, 266, :none),
            (:(=), :s, :t)
          )),
        (:line, 268, :none),
        (:call, :+, :s, :c)
      )),
    (:line, 274, :none),
    (:(=), (:call, :prod, (:(::), :f, :Callable), :a), (:block,
        (:line, 274, :none),
        (:call, :mapreduce, :f, :*, :a)
      )),
    (:line, 275, :none),
    (:(=), (:call, :prod, :a), (:block,
        (:line, 275, :none),
        (:call, :mapreduce, :identity, :*, :a)
      )),
    (:line, 279, :none),
    (:function, (:call, :mapreduce_impl, :f, (:(::), :op, (:curly, :Union, (:call, :typeof, :scalarmax), (:call, :typeof, :scalarmin), (:call, :typeof, :max), (:call, :typeof, :min))), (:(::), :A, :AbstractArray), (:(::), :first, :Int), (:(::), :last, :Int)), (:block,
        (:line, 285, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :a1, (:ref, :A, :first))),
        (:line, 286, :none),
        (:(=), :v, (:call, :f, :a1)),
        (:line, 287, :none),
        (:(=), :i, (:call, :+, :first, 1)),
        (:line, 288, :none),
        (:while, (:&&, (:call, :(!=), :v, :v), (:call, :(<=), :i, :last)), (:block,
            (:line, 289, :none),
            (:macrocall, Symbol("@inbounds"), (:(=), :ai, (:ref, :A, :i))),
            (:line, 290, :none),
            (:(=), :v, (:call, :f, :ai)),
            (:line, 291, :none),
            (:+=, :i, 1)
          )),
        (:line, 293, :none),
        (:while, (:call, :(<=), :i, :last), (:block,
            (:line, 294, :none),
            (:macrocall, Symbol("@inbounds"), (:(=), :ai, (:ref, :A, :i))),
            (:line, 295, :none),
            (:(=), :v, (:call, :op, :v, (:call, :f, :ai))),
            (:line, 296, :none),
            (:+=, :i, 1)
          )),
        (:line, 298, :none),
        :v
      )),
    (:line, 301, :none),
    (:(=), (:call, :maximum, (:(::), :f, :Callable), :a), (:block,
        (:line, 301, :none),
        (:call, :mapreduce, :f, :scalarmax, :a)
      )),
    (:line, 302, :none),
    (:(=), (:call, :minimum, (:(::), :f, :Callable), :a), (:block,
        (:line, 302, :none),
        (:call, :mapreduce, :f, :scalarmin, :a)
      )),
    (:line, 304, :none),
    "    maximum(itr)\n\nReturns the largest element in a collection.\n\n```jldoctest\njulia> maximum(-20.5:10)\n9.5\n\njulia> maximum([1,2,3])\n3\n```\n",
    (:line, 317, :none),
    (:(=), (:call, :maximum, :a), (:block,
        (:line, 317, :none),
        (:call, :mapreduce, :identity, :scalarmax, :a)
      )),
    (:line, 319, :none),
    "    minimum(itr)\n\nReturns the smallest element in a collection.\n\n```jldoctest\njulia> minimum(-20.5:10)\n-20.5\n\njulia> minimum([1,2,3])\n1\n```\n",
    (:line, 332, :none),
    (:(=), (:call, :minimum, :a), (:block,
        (:line, 332, :none),
        (:call, :mapreduce, :identity, :scalarmin, :a)
      )),
    (:line, 334, :none),
    "    maxabs(itr)\n\nCompute the maximum absolute value of a collection of values.\n\n```jldoctest\njulia> maxabs([-1, 3, 4*im])\n4.0\n```\n",
    (:line, 344, :none),
    (:(=), (:call, :maxabs, :a), (:block,
        (:line, 344, :none),
        (:call, :mapreduce, :abs, :scalarmax, :a)
      )),
    (:line, 346, :none),
    "    minabs(itr)\n\nCompute the minimum absolute value of a collection of values.\n\n```jldoctest\njulia> minabs([-1, 3, 4*im])\n1.0\n```\n",
    (:line, 356, :none),
    (:(=), (:call, :minabs, :a), (:block,
        (:line, 356, :none),
        (:call, :mapreduce, :abs, :scalarmin, :a)
      )),
    (:line, 360, :none),
    (:(=), (:call, :extrema, (:(::), :r, :Range)), (:block,
        (:line, 360, :none),
        (:tuple, (:call, :minimum, :r), (:call, :maximum, :r))
      )),
    (:line, 361, :none),
    (:(=), (:call, :extrema, (:(::), :x, :Real)), (:block,
        (:line, 361, :none),
        (:tuple, :x, :x)
      )),
    (:line, 363, :none),
    "    extrema(itr) -> Tuple\n\nCompute both the minimum and maximum element in a single pass, and return them as a 2-tuple.\n\n```jldoctest\njulia> extrema(2:10)\n(2,10)\n\njulia> extrema([9,pi,4.5])\n(3.141592653589793,9.0)\n```\n",
    (:line, 376, :none),
    (:function, (:call, :extrema, :itr), (:block,
        (:line, 377, :none),
        (:(=), :s, (:call, :start, :itr)),
        (:line, 378, :none),
        (:&&, (:call, :done, :itr, :s), (:call, :throw, (:call, :ArgumentError, "collection must be non-empty"))),
        (:line, 379, :none),
        (:(=), (:tuple, :v, :s), (:call, :next, :itr, :s)),
        (:line, 380, :none),
        (:while, (:&&, (:call, :(!=), :v, :v), (:call, :!, (:call, :done, :itr, :s))), (:block,
            (:line, 381, :none),
            (:(=), (:tuple, :x, :s), (:call, :next, :itr, :s)),
            (:line, 382, :none),
            (:(=), :v, :x)
          )),
        (:line, 384, :none),
        (:(=), :vmin, :v),
        (:line, 385, :none),
        (:(=), :vmax, :v),
        (:line, 386, :none),
        (:while, (:call, :!, (:call, :done, :itr, :s)), (:block,
            (:line, 387, :none),
            (:(=), (:tuple, :x, :s), (:call, :next, :itr, :s)),
            (:line, 388, :none),
            (:if, (:call, :>, :x, :vmax), (:block,
                (:line, 389, :none),
                (:(=), :vmax, :x)
              ), (:block,
                (:line, 390, :none),
                (:if, (:call, :<, :x, :vmin), (:block,
                    (:line, 391, :none),
                    (:(=), :vmin, :x)
                  ))
              ))
          )),
        (:line, 394, :none),
        (:return, (:tuple, :vmin, :vmax))
      )),
    (:line, 397, :none),
    "    extrema(A,dims) -> Array{Tuple}\n\nCompute the minimum and maximum elements of an array over the given dimensions.\n",
    (:line, 402, :none),
    (:function, (:call, :extrema, (:(::), :A, :AbstractArray), :dims), (:block,
        (:line, 403, :none),
        (:(=), :sz, (:vect, (:..., (:call, :size, :A)))),
        (:line, 404, :none),
        (:(=), (:ref, :sz, (:vect, (:..., :dims))), 1),
        (:line, 405, :none),
        (:(=), :B, (:call, (:curly, :Array, (:curly, :Tuple, (:call, :eltype, :A), (:call, :eltype, :A))), (:..., :sz))),
        (:line, 406, :none),
        (:call, :extrema!, :B, :A)
      )),
    (:line, 409, :none),
    (:macrocall, Symbol("@generated"), (:function, (:call, (:curly, :extrema!, :T, :N), :B, (:(::), :A, (:curly, :AbstractArray, :T, :N))), (:block,
          (:line, 410, :none),
          (:quote, (:block,
              (:line, 411, :none),
              (:(=), :sA, (:call, :size, :A)),
              (:line, 412, :none),
              (:(=), :sB, (:call, :size, :B)),
              (:line, 413, :none),
              (:macrocall, Symbol("@nloops"), (:$, :N), :i, :B, (:block,
                  (:line, 414, :none),
                  (:(=), :AI, (:macrocall, Symbol("@nref"), (:$, :N), :A, :i)),
                  (:line, 415, :none),
                  (:(=), (:macrocall, Symbol("@nref"), (:$, :N), :B, :i), (:tuple, :AI, :AI))
                )),
              (:line, 417, :none),
              (:(=), :Bmax, :sB),
              (:line, 418, :none),
              (:(=), :Istart, (:call, :ones, :Int, (:call, :ndims, :A))),
              (:line, 419, :none),
              (:(=), (:ref, :Istart, (:call, :&, (:call, :.==, (:vect, (:..., :sB)), 1), (:call, :.!=, (:vect, (:..., :sA)), 1))), 2),
              (:line, 420, :none),
              (:macrocall, Symbol("@inbounds"), (:macrocall, Symbol("@nloops"), (:$, :N), :i, (:->, :d, (:block,
                      (:line, 420, :none),
                      (:(:), (:ref, :Istart, :d), (:call, :size, :A, :d))
                    )), (:block,
                    (:line, 421, :none),
                    (:(=), :AI, (:macrocall, Symbol("@nref"), (:$, :N), :A, :i)),
                    (:line, 422, :none),
                    (:macrocall, Symbol("@nexprs"), (:$, :N), (:->, :d, (:block,
                          (:line, 422, :none),
                          (:(=), :j_d, (:call, :min, (:ref, :Bmax, :d), (:curly, :i_, :d)))
                        ))),
                    (:line, 423, :none),
                    (:(=), :BJ, (:macrocall, Symbol("@nref"), (:$, :N), :B, :j)),
                    (:line, 424, :none),
                    (:if, (:call, :<, :AI, (:ref, :BJ, 1)), (:block,
                        (:line, 425, :none),
                        (:(=), (:macrocall, Symbol("@nref"), (:$, :N), :B, :j), (:tuple, :AI, (:ref, :BJ, 2)))
                      ), (:block,
                        (:line, 426, :none),
                        (:if, (:call, :>, :AI, (:ref, :BJ, 2)), (:block,
                            (:line, 427, :none),
                            (:(=), (:macrocall, Symbol("@nref"), (:$, :N), :B, :j), (:tuple, (:ref, :BJ, 1), :AI))
                          ))
                      ))
                  ))),
              (:line, 430, :none),
              :B
            ))
        ))),
    (:line, 436, :none),
    "    any(itr) -> Bool\n\nTest whether any elements of a boolean collection are `true`.\n",
    (:line, 441, :none),
    (:(=), (:call, :any, :itr), (:block,
        (:line, 441, :none),
        (:call, :any, :identity, :itr)
      )),
    (:line, 443, :none),
    "    all(itr) -> Bool\n\nTest whether all elements of a boolean collection are `true`.\n",
    (:line, 448, :none),
    (:(=), (:call, :all, :itr), (:block,
        (:line, 448, :none),
        (:call, :all, :identity, :itr)
      )),
    (:line, 450, :none),
    (:(=), (:call, :nonboolean_error, :f, :op), (:block,
        (:line, 450, :none),
        (:call, :throw, (:call, :ArgumentError, (:string, "    Using non-boolean collections with ", :f, "(itr) is not allowed, use\n    reduce(", :op, ", itr) instead. If you are using ", :f, "(map(f, itr)) or\n    ", :f, "([f(x) for x in itr]), use ", :f, "(f, itr) instead.\n")))
      )),
    (:line, 455, :none),
    (:(=), (:call, :or_bool_only, :a, :b), (:block,
        (:line, 455, :none),
        (:call, :nonboolean_error, (:quote, #QuoteNode
            :any
          ), (:quote, #QuoteNode
            :|
          ))
      )),
    (:line, 456, :none),
    (:(=), (:call, :or_bool_only, (:(::), :a, :Bool), (:(::), :b, :Bool)), (:block,
        (:line, 456, :none),
        (:call, :|, :a, :b)
      )),
    (:line, 457, :none),
    (:(=), (:call, :and_bool_only, :a, :b), (:block,
        (:line, 457, :none),
        (:call, :nonboolean_error, (:quote, #QuoteNode
            :all
          ), (:quote, #QuoteNode
            :&
          ))
      )),
    (:line, 458, :none),
    (:(=), (:call, :and_bool_only, (:(::), :a, :Bool), (:(::), :b, :Bool)), (:block,
        (:line, 458, :none),
        (:call, :&, :a, :b)
      )),
    (:line, 460, :none),
    "    any(p, itr) -> Bool\n\nDetermine whether predicate `p` returns `true` for any elements of `itr`.\n\n```jldoctest\njulia> any(i->(4<=i<=6), [3,5,7])\ntrue\n```\n",
    (:line, 470, :none),
    (:(=), (:call, :any, (:(::), :f, :Any), :itr), (:block,
        (:line, 470, :none),
        (:call, :any, (:call, :Predicate, :f), :itr)
      )),
    (:line, 471, :none),
    (:(=), (:call, :any, (:(::), :f, :Predicate), :itr), (:block,
        (:line, 471, :none),
        (:call, :mapreduce_sc_impl, :f, :|, :itr)
      )),
    (:line, 472, :none),
    (:(=), (:call, :any, (:(::), :f, (:call, :typeof, :identity)), :itr), (:block,
        (:line, 472, :none),
        (:if, (:<:, (:call, :eltype, :itr), :Bool), (:call, :mapreduce_sc_impl, :f, :|, :itr), (:call, :reduce, :or_bool_only, false, :itr))
      )),
    (:line, 477, :none),
    "    all(p, itr) -> Bool\n\nDetermine whether predicate `p` returns `true` for all elements of `itr`.\n\n```jldoctest\njulia> all(i->(4<=i<=6), [4,5,6])\ntrue\n```\n",
    (:line, 487, :none),
    (:(=), (:call, :all, (:(::), :f, :Any), :itr), (:block,
        (:line, 487, :none),
        (:call, :all, (:call, :Predicate, :f), :itr)
      )),
    (:line, 488, :none),
    (:(=), (:call, :all, (:(::), :f, :Predicate), :itr), (:block,
        (:line, 488, :none),
        (:call, :mapreduce_sc_impl, :f, :&, :itr)
      )),
    (:line, 489, :none),
    (:(=), (:call, :all, (:(::), :f, (:call, :typeof, :identity)), :itr), (:block,
        (:line, 489, :none),
        (:if, (:<:, (:call, :eltype, :itr), :Bool), (:call, :mapreduce_sc_impl, :f, :&, :itr), (:call, :reduce, :and_bool_only, true, :itr))
      )),
    (:line, 496, :none),
    (:(=), (:call, :in, :x, :itr), (:block,
        (:line, 496, :none),
        (:call, :any, (:call, :Predicate, (:->, :y, (:block,
                (:line, 496, :none),
                (:call, :(==), :y, :x)
              ))), :itr)
      )),
    (:line, 498, :none),
    (:const, (:(=), :∈, :in)),
    (:line, 499, :none),
    (:(=), (:call, :∉, :x, :itr), (:block,
        (:line, 499, :none),
        (:call, :!, (:call, :∈, :x, :itr))
      )),
    (:line, 500, :none),
    (:(=), (:call, :∋, :itr, :x), (:block,
        (:line, 500, :none),
        (:call, :∈, :x, :itr)
      )),
    (:line, 501, :none),
    (:(=), (:call, :∌, :itr, :x), (:block,
        (:line, 501, :none),
        (:call, :!, (:call, :∋, :itr, :x))
      )),
    (:line, 503, :none),
    (:function, (:call, :contains, (:(::), :eq, :Function), :itr, :x), (:block,
        (:line, 504, :none),
        (:for, (:(=), :y, :itr), (:block,
            (:line, 505, :none),
            (:&&, (:call, :eq, :y, :x), (:return, true))
          )),
        (:line, 507, :none),
        (:return, false)
      )),
    (:line, 513, :none),
    "    count(p, itr) -> Integer\n\nCount the number of elements in `itr` for which predicate `p` returns `true`.\n\n```jldoctest\njulia> count(i->(4<=i<=6), [2,3,4,5,6])\n3\n```\n",
    (:line, 523, :none),
    (:function, (:call, :count, :pred, :itr), (:block,
        (:line, 524, :none),
        (:(=), :n, 0),
        (:line, 525, :none),
        (:for, (:(=), :x, :itr), (:block,
            (:line, 526, :none),
            (:+=, :n, (:call, :pred, :x))
          )),
        (:line, 528, :none),
        (:return, :n)
      )),
    (:line, 531, :none),
    "    countnz(A)\n\nCounts the number of nonzero values in array `A` (dense or sparse). Note that this is not a constant-time operation.\nFor sparse matrices, one should usually use `nnz`, which returns the number of stored values.\n",
    (:line, 537, :none),
    (:(=), (:call, :countnz, :a), (:block,
        (:line, 537, :none),
        (:call, :count, (:->, :x, (:block,
              (:line, 537, :none),
              (:call, :(!=), :x, 0)
            )), :a)
      ))
  ))