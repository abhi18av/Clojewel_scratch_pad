(:quote, (:block,
    (:line, 3, :none),
    (:type, true, (:<:, :BatchProcessingError, :Exception), (:block,
        (:line, 4, :none),
        :data,
        (:line, 5, :none),
        :ex
      )),
    (:line, 8, :none),
    "    pgenerate([::WorkerPool], f, c...) -> iterator\n\nApply `f` to each element of `c` in parallel using available workers and tasks.\n\nFor multiple collection arguments, apply f elementwise.\n\nResults are returned in order as they become available.\n\nNote that `f` must be made available to all worker processes; see\n[Code Availability and Loading Packages](:ref:`Code Availability\nand Loading Packages <man-parallel-computing-code-availability>`)\nfor details.\n",
    (:line, 22, :none),
    (:function, (:call, :pgenerate, (:(::), :p, :WorkerPool), :f, :c), (:block,
        (:line, 23, :none),
        (:if, (:call, :(==), (:call, :length, :p), 0), (:block,
            (:line, 24, :none),
            (:return, (:call, :AsyncGenerator, (:parameters, (:kw, :ntasks, (:->, (:tuple,), (:block,
                        (:line, 24, :none),
                        (:call, :nworkers, :p)
                      )))), :f, :c))
          )),
        (:line, 26, :none),
        (:(=), :batches, (:call, :batchsplit, :c, (:kw, :min_batch_count, (:call, :*, (:call, :length, :p), 3)))),
        (:line, 27, :none),
        (:return, (:call, :flatten, (:call, :AsyncGenerator, (:call, :remote, :p, (:->, :b, (:block,
                    (:line, 27, :none),
                    (:call, :asyncmap, :f, :b)
                  ))), :batches)))
      )),
    (:line, 29, :none),
    (:(=), (:call, :pgenerate, (:(::), :p, :WorkerPool), :f, :c1, (:..., :c)), (:block,
        (:line, 29, :none),
        (:call, :pgenerate, :p, (:->, :a, (:block,
              (:line, 29, :none),
              (:call, :f, (:..., :a))
            )), (:call, :zip, :c1, (:..., :c)))
      )),
    (:line, 30, :none),
    (:(=), (:call, :pgenerate, :f, :c), (:block,
        (:line, 30, :none),
        (:call, :pgenerate, (:call, :default_worker_pool), :f, :c)
      )),
    (:line, 31, :none),
    (:(=), (:call, :pgenerate, :f, :c1, (:..., :c)), (:block,
        (:line, 31, :none),
        (:call, :pgenerate, (:->, :a, (:block,
              (:line, 31, :none),
              (:call, :f, (:..., :a))
            )), (:call, :zip, :c1, (:..., :c)))
      )),
    (:line, 33, :none),
    "    pmap([::AbstractWorkerPool], f, c...; distributed=true, batch_size=1, on_error=nothing, retry_n=0, retry_max_delay=DEFAULT_RETRY_MAX_DELAY, retry_on=DEFAULT_RETRY_ON) -> collection\n\nTransform collection `c` by applying `f` to each element using available\nworkers and tasks.\n\nFor multiple collection arguments, apply f elementwise.\n\nNote that `f` must be made available to all worker processes; see\n[Code Availability and Loading Packages](:ref:`Code Availability\nand Loading Packages <man-parallel-computing-code-availability>`)\nfor details.\n\nIf a worker pool is not specified, all available workers, i.e., the default worker pool\nis used.\n\nBy default, `pmap` distributes the computation over all specified workers. To use only the\nlocal process and distribute over tasks, specify `distributed=false`. This is equivalent to `asyncmap`.\n\n`pmap` can also use a mix of processes and tasks via the `batch_size` argument. For batch sizes\ngreater than 1, the collection is split into multiple batches, which are distributed across\nworkers. Each such batch is processed in parallel via tasks in each worker. The specified\n`batch_size` is an upper limit, the actual size of batches may be smaller and is calculated\ndepending on the number of workers available and length of the collection.\n\nAny error stops pmap from processing the remainder of the collection. To override this behavior\nyou can specify an error handling function via argument `on_error` which takes in a single argument, i.e.,\nthe exception. The function can stop the processing by rethrowing the error, or, to continue, return any value\nwhich is then returned inline with the results to the caller.\n\nFailed computation can also be retried via `retry_on`, `retry_n`, `retry_max_delay`, which are passed through\nto `retry` as arguments `retry_on`, `n` and `max_delay` respectively. If batching is specified, and an entire batch fails,\nall items in the batch are retried.\n\nThe following are equivalent:\n\n* `pmap(f, c; distributed=false)` and `asyncmap(f,c)`\n* `pmap(f, c; retry_n=1)` and `asyncmap(retry(remote(f)),c)`\n* `pmap(f, c; retry_n=1, on_error=e->e)` and `asyncmap(x->try retry(remote(f))(x) catch e; e end, c)`\n",
    (:line, 73, :none),
    (:function, (:call, :pmap, (:parameters, (:kw, :distributed, true), (:kw, :batch_size, 1), (:kw, :on_error, :nothing), (:kw, :retry_n, 0), (:kw, :retry_max_delay, :DEFAULT_RETRY_MAX_DELAY), (:kw, :retry_on, :DEFAULT_RETRY_ON), (:kw, :err_retry, :nothing), (:kw, :err_stop, :nothing), (:kw, :pids, :nothing)), (:(::), :p, :AbstractWorkerPool), :f, :c), (:block,
        (:line, 80, :none),
        (:if, (:call, :(!==), :err_retry, :nothing), (:block,
            (:line, 81, :none),
            (:call, :depwarn, "err_retry is deprecated, use pmap(retry(f), c...).", (:quote, #QuoteNode
                :pmap
              )),
            (:line, 82, :none),
            (:if, (:call, :(==), :err_retry, true), (:block,
                (:line, 83, :none),
                (:(=), :f, (:call, :retry, :f))
              ))
          )),
        (:line, 86, :none),
        (:if, (:call, :(!==), :pids, :nothing), (:block,
            (:line, 87, :none),
            (:call, :depwarn, "pids is deprecated, use pmap(::WorkerPool, f, c...).", (:quote, #QuoteNode
                :pmap
              )),
            (:line, 88, :none),
            (:(=), :p, (:call, :WorkerPool, :pids))
          )),
        (:line, 90, :none),
        (:if, (:call, :(!==), :err_stop, :nothing), (:block,
            (:line, 91, :none),
            (:call, :depwarn, "err_stop is deprecated, use pmap(f, c...; on_error = error_handling_func).", (:quote, #QuoteNode
                :pmap
              )),
            (:line, 92, :none),
            (:if, (:call, :(===), :err_stop, false), (:block,
                (:line, 93, :none),
                (:(=), :on_error, (:->, :e, (:block,
                      (:line, 93, :none),
                      :e
                    )))
              ))
          )),
        (:line, 97, :none),
        (:(=), :f_orig, :f),
        (:line, 99, :none),
        (:if, (:||, (:call, :(==), (:call, :length, :p), 0), (:&&, (:call, :(==), (:call, :length, :p), 1), (:call, :(==), (:call, :fetch, (:., :p, (:quote, #QuoteNode
                      :channel
                    ))), (:call, :myid)))), (:block,
            (:line, 100, :none),
            (:(=), :distributed, false)
          )),
        (:line, 104, :none),
        (:if, (:call, :!, :distributed), (:block,
            (:line, 105, :none),
            (:(=), :batch_size, 1)
          )),
        (:line, 109, :none),
        (:if, (:call, :(==), :batch_size, 1), (:block,
            (:line, 110, :none),
            (:if, :distributed, (:block,
                (:line, 111, :none),
                (:(=), :f, (:call, :remote, :p, :f))
              )),
            (:line, 114, :none),
            (:if, (:call, :>, :retry_n, 0), (:block,
                (:line, 115, :none),
                (:(=), :f, (:call, :wrap_retry, :f, :retry_on, :retry_n, :retry_max_delay))
              )),
            (:line, 117, :none),
            (:if, (:call, :(!==), :on_error, :nothing), (:block,
                (:line, 118, :none),
                (:(=), :f, (:call, :wrap_on_error, :f, :on_error))
              )),
            (:line, 121, :none),
            (:return, (:call, :collect, (:call, :AsyncGenerator, (:parameters, (:kw, :ntasks, (:->, (:tuple,), (:block,
                          (:line, 121, :none),
                          (:call, :nworkers, :p)
                        )))), :f, :c)))
          ), (:block,
            (:line, 123, :none),
            (:(=), :batches, (:call, :batchsplit, :c, (:kw, :min_batch_count, (:call, :*, (:call, :length, :p), 3)), (:kw, :max_batch_size, :batch_size))),
            (:line, 132, :none),
            (:if, (:||, (:call, :(!==), :on_error, :nothing), (:call, :>, :retry_n, 0)), (:block,
                (:line, 133, :none),
                (:(=), :f, (:call, :wrap_on_error, (:parameters, (:kw, :capture_data, true)), :f, (:->, (:tuple, :x, :e), (:block,
                        (:line, 133, :none),
                        (:call, :BatchProcessingError, :x, :e)
                      ))))
              )),
            (:line, 135, :none),
            (:(=), :f, (:call, :wrap_batch, :f, :p, :on_error)),
            (:line, 136, :none),
            (:(=), :results, (:call, :collect, (:call, :flatten, (:call, :AsyncGenerator, (:parameters, (:kw, :ntasks, (:->, (:tuple,), (:block,
                            (:line, 136, :none),
                            (:call, :nworkers, :p)
                          )))), :f, :batches)))),
            (:line, 137, :none),
            (:if, (:||, (:call, :(!==), :on_error, :nothing), (:call, :>, :retry_n, 0)), (:block,
                (:line, 138, :none),
                (:call, :process_batch_errors!, :p, :f_orig, :results, :on_error, :retry_on, :retry_n, :retry_max_delay)
              )),
            (:line, 141, :none),
            (:return, :results)
          ))
      )),
    (:line, 145, :none),
    (:(=), (:call, :pmap, (:parameters, (:..., :kwargs)), (:(::), :p, :AbstractWorkerPool), :f, :c1, (:..., :c)), (:block,
        (:line, 145, :none),
        (:call, :pmap, (:parameters, (:..., :kwargs)), :p, (:->, :a, (:block,
              (:line, 145, :none),
              (:call, :f, (:..., :a))
            )), (:call, :zip, :c1, (:..., :c)))
      )),
    (:line, 146, :none),
    (:(=), (:call, :pmap, (:parameters, (:..., :kwargs)), :f, :c), (:block,
        (:line, 146, :none),
        (:call, :pmap, (:parameters, (:..., :kwargs)), (:call, :default_worker_pool), :f, :c)
      )),
    (:line, 147, :none),
    (:(=), (:call, :pmap, (:parameters, (:..., :kwargs)), :f, :c1, (:..., :c)), (:block,
        (:line, 147, :none),
        (:call, :pmap, (:parameters, (:..., :kwargs)), (:->, :a, (:block,
              (:line, 147, :none),
              (:call, :f, (:..., :a))
            )), (:call, :zip, :c1, (:..., :c)))
      )),
    (:line, 149, :none),
    (:function, (:call, :wrap_on_error, (:parameters, (:kw, :capture_data, false)), :f, :on_error), (:block,
        (:line, 150, :none),
        (:return, (:->, :x, (:block,
              (:line, 150, :none),
              (:block,
                (:line, 151, :none),
                (:try, (:block,
                    (:line, 152, :none),
                    (:call, :f, :x)
                  ), :e, (:block,
                    (:line, 154, :none),
                    (:if, :capture_data, (:block,
                        (:line, 155, :none),
                        (:call, :on_error, :x, :e)
                      ), (:block,
                        (:line, 157, :none),
                        (:call, :on_error, :e)
                      ))
                  ))
              )
            )))
      )),
    (:line, 163, :none),
    (:(=), (:call, :wrap_retry, :f, :retry_on, :n, :max_delay), (:block,
        (:line, 163, :none),
        (:call, :retry, (:parameters, (:kw, :n, :n), (:kw, :max_delay, :max_delay)), :f, :retry_on)
      )),
    (:line, 165, :none),
    (:function, (:call, :wrap_batch, :f, :p, :on_error), (:block,
        (:line, 166, :none),
        (:(=), :f, (:call, :asyncmap_batch, :f)),
        (:line, 167, :none),
        (:return, (:->, :batch, (:block,
              (:line, 167, :none),
              (:block,
                (:line, 168, :none),
                (:try, (:block,
                    (:line, 169, :none),
                    (:call, :remotecall_fetch, :f, :p, :batch)
                  ), :e, (:block,
                    (:line, 171, :none),
                    (:if, (:call, :(!==), :on_error, :nothing), (:block,
                        (:line, 172, :none),
                        (:return, (:typed_comprehension, :Any, (:generator, (:call, :BatchProcessingError, (:ref, :batch, :i), :e), (:(=), :i, (:(:), 1, (:call, :length, :batch))))))
                      ), (:block,
                        (:line, 174, :none),
                        (:call, :rethrow, :e)
                      ))
                  ))
              )
            )))
      )),
    (:line, 180, :none),
    (:(=), (:call, :asyncmap_batch, :f), (:block,
        (:line, 180, :none),
        (:->, :batch, (:block,
            (:line, 180, :none),
            (:call, :asyncmap, :f, :batch)
          ))
      )),
    (:line, 182, :none),
    (:function, (:call, :process_batch_errors!, :p, :f, :results, :on_error, :retry_on, :retry_n, :retry_max_delay), (:block,
        (:line, 184, :none),
        (:if, (:||, (:call, :(!==), :on_error, :nothing), (:call, :>, :retry_n, 0)), (:block,
            (:line, 185, :none),
            (:(=), :reprocess, (:vect,)),
            (:line, 186, :none),
            (:for, (:(=), (:tuple, :idx, :v), (:call, :enumerate, :results)), (:block,
                (:line, 187, :none),
                (:if, (:call, :isa, :v, :BatchProcessingError), (:block,
                    (:line, 188, :none),
                    (:call, :push!, :reprocess, (:tuple, :idx, :v))
                  ))
              )),
            (:line, 192, :none),
            (:if, (:call, :>, (:call, :length, :reprocess), 0), (:block,
                (:line, 193, :none),
                (:(=), :errors, (:comprehension, (:generator, (:ref, :x, 2), (:(=), :x, :reprocess)))),
                (:line, 194, :none),
                (:(=), :exceptions, (:comprehension, (:generator, (:., :x, (:quote, #QuoteNode
                          :ex
                        )), (:(=), :x, :errors)))),
                (:line, 195, :none),
                (:if, (:&&, (:call, :>, :retry_n, 0), (:call, :all, (:comprehension, (:generator, (:call, :retry_on, :ex), (:(=), :ex, :exceptions))))), (:block,
                    (:line, 196, :none),
                    (:(=), :retry_n, (:call, :-, :retry_n, 1)),
                    (:line, 197, :none),
                    (:(=), :error_processed, (:call, :pmap, (:parameters, (:kw, :on_error, :on_error), (:kw, :retry_on, :retry_on), (:kw, :retry_n, :retry_n), (:kw, :retry_max_delay, :retry_max_delay)), :p, :f, (:comprehension, (:generator, (:., :x, (:quote, #QuoteNode
                                :data
                              )), (:(=), :x, :errors)))))
                  ), (:block,
                    (:line, 202, :none),
                    (:if, (:call, :(!==), :on_error, :nothing), (:block,
                        (:line, 203, :none),
                        (:(=), :error_processed, (:call, :map, :on_error, :exceptions))
                      ), (:block,
                        (:line, 205, :none),
                        (:call, :throw, (:call, :CompositeException, :exceptions))
                      ))
                  )),
                (:line, 208, :none),
                (:for, (:(=), (:tuple, :idx, :v), (:call, :enumerate, :error_processed)), (:block,
                    (:line, 209, :none),
                    (:(=), (:ref, :results, (:ref, (:ref, :reprocess, :idx), 1)), :v)
                  ))
              ))
          )),
        (:line, 213, :none),
        :nothing
      )),
    (:line, 217, :none),
    "    batchsplit(c; min_batch_count=1, max_batch_size=100) -> iterator\n\nSplit a collection into at least `min_batch_count` batches.\n\nEquivalent to `partition(c, max_batch_size)` when `length(c) >> max_batch_size`.\n",
    (:line, 224, :none),
    (:function, (:call, :batchsplit, (:parameters, (:kw, :min_batch_count, 1), (:kw, :max_batch_size, 100)), :c), (:block,
        (:line, 225, :none),
        (:if, (:call, :<, :min_batch_count, 1), (:block,
            (:line, 226, :none),
            (:call, :throw, (:call, :ArgumentError, (:string, "min_batch_count must be ≥ 1, got ", :min_batch_count)))
          )),
        (:line, 229, :none),
        (:if, (:call, :<, :max_batch_size, 1), (:block,
            (:line, 230, :none),
            (:call, :throw, (:call, :ArgumentError, (:string, "max_batch_size must be ≥ 1, got ", :max_batch_size)))
          )),
        (:line, 234, :none),
        (:(=), :batches, (:call, :partition, :c, :max_batch_size)),
        (:line, 235, :none),
        (:(=), (:tuple, :head, :tail), (:call, :head_and_tail, :batches, :min_batch_count)),
        (:line, 238, :none),
        (:if, (:call, :<, (:call, :length, :head), :min_batch_count), (:block,
            (:line, 239, :none),
            (:(=), :batch_size, (:call, :max, 1, (:call, :div, (:call, :sum, :length, :head), :min_batch_count))),
            (:line, 240, :none),
            (:return, (:call, :partition, (:call, :collect, (:call, :flatten, :head)), :batch_size))
          )),
        (:line, 243, :none),
        (:return, (:call, :flatten, (:tuple, :head, :tail)))
      ))
  ))