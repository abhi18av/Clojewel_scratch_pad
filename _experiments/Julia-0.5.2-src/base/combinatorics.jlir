(:quote, (:block,
    (:line, 5, :none),
    (:const, (:(=), :_fact_table64, (:ref, :Int64, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200, 1307674368000, 20922789888000, 355687428096000, 6402373705728000, 121645100408832000, 2432902008176640000))),
    (:line, 10, :none),
    (:const, (:(=), :_fact_table128, (:ref, :UInt128, (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000000001"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000000002"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000000006"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000000018"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000000078"), (:macrocall, Symbol("@uint128_str"), "0x000000000000000000000000000002d0"), (:macrocall, Symbol("@uint128_str"), "0x000000000000000000000000000013b0"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000009d80"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000058980"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000375f00"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000002611500"), (:macrocall, Symbol("@uint128_str"), "0x0000000000000000000000001c8cfc00"), (:macrocall, Symbol("@uint128_str"), "0x0000000000000000000000017328cc00"), (:macrocall, Symbol("@uint128_str"), "0x0000000000000000000000144c3b2800"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000013077775800"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000130777758000"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000001437eeecd8000"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000016beecca730000"), (:macrocall, Symbol("@uint128_str"), "0x000000000000000001b02b9306890000"), (:macrocall, Symbol("@uint128_str"), "0x000000000000000021c3677c82b40000"), (:macrocall, Symbol("@uint128_str"), "0x0000000000000002c5077d36b8c40000"), (:macrocall, Symbol("@uint128_str"), "0x000000000000003ceea4c2b3e0d80000"), (:macrocall, Symbol("@uint128_str"), "0x000000000000057970cd7e2933680000"), (:macrocall, Symbol("@uint128_str"), "0x00000000000083629343d3dcd1c00000"), (:macrocall, Symbol("@uint128_str"), "0x00000000000cd4a0619fb0907bc00000"), (:macrocall, Symbol("@uint128_str"), "0x00000000014d9849ea37eeac91800000"), (:macrocall, Symbol("@uint128_str"), "0x00000000232f0fcbb3e62c3358800000"), (:macrocall, Symbol("@uint128_str"), "0x00000003d925ba47ad2cd59dae000000"), (:macrocall, Symbol("@uint128_str"), "0x0000006f99461a1e9e1432dcb6000000"), (:macrocall, Symbol("@uint128_str"), "0x00000d13f6370f96865df5dd54000000"), (:macrocall, Symbol("@uint128_str"), "0x0001956ad0aae33a4560c5cd2c000000"), (:macrocall, Symbol("@uint128_str"), "0x0032ad5a155c6748ac18b9a580000000"), (:macrocall, Symbol("@uint128_str"), "0x0688589cc0e9505e2f2fee5580000000"), (:macrocall, Symbol("@uint128_str"), "0xde1bc4d19efcac82445da75b00000000")))),
    (:line, 29, :none),
    (:function, (:call, :factorial_lookup, (:(::), :n, :Integer), :table, :lim), (:block,
        (:line, 30, :none),
        (:&&, (:call, :<, :n, 0), (:call, :throw, (:call, :DomainError))),
        (:line, 31, :none),
        (:&&, (:call, :>, :n, :lim), (:call, :throw, (:call, :OverflowError))),
        (:line, 32, :none),
        (:&&, (:call, :(==), :n, 0), (:return, (:call, :one, :n))),
        (:line, 33, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :f, (:ref, :table, :n))),
        (:line, 34, :none),
        (:return, (:call, :oftype, :n, :f))
      )),
    (:line, 37, :none),
    (:(=), (:call, :factorial, (:(::), :n, :Int128)), (:block,
        (:line, 37, :none),
        (:call, :factorial_lookup, :n, :_fact_table128, 33)
      )),
    (:line, 38, :none),
    (:(=), (:call, :factorial, (:(::), :n, :UInt128)), (:block,
        (:line, 38, :none),
        (:call, :factorial_lookup, :n, :_fact_table128, 34)
      )),
    (:line, 39, :none),
    (:(=), (:call, :factorial, (:(::), :n, (:curly, :Union, :Int64, :UInt64))), (:block,
        (:line, 39, :none),
        (:call, :factorial_lookup, :n, :_fact_table64, 20)
      )),
    (:line, 41, :none),
    (:if, (:call, :(===), :Int, :Int32), (:block,
        (:line, 42, :none),
        (:(=), (:call, :factorial, (:(::), :n, (:curly, :Union, :Int8, :UInt8, :Int16, :UInt16))), (:block,
            (:line, 42, :none),
            (:call, :factorial, (:call, :Int32, :n))
          )),
        (:line, 43, :none),
        (:(=), (:call, :factorial, (:(::), :n, (:curly, :Union, :Int32, :UInt32))), (:block,
            (:line, 43, :none),
            (:call, :factorial_lookup, :n, :_fact_table64, 12)
          ))
      ), (:block,
        (:line, 45, :none),
        (:(=), (:call, :factorial, (:(::), :n, (:curly, :Union, :Int8, :UInt8, :Int16, :UInt16, :Int32, :UInt32))), (:block,
            (:line, 45, :none),
            (:call, :factorial, (:call, :Int64, :n))
          ))
      )),
    (:line, 48, :none),
    (:function, (:call, :gamma, (:(::), :n, (:curly, :Union, :Int8, :UInt8, :Int16, :UInt16, :Int32, :UInt32, :Int64, :UInt64))), (:block,
        (:line, 49, :none),
        (:&&, (:call, :<, :n, 0), (:call, :throw, (:call, :DomainError))),
        (:line, 50, :none),
        (:&&, (:call, :(==), :n, 0), (:return, :Inf)),
        (:line, 51, :none),
        (:&&, (:call, :(<=), :n, 2), (:return, 1.0)),
        (:line, 52, :none),
        (:&&, (:call, :>, :n, 20), (:return, (:call, :gamma, (:call, :Float64, :n)))),
        (:line, 53, :none),
        (:macrocall, Symbol("@inbounds"), (:return, (:call, :Float64, (:ref, :_fact_table64, (:call, :-, :n, 1)))))
      )),
    (:line, 59, :none),
    "    isperm(v) -> Bool\n\nReturns `true` if `v` is a valid permutation.\n",
    (:line, 64, :none),
    (:function, (:call, :isperm, :A), (:block,
        (:line, 65, :none),
        (:(=), :n, (:call, :length, :A)),
        (:line, 66, :none),
        (:(=), :used, (:call, :falses, :n)),
        (:line, 67, :none),
        (:for, (:(=), :a, :A), (:block,
            (:line, 68, :none),
            (:||, (:&&, (:comparison, 0, :<, :a, :(<=), :n), (:$=, (:ref, :used, :a), true)), (:return, false))
          )),
        (:line, 70, :none),
        true
      )),
    (:line, 73, :none),
    (:(=), (:call, :isperm, (:(::), :p, (:curly, :Tuple))), (:block,
        (:line, 73, :none),
        true
      )),
    (:line, 74, :none),
    (:(=), (:call, :isperm, (:(::), :p, (:curly, :Tuple, :Int))), (:block,
        (:line, 74, :none),
        (:call, :(==), (:ref, :p, 1), 1)
      )),
    (:line, 75, :none),
    (:(=), (:call, :isperm, (:(::), :p, (:curly, :Tuple, :Int, :Int))), (:block,
        (:line, 75, :none),
        (:call, :|, (:call, :&, (:call, :(==), (:ref, :p, 1), 1), (:call, :(==), (:ref, :p, 2), 2)), (:call, :&, (:call, :(==), (:ref, :p, 1), 2), (:call, :(==), (:ref, :p, 2), 1)))
      )),
    (:line, 77, :none),
    (:function, (:call, (:curly, :permute!!, (:<:, :T, :Integer)), :a, (:(::), :p, (:curly, :AbstractVector, :T))), (:block,
        (:line, 78, :none),
        (:(=), :count, 0),
        (:line, 79, :none),
        (:(=), :start, 0),
        (:line, 80, :none),
        (:while, (:call, :<, :count, (:call, :length, :a)), (:block,
            (:line, 81, :none),
            (:(=), :ptr, (:(=), :start, (:call, :findnext, :p, (:call, :+, :start, 1)))),
            (:line, 82, :none),
            (:(=), :temp, (:ref, :a, :start)),
            (:line, 83, :none),
            (:(=), :next, (:ref, :p, :start)),
            (:line, 84, :none),
            (:+=, :count, 1),
            (:line, 85, :none),
            (:while, (:call, :(!=), :next, :start), (:block,
                (:line, 86, :none),
                (:(=), (:ref, :a, :ptr), (:ref, :a, :next)),
                (:line, 87, :none),
                (:(=), (:ref, :p, :ptr), 0),
                (:line, 88, :none),
                (:(=), :ptr, :next),
                (:line, 89, :none),
                (:(=), :next, (:ref, :p, :next)),
                (:line, 90, :none),
                (:+=, :count, 1)
              )),
            (:line, 92, :none),
            (:(=), (:ref, :a, :ptr), :temp),
            (:line, 93, :none),
            (:(=), (:ref, :p, :ptr), 0)
          )),
        (:line, 95, :none),
        :a
      )),
    (:line, 98, :none),
    "    permute!(v, p)\n\nPermute vector `v` in-place, according to permutation `p`. No checking is done\nto verify that `p` is a permutation.\n\nTo return a new permutation, use `v[p]`. Note that this is generally faster than\n`permute!(v,p)` for large vectors.\n",
    (:line, 107, :none),
    (:(=), (:call, :permute!, :a, (:(::), :p, :AbstractVector)), (:block,
        (:line, 107, :none),
        (:call, :permute!!, :a, (:call, :copymutable, :p))
      )),
    (:line, 109, :none),
    (:function, (:call, (:curly, :ipermute!!, (:<:, :T, :Integer)), :a, (:(::), :p, (:curly, :AbstractVector, :T))), (:block,
        (:line, 110, :none),
        (:(=), :count, 0),
        (:line, 111, :none),
        (:(=), :start, 0),
        (:line, 112, :none),
        (:while, (:call, :<, :count, (:call, :length, :a)), (:block,
            (:line, 113, :none),
            (:(=), :start, (:call, :findnext, :p, (:call, :+, :start, 1))),
            (:line, 114, :none),
            (:(=), :temp, (:ref, :a, :start)),
            (:line, 115, :none),
            (:(=), :next, (:ref, :p, :start)),
            (:line, 116, :none),
            (:+=, :count, 1),
            (:line, 117, :none),
            (:while, (:call, :(!=), :next, :start), (:block,
                (:line, 118, :none),
                (:(=), :temp_next, (:ref, :a, :next)),
                (:line, 119, :none),
                (:(=), (:ref, :a, :next), :temp),
                (:line, 120, :none),
                (:(=), :temp, :temp_next),
                (:line, 121, :none),
                (:(=), :ptr, (:ref, :p, :next)),
                (:line, 122, :none),
                (:(=), (:ref, :p, :next), 0),
                (:line, 123, :none),
                (:(=), :next, :ptr),
                (:line, 124, :none),
                (:+=, :count, 1)
              )),
            (:line, 126, :none),
            (:(=), (:ref, :a, :next), :temp),
            (:line, 127, :none),
            (:(=), (:ref, :p, :next), 0)
          )),
        (:line, 129, :none),
        :a
      )),
    (:line, 132, :none),
    "    ipermute!(v, p)\n\nLike `permute!`, but the inverse of the given permutation is applied.\n",
    (:line, 137, :none),
    (:(=), (:call, :ipermute!, :a, (:(::), :p, :AbstractVector)), (:block,
        (:line, 137, :none),
        (:call, :ipermute!!, :a, (:call, :copymutable, :p))
      )),
    (:line, 139, :none),
    "    invperm(v)\n\nReturn the inverse permutation of `v`\n",
    (:line, 144, :none),
    (:function, (:call, :invperm, (:(::), :a, :AbstractVector)), (:block,
        (:line, 145, :none),
        (:(=), :b, (:call, :zero, :a)),
        (:line, 146, :none),
        (:(=), :n, (:call, :length, :a)),
        (:line, 147, :none),
        (:macrocall, Symbol("@inbounds"), (:for, (:(=), (:tuple, :i, :j), (:call, :enumerate, :a)), (:block,
              (:line, 148, :none),
              (:||, (:&&, (:comparison, 1, :(<=), :j, :(<=), :n), (:call, :(==), (:ref, :b, :j), 0)), (:call, :throw, (:call, :ArgumentError, "argument is not a permutation"))),
              (:line, 150, :none),
              (:(=), (:ref, :b, :j), :i)
            ))),
        (:line, 152, :none),
        :b
      )),
    (:line, 155, :none),
    (:function, (:call, :invperm, (:(::), :p, (:curly, :Union, (:curly, :Tuple), (:curly, :Tuple, :Int), (:curly, :Tuple, :Int, :Int)))), (:block,
        (:line, 156, :none),
        (:||, (:call, :isperm, :p), (:call, :throw, (:call, :ArgumentError, "argument is not a permutation"))),
        (:line, 157, :none),
        :p
      )),
    (:line, 159, :none),
    (:(=), (:call, :invperm, (:(::), :a, :Tuple)), (:block,
        (:line, 159, :none),
        (:tuple, (:..., (:call, :invperm, (:vect, (:..., :a)))))
      )),
    (:line, 162, :none),
    "    nextprod([k_1,k_2,...], n)\n\nNext integer not less than `n` that can be written as ``\\prod k_i^{p_i}`` for integers\n``p_1``, ``p_2``, etc.\n",
    (:line, 168, :none),
    (:function, (:call, :nextprod, (:(::), :a, (:curly, :Vector, :Int)), :x), (:block,
        (:line, 169, :none),
        (:if, (:call, :>, :x, (:call, :typemax, :Int)), (:block,
            (:line, 170, :none),
            (:call, :throw, (:call, :ArgumentError, (:string, "unsafe for x > typemax(Int), got ", :x)))
          )),
        (:line, 172, :none),
        (:(=), :k, (:call, :length, :a)),
        (:line, 173, :none),
        (:(=), :v, (:call, :ones, :Int, :k)),
        (:line, 174, :none),
        (:(=), :mx, (:comprehension, (:generator, (:call, :nextpow, :ai, :x), (:(=), :ai, :a)))),
        (:line, 175, :none),
        (:(=), (:ref, :v, 1), (:ref, :mx, 1)),
        (:line, 176, :none),
        (:(=), (:(::), :p, (:call, :widen, :Int)), (:ref, :mx, 1)),
        (:line, 177, :none),
        (:(=), :best, :p),
        (:line, 178, :none),
        (:(=), :icarry, 1),
        (:line, 180, :none),
        (:while, (:call, :<, (:ref, :v, :end), (:ref, :mx, :end)), (:block,
            (:line, 181, :none),
            (:if, (:call, :(>=), :p, :x), (:block,
                (:line, 182, :none),
                (:(=), :best, (:if, (:call, :<, :p, :best), :p, :best)),
                (:line, 183, :none),
                (:(=), :carrytest, true),
                (:line, 184, :none),
                (:while, :carrytest, (:block,
                    (:line, 185, :none),
                    (:(=), :p, (:call, :div, :p, (:ref, :v, :icarry))),
                    (:line, 186, :none),
                    (:(=), (:ref, :v, :icarry), 1),
                    (:line, 187, :none),
                    (:+=, :icarry, 1),
                    (:line, 188, :none),
                    (:*=, :p, (:ref, :a, :icarry)),
                    (:line, 189, :none),
                    (:*=, (:ref, :v, :icarry), (:ref, :a, :icarry)),
                    (:line, 190, :none),
                    (:(=), :carrytest, (:&&, (:call, :>, (:ref, :v, :icarry), (:ref, :mx, :icarry)), (:call, :<, :icarry, :k)))
                  )),
                (:line, 192, :none),
                (:if, (:call, :<, :p, :x), (:block,
                    (:line, 193, :none),
                    (:(=), :icarry, 1)
                  ))
              ), (:block,
                (:line, 196, :none),
                (:while, (:call, :<, :p, :x), (:block,
                    (:line, 197, :none),
                    (:*=, :p, (:ref, :a, 1)),
                    (:line, 198, :none),
                    (:*=, (:ref, :v, 1), (:ref, :a, 1))
                  ))
              ))
          )),
        (:line, 203, :none),
        (:return, (:if, (:call, :<, (:ref, :mx, :end), :best), (:call, :Int, (:ref, :mx, :end)), (:call, :Int, :best)))
      ))
  ))