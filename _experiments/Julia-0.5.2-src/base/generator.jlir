(:quote, (:block,
    (:line, 3, :none),
    "    Generator(f, iter)\n\nGiven a function `f` and an iterator `iter`, construct an iterator that yields\nthe values of `f` applied to the elements of `iter`.\nThe syntax `f(x) [if cond(x)::Bool] for x in iter` is syntax for constructing an instance of this\ntype. The `[if cond(x)::Bool]` expression is optional and acts as a \"guard\", effectively\nfiltering out values where the condition is false.\n",
    (:line, 12, :none),
    (:type, false, (:curly, :Generator, :I, :F), (:block,
        (:line, 13, :none),
        (:(::), :f, :F),
        (:line, 14, :none),
        (:(::), :iter, :I)
      )),
    (:line, 17, :none),
    (:(=), (:call, :Generator, :f, :I1, :I2, (:..., :Is)), (:block,
        (:line, 17, :none),
        (:call, :Generator, (:->, :a, (:block,
              (:line, 17, :none),
              (:call, :f, (:..., :a))
            )), (:call, :zip, :I1, :I2, (:..., :Is)))
      )),
    (:line, 19, :none),
    (:(=), (:call, (:curly, :Generator, :T, :I), (:(::), (:curly, :Type, :T)), (:(::), :iter, :I)), (:block,
        (:line, 19, :none),
        (:call, (:curly, :Generator, :I, (:curly, :Type, :T)), :T, :iter)
      )),
    (:line, 21, :none),
    (:(=), (:call, :start, (:(::), :g, :Generator)), (:block,
        (:line, 21, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :start, (:., :g, (:quote, #QuoteNode
                :iter
              )))
        )
      )),
    (:line, 22, :none),
    (:(=), (:call, :done, (:(::), :g, :Generator), :s), (:block,
        (:line, 22, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :done, (:., :g, (:quote, #QuoteNode
                :iter
              )), :s)
        )
      )),
    (:line, 23, :none),
    (:function, (:call, :next, (:(::), :g, :Generator), :s), (:block,
        (:line, 24, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 25, :none),
        (:(=), (:tuple, :v, :s2), (:call, :next, (:., :g, (:quote, #QuoteNode
                :iter
              )), :s)),
        (:line, 26, :none),
        (:tuple, (:call, (:., :g, (:quote, #QuoteNode
                :f
              )), :v), :s2)
      )),
    (:line, 32, :none),
    (:abstract, :IteratorSize),
    (:line, 33, :none),
    (:type, false, (:<:, :SizeUnknown, :IteratorSize), (:block,
        (:line, 33, :none)
      )),
    (:line, 34, :none),
    (:type, false, (:<:, :HasLength, :IteratorSize), (:block,
        (:line, 34, :none)
      )),
    (:line, 35, :none),
    (:type, false, (:<:, :HasShape, :IteratorSize), (:block,
        (:line, 35, :none)
      )),
    (:line, 36, :none),
    (:type, false, (:<:, :IsInfinite, :IteratorSize), (:block,
        (:line, 36, :none)
      )),
    (:line, 38, :none),
    "    iteratorsize(itertype::Type) -> IteratorSize\n\nGiven the type of an iterator, returns one of the following values:\n\n* `SizeUnknown()` if the length (number of elements) cannot be determined in advance.\n* `HasLength()` if there is a fixed, finite length.\n* `HasShape()` if there is a known length plus a notion of multidimensional shape (as for an array).\n  In this case the `size` function is valid for the iterator.\n* `IsInfinite()` if the iterator yields values forever.\n\nThe default value (for iterators that do not define this function) is `HasLength()`.\nThis means that most iterators are assumed to implement `length`.\n\nThis trait is generally used to select between algorithms that pre-allocate space for their\nresult, and algorithms that resize their result incrementally.\n",
    (:line, 55, :none),
    (:(=), (:call, :iteratorsize, :x), (:block,
        (:line, 55, :none),
        (:call, :iteratorsize, (:call, :typeof, :x))
      )),
    (:line, 56, :none),
    (:(=), (:call, :iteratorsize, (:(::), :Type)), (:block,
        (:line, 56, :none),
        (:call, :HasLength)
      )),
    (:line, 58, :none),
    (:(=), (:call, (:curly, :and_iteratorsize, :T), (:(::), :isz, :T), (:(::), :T)), (:block,
        (:line, 58, :none),
        :isz
      )),
    (:line, 59, :none),
    (:(=), (:call, :and_iteratorsize, (:(::), :HasLength), (:(::), :HasShape)), (:block,
        (:line, 59, :none),
        (:call, :HasLength)
      )),
    (:line, 60, :none),
    (:(=), (:call, :and_iteratorsize, (:(::), :HasShape), (:(::), :HasLength)), (:block,
        (:line, 60, :none),
        (:call, :HasLength)
      )),
    (:line, 61, :none),
    (:(=), (:call, :and_iteratorsize, :a, :b), (:block,
        (:line, 61, :none),
        (:call, :SizeUnknown)
      )),
    (:line, 63, :none),
    (:abstract, :IteratorEltype),
    (:line, 64, :none),
    (:type, false, (:<:, :EltypeUnknown, :IteratorEltype), (:block,
        (:line, 64, :none)
      )),
    (:line, 65, :none),
    (:type, false, (:<:, :HasEltype, :IteratorEltype), (:block,
        (:line, 65, :none)
      )),
    (:line, 67, :none),
    "    iteratoreltype(itertype::Type) -> IteratorEltype\n\nGiven the type of an iterator, returns one of the following values:\n\n* `EltypeUnknown()` if the type of elements yielded by the iterator is not known in advance.\n* `HasEltype()` if the element type is known, and `eltype` would return a meaningful value.\n\n`HasEltype()` is the default, since iterators are assumed to implement `eltype`.\n\nThis trait is generally used to select between algorithms that pre-allocate a specific\ntype of result, and algorithms that pick a result type based on the types of yielded\nvalues.\n",
    (:line, 81, :none),
    (:(=), (:call, :iteratoreltype, :x), (:block,
        (:line, 81, :none),
        (:call, :iteratoreltype, (:call, :typeof, :x))
      )),
    (:line, 82, :none),
    (:(=), (:call, :iteratoreltype, (:(::), :Type)), (:block,
        (:line, 82, :none),
        (:call, :HasEltype)
      )),
    (:line, 84, :none),
    (:(=), (:call, (:curly, :and_iteratoreltype, :T), (:(::), :iel, :T), (:(::), :T)), (:block,
        (:line, 84, :none),
        :iel
      )),
    (:line, 85, :none),
    (:(=), (:call, :and_iteratoreltype, :a, :b), (:block,
        (:line, 85, :none),
        (:call, :EltypeUnknown)
      )),
    (:line, 87, :none),
    (:(=), (:call, (:curly, :iteratorsize, (:<:, :T, :AbstractArray)), (:(::), (:curly, :Type, :T))), (:block,
        (:line, 87, :none),
        (:call, :HasShape)
      )),
    (:line, 88, :none),
    (:(=), (:call, (:curly, :iteratorsize, :I, :F), (:(::), (:curly, :Type, (:curly, :Generator, :I, :F)))), (:block,
        (:line, 88, :none),
        (:call, :iteratorsize, :I)
      )),
    (:line, 89, :none),
    (:(=), (:call, :length, (:(::), :g, :Generator)), (:block,
        (:line, 89, :none),
        (:call, :length, (:., :g, (:quote, #QuoteNode
              :iter
            )))
      )),
    (:line, 90, :none),
    (:(=), (:call, :size, (:(::), :g, :Generator)), (:block,
        (:line, 90, :none),
        (:call, :size, (:., :g, (:quote, #QuoteNode
              :iter
            )))
      )),
    (:line, 91, :none),
    (:(=), (:call, :indices, (:(::), :g, :Generator)), (:block,
        (:line, 91, :none),
        (:call, :indices, (:., :g, (:quote, #QuoteNode
              :iter
            )))
      )),
    (:line, 92, :none),
    (:(=), (:call, :ndims, (:(::), :g, :Generator)), (:block,
        (:line, 92, :none),
        (:call, :ndims, (:., :g, (:quote, #QuoteNode
              :iter
            )))
      )),
    (:line, 94, :none),
    (:(=), (:call, (:curly, :iteratoreltype, :I, :T), (:(::), (:curly, :Type, (:curly, :Generator, :I, :T)))), (:block,
        (:line, 94, :none),
        (:call, :EltypeUnknown)
      ))
  ))