(:quote, (:block,
    (:line, 3, :none),
    (:toplevel, (:import, :Base, :_uv_hook_close), (:import, :Base, :unsafe_convert), (:import, :Base, :lock), (:import, :Base, :trylock), (:import, :Base, :unlock), (:import, :Base, :islocked)),
    (:line, 6, :none),
    (:export, :SpinLock, :RecursiveSpinLock, :Mutex),
    (:line, 13, :none),
    "    AbstractLock\n\nAbstract supertype describing types that\nimplement the thread-safe synchronization primitives:\n`lock`, `trylock`, `unlock`, and `islocked`\n",
    (:line, 20, :none),
    (:abstract, :AbstractLock),
    (:line, 25, :none),
    "    TatasLock()\n\nSee SpinLock.\n",
    (:line, 30, :none),
    (:type, false, (:<:, :TatasLock, :AbstractLock), (:block,
        (:line, 31, :none),
        (:(::), :handle, (:curly, :Atomic, :Int)),
        (:line, 32, :none),
        (:(=), (:call, :TatasLock), (:block,
            (:line, 32, :none),
            (:call, :new, (:call, (:curly, :Atomic, :Int), 0))
          ))
      )),
    (:line, 35, :none),
    "    SpinLock()\n\nCreates a non-reentrant lock.\nRecursive use will result in a deadlock.\nEach `lock` must be matched with an `unlock`.\n\nTest-and-test-and-set spin locks are quickest up to about 30ish\ncontending threads. If you have more contention than that, perhaps\na lock is the wrong way to synchronize.\n\nSee also RecursiveSpinLock for a version that permits recursion.\n\nSee also Mutex for a more efficient version on one core or if the lock may be held for a considerable length of time.\n",
    (:line, 50, :none),
    (:typealias, :SpinLock, :TatasLock),
    (:line, 52, :none),
    (:function, (:call, :lock, (:(::), :l, :TatasLock)), (:block,
        (:line, 53, :none),
        (:while, true, (:block,
            (:line, 54, :none),
            (:if, (:call, :(==), (:ref, (:., :l, (:quote, #QuoteNode
                      :handle
                    ))), 0), (:block,
                (:line, 55, :none),
                (:(=), :p, (:call, :atomic_xchg!, (:., :l, (:quote, #QuoteNode
                        :handle
                      )), 1)),
                (:line, 56, :none),
                (:if, (:call, :(==), :p, 0), (:block,
                    (:line, 57, :none),
                    (:return, nothing)
                  ))
              )),
            (:line, 60, :none),
            (:ccall, (:quote, #QuoteNode
                :jl_cpu_pause
              ), :Void, (:tuple,)),
            (:line, 62, :none),
            (:ccall, (:quote, #QuoteNode
                :jl_gc_safepoint
              ), :Void, (:tuple,))
          ))
      )),
    (:line, 66, :none),
    (:function, (:call, :trylock, (:(::), :l, :TatasLock)), (:block,
        (:line, 67, :none),
        (:if, (:call, :(==), (:ref, (:., :l, (:quote, #QuoteNode
                  :handle
                ))), 0), (:block,
            (:line, 68, :none),
            (:return, (:call, :(==), (:call, :atomic_xchg!, (:., :l, (:quote, #QuoteNode
                      :handle
                    )), 1), 0))
          )),
        (:line, 70, :none),
        (:return, false)
      )),
    (:line, 73, :none),
    (:function, (:call, :unlock, (:(::), :l, :TatasLock)), (:block,
        (:line, 74, :none),
        (:(=), (:ref, (:., :l, (:quote, #QuoteNode
                :handle
              ))), 0),
        (:line, 75, :none),
        (:ccall, (:quote, #QuoteNode
            :jl_cpu_wake
          ), :Void, (:tuple,)),
        (:line, 76, :none),
        (:return, nothing)
      )),
    (:line, 79, :none),
    (:function, (:call, :islocked, (:(::), :l, :TatasLock)), (:block,
        (:line, 80, :none),
        (:return, (:call, :(!=), (:ref, (:., :l, (:quote, #QuoteNode
                  :handle
                ))), 0))
      )),
    (:line, 84, :none),
    "    RecursiveTatasLock()\n\nSee RecursiveSpinLock.\n",
    (:line, 89, :none),
    (:type, false, (:<:, :RecursiveTatasLock, :AbstractLock), (:block,
        (:line, 90, :none),
        (:(::), :ownertid, (:curly, :Atomic, :Int16)),
        (:line, 91, :none),
        (:(::), :handle, (:curly, :Atomic, :Int)),
        (:line, 92, :none),
        (:(=), (:call, :RecursiveTatasLock), (:block,
            (:line, 92, :none),
            (:call, :new, (:call, (:curly, :Atomic, :Int16), 0), (:call, (:curly, :Atomic, :Int), 0))
          ))
      )),
    (:line, 95, :none),
    "    RecursiveSpinLock()\n\nCreates a reentrant lock.\nThe same thread can acquire the lock as many times as required.\nEach `lock` must be matched with an `unlock`.\n\nSee also SpinLock for a slightly faster version.\n\nSee also Mutex for a more efficient version on one core or if the lock may be held for a considerable length of time.\n",
    (:line, 106, :none),
    (:typealias, :RecursiveSpinLock, :RecursiveTatasLock),
    (:line, 108, :none),
    (:function, (:call, :lock, (:(::), :l, :RecursiveTatasLock)), (:block,
        (:line, 109, :none),
        (:if, (:call, :(==), (:ref, (:., :l, (:quote, #QuoteNode
                  :ownertid
                ))), (:call, :threadid)), (:block,
            (:line, 110, :none),
            (:+=, (:ref, (:., :l, (:quote, #QuoteNode
                    :handle
                  ))), 1),
            (:line, 111, :none),
            (:return, nothing)
          )),
        (:line, 113, :none),
        (:while, true, (:block,
            (:line, 114, :none),
            (:if, (:call, :(==), (:ref, (:., :l, (:quote, #QuoteNode
                      :handle
                    ))), 0), (:block,
                (:line, 115, :none),
                (:if, (:call, :(==), (:call, :atomic_cas!, (:., :l, (:quote, #QuoteNode
                          :handle
                        )), 0, 1), 0), (:block,
                    (:line, 116, :none),
                    (:(=), (:ref, (:., :l, (:quote, #QuoteNode
                            :ownertid
                          ))), (:call, :threadid)),
                    (:line, 117, :none),
                    (:return, nothing)
                  ))
              )),
            (:line, 120, :none),
            (:ccall, (:quote, #QuoteNode
                :jl_cpu_pause
              ), :Void, (:tuple,)),
            (:line, 122, :none),
            (:ccall, (:quote, #QuoteNode
                :jl_gc_safepoint
              ), :Void, (:tuple,))
          ))
      )),
    (:line, 126, :none),
    (:function, (:call, :trylock, (:(::), :l, :RecursiveTatasLock)), (:block,
        (:line, 127, :none),
        (:if, (:call, :(==), (:ref, (:., :l, (:quote, #QuoteNode
                  :ownertid
                ))), (:call, :threadid)), (:block,
            (:line, 128, :none),
            (:+=, (:ref, (:., :l, (:quote, #QuoteNode
                    :handle
                  ))), 1),
            (:line, 129, :none),
            (:return, true)
          )),
        (:line, 131, :none),
        (:if, (:call, :(==), (:ref, (:., :l, (:quote, #QuoteNode
                  :handle
                ))), 0), (:block,
            (:line, 132, :none),
            (:if, (:call, :(==), (:call, :atomic_cas!, (:., :l, (:quote, #QuoteNode
                      :handle
                    )), 0, 1), 0), (:block,
                (:line, 133, :none),
                (:(=), (:ref, (:., :l, (:quote, #QuoteNode
                        :ownertid
                      ))), (:call, :threadid)),
                (:line, 134, :none),
                (:return, true)
              )),
            (:line, 136, :none),
            (:return, false)
          )),
        (:line, 138, :none),
        (:return, false)
      )),
    (:line, 141, :none),
    (:function, (:call, :unlock, (:(::), :l, :RecursiveTatasLock)), (:block,
        (:line, 142, :none),
        (:macrocall, Symbol("@assert"), (:call, :(==), (:ref, (:., :l, (:quote, #QuoteNode
                  :ownertid
                ))), (:call, :threadid)), "unlock from wrong thread"),
        (:line, 143, :none),
        (:macrocall, Symbol("@assert"), (:call, :(!=), (:ref, (:., :l, (:quote, #QuoteNode
                  :handle
                ))), 0), "unlock count must match lock count"),
        (:line, 144, :none),
        (:if, (:call, :(==), (:ref, (:., :l, (:quote, #QuoteNode
                  :handle
                ))), 1), (:block,
            (:line, 145, :none),
            (:(=), (:ref, (:., :l, (:quote, #QuoteNode
                    :ownertid
                  ))), 0),
            (:line, 146, :none),
            (:(=), (:ref, (:., :l, (:quote, #QuoteNode
                    :handle
                  ))), 0),
            (:line, 147, :none),
            (:ccall, (:quote, #QuoteNode
                :jl_cpu_wake
              ), :Void, (:tuple,))
          ), (:block,
            (:line, 149, :none),
            (:-=, (:ref, (:., :l, (:quote, #QuoteNode
                    :handle
                  ))), 1)
          )),
        (:line, 151, :none),
        (:return, nothing)
      )),
    (:line, 154, :none),
    (:function, (:call, :islocked, (:(::), :l, :RecursiveTatasLock)), (:block,
        (:line, 155, :none),
        (:return, (:call, :(!=), (:ref, (:., :l, (:quote, #QuoteNode
                  :handle
                ))), 0))
      )),
    (:line, 170, :none),
    (:const, (:(=), :UV_MUTEX_SIZE, (:ccall, (:quote, #QuoteNode
            :jl_sizeof_uv_mutex
          ), :Cint, (:tuple,)))),
    (:line, 172, :none),
    "    Mutex()\n\nThese are standard system mutexes for locking critical sections of logic.\n\nOn Windows, this is a critical section object,\non pthreads, this is a `pthread_mutex_t`.\n\nSee also SpinLock for a lighter-weight lock.\n",
    (:line, 182, :none),
    (:type, true, (:<:, :Mutex, :AbstractLock), (:block,
        (:line, 183, :none),
        (:(::), :ownertid, :Int16),
        (:line, 184, :none),
        (:(::), :handle, (:curly, :Ptr, :Void)),
        (:line, 185, :none),
        (:function, (:call, :Mutex), (:block,
            (:line, 186, :none),
            (:(=), :m, (:call, :new, (:call, :zero, :Int16), (:call, (:., :Libc, (:quote, #QuoteNode
                      :malloc
                    )), :UV_MUTEX_SIZE))),
            (:line, 187, :none),
            (:ccall, (:quote, #QuoteNode
                :uv_mutex_init
              ), :Void, (:tuple, (:curly, :Ptr, :Void)), (:., :m, (:quote, #QuoteNode
                  :handle
                ))),
            (:line, 188, :none),
            (:call, :finalizer, :m, :_uv_hook_close),
            (:line, 189, :none),
            (:return, :m)
          ))
      )),
    (:line, 193, :none),
    (:(=), (:call, :unsafe_convert, (:(::), (:curly, :Type, (:curly, :Ptr, :Void))), (:(::), :m, :Mutex)), (:block,
        (:line, 193, :none),
        (:., :m, (:quote, #QuoteNode
            :handle
          ))
      )),
    (:line, 195, :none),
    (:function, (:call, :_uv_hook_close, (:(::), :x, :Mutex)), (:block,
        (:line, 196, :none),
        (:(=), :h, (:., :x, (:quote, #QuoteNode
              :handle
            ))),
        (:line, 197, :none),
        (:if, (:call, :(!=), :h, :C_NULL), (:block,
            (:line, 198, :none),
            (:(=), (:., :x, (:quote, #QuoteNode
                  :handle
                )), :C_NULL),
            (:line, 199, :none),
            (:ccall, (:quote, #QuoteNode
                :uv_mutex_destroy
              ), :Void, (:tuple, (:curly, :Ptr, :Void)), :h),
            (:line, 200, :none),
            (:call, (:., :Libc, (:quote, #QuoteNode
                  :free
                )), :h),
            (:line, 201, :none),
            :nothing
          ))
      )),
    (:line, 205, :none),
    (:function, (:call, :lock, (:(::), :m, :Mutex)), (:block,
        (:line, 206, :none),
        (:if, (:call, :(==), (:., :m, (:quote, #QuoteNode
                :ownertid
              )), (:call, :threadid)), (:block,
            (:line, 207, :none),
            (:return, nothing)
          )),
        (:line, 211, :none),
        (:(=), :gc_state, (:ccall, (:quote, #QuoteNode
              :jl_gc_safe_enter
            ), :Int8, (:tuple,))),
        (:line, 212, :none),
        (:ccall, (:quote, #QuoteNode
            :uv_mutex_lock
          ), :Void, (:tuple, (:curly, :Ptr, :Void)), :m),
        (:line, 213, :none),
        (:ccall, (:quote, #QuoteNode
            :jl_gc_safe_leave
          ), :Void, (:tuple, :Int8), :gc_state),
        (:line, 214, :none),
        (:(=), (:., :m, (:quote, #QuoteNode
              :ownertid
            )), (:call, :threadid)),
        (:line, 215, :none),
        (:return, nothing)
      )),
    (:line, 218, :none),
    (:function, (:call, :trylock, (:(::), :m, :Mutex)), (:block,
        (:line, 219, :none),
        (:if, (:call, :(==), (:., :m, (:quote, #QuoteNode
                :ownertid
              )), (:call, :threadid)), (:block,
            (:line, 220, :none),
            (:return, true)
          )),
        (:line, 222, :none),
        (:(=), :r, (:ccall, (:quote, #QuoteNode
              :uv_mutex_trylock
            ), :Cint, (:tuple, (:curly, :Ptr, :Void)), :m)),
        (:line, 223, :none),
        (:if, (:call, :(==), :r, 0), (:block,
            (:line, 224, :none),
            (:(=), (:., :m, (:quote, #QuoteNode
                  :ownertid
                )), (:call, :threadid))
          )),
        (:line, 226, :none),
        (:return, (:call, :(==), :r, 0))
      )),
    (:line, 229, :none),
    (:function, (:call, :unlock, (:(::), :m, :Mutex)), (:block,
        (:line, 230, :none),
        (:macrocall, Symbol("@assert"), (:call, :(==), (:., :m, (:quote, #QuoteNode
                :ownertid
              )), (:call, :threadid)), "unlock from wrong thread"),
        (:line, 231, :none),
        (:(=), (:., :m, (:quote, #QuoteNode
              :ownertid
            )), 0),
        (:line, 232, :none),
        (:ccall, (:quote, #QuoteNode
            :uv_mutex_unlock
          ), :Void, (:tuple, (:curly, :Ptr, :Void)), :m),
        (:line, 233, :none),
        (:return, nothing)
      )),
    (:line, 236, :none),
    (:function, (:call, :islocked, (:(::), :m, :Mutex)), (:block,
        (:line, 237, :none),
        (:return, (:call, :(!=), (:., :m, (:quote, #QuoteNode
                :ownertid
              )), 0))
      ))
  ))