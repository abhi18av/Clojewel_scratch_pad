(:quote, (:block,
    (:line, 5, :none),
    (:(=), (:call, :isreal, (:(::), :x, :AbstractArray)), (:block,
        (:line, 5, :none),
        (:call, :all, :isreal, :x)
      )),
    (:line, 6, :none),
    (:(=), (:call, :iszero, (:(::), :x, :AbstractArray)), (:block,
        (:line, 6, :none),
        (:call, :all, :iszero, :x)
      )),
    (:line, 7, :none),
    (:(=), (:call, :isreal, (:(::), :x, (:curly, :AbstractArray, (:<:, :Real)))), (:block,
        (:line, 7, :none),
        true
      )),
    (:line, 8, :none),
    (:(=), (:call, :all, (:(::), (:call, :typeof, :isinteger)), (:(::), (:curly, :AbstractArray, (:<:, :Integer)))), (:block,
        (:line, 8, :none),
        true
      )),
    (:line, 12, :none),
    (:macrocall, :(Core.@doc), "    vec(a::AbstractArray) -> Vector\n\nReshape the array `a` as a one-dimensional column vector. The resulting array\nshares the same underlying data as `a`, so modifying one will also modify the\nother.\n\n```jldoctest\njulia> a = [1 2 3; 4 5 6]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> vec(a)\n6-element Array{Int64,1}:\n 1\n 4\n 2\n 5\n 3\n 6\n```\n\nSee also [`reshape`](@ref).\n", (:(=), (:call, :vec, (:(::), :a, :AbstractArray)), (:block,
          (:line, 37, :none),
          (:call, :reshape, :a, (:call, :_length, :a))
        ))),
    (:line, 38, :none),
    (:(=), (:call, :vec, (:(::), :a, :AbstractVector)), (:block,
        (:line, 38, :none),
        :a
      )),
    (:line, 40, :none),
    (:(=), (:call, :_sub, (:(::), (:curly, :Tuple)), (:(::), (:curly, :Tuple))), (:block,
        (:line, 40, :none),
        (:tuple,)
      )),
    (:line, 41, :none),
    (:(=), (:call, :_sub, (:(::), :t, :Tuple), (:(::), (:curly, :Tuple))), (:block,
        (:line, 41, :none),
        :t
      )),
    (:line, 42, :none),
    (:(=), (:call, :_sub, (:(::), :t, :Tuple), (:(::), :s, :Tuple)), (:block,
        (:line, 42, :none),
        (:call, :_sub, (:call, :tail, :t), (:call, :tail, :s))
      )),
    (:line, 44, :none),
    (:macrocall, :(Core.@doc), "    squeeze(A, dims)\n\nRemove the dimensions specified by `dims` from array `A`.\nElements of `dims` must be unique and within the range `1:ndims(A)`.\n`size(A,i)` must equal 1 for all `i` in `dims`.\n\n```jldoctest\njulia> a = reshape(collect(1:4),(2,2,1,1))\n2×2×1×1 Array{Int64,4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\njulia> squeeze(a,3)\n2×2×1 Array{Int64,3}:\n[:, :, 1] =\n 1  3\n 2  4\n```\n", (:function, (:call, :squeeze, (:(::), :A, :AbstractArray), (:(::), :dims, :Dims)), (:block,
          (:line, 66, :none),
          (:for, (:(=), :i, (:(:), 1, (:call, :length, :dims))), (:block,
              (:line, 67, :none),
              (:||, (:comparison, 1, :(<=), (:ref, :dims, :i), :(<=), (:call, :ndims, :A)), (:call, :throw, (:call, :ArgumentError, "squeezed dims must be in range 1:ndims(A)"))),
              (:line, 68, :none),
              (:||, (:call, :(==), (:call, :size, :A, (:ref, :dims, :i)), 1), (:call, :throw, (:call, :ArgumentError, "squeezed dims must all be size 1"))),
              (:line, 69, :none),
              (:for, (:(=), :j, (:(:), 1, (:call, :-, :i, 1))), (:block,
                  (:line, 70, :none),
                  (:&&, (:call, :(==), (:ref, :dims, :j), (:ref, :dims, :i)), (:call, :throw, (:call, :ArgumentError, "squeezed dims must be unique")))
                ))
            )),
          (:line, 73, :none),
          (:(=), :d, (:tuple,)),
          (:line, 74, :none),
          (:for, (:(=), :i, (:(:), 1, (:call, :ndims, :A))), (:block,
              (:line, 75, :none),
              (:if, (:call, :!, (:call, :in, :i, :dims)), (:block,
                  (:line, 76, :none),
                  (:(=), :d, (:call, :tuple, (:..., :d), (:call, :size, :A, :i)))
                ))
            )),
          (:line, 79, :none),
          (:call, :reshape, :A, (:(::), :d, (:call, :typeof, (:call, :_sub, (:call, :size, :A), :dims))))
        ))),
    (:line, 82, :none),
    (:(=), (:call, :squeeze, (:(::), :A, :AbstractArray), (:(::), :dim, :Integer)), (:block,
        (:line, 82, :none),
        (:call, :squeeze, :A, (:tuple, (:call, :Int, :dim)))
      )),
    (:line, 87, :none),
    (:(=), (:call, :conj, (:(::), :x, (:curly, :AbstractArray, (:<:, :Real)))), (:block,
        (:line, 87, :none),
        :x
      )),
    (:line, 88, :none),
    (:(=), (:call, :conj!, (:(::), :x, (:curly, :AbstractArray, (:<:, :Real)))), (:block,
        (:line, 88, :none),
        :x
      )),
    (:line, 90, :none),
    (:(=), (:call, :real, (:(::), :x, (:curly, :AbstractArray, (:<:, :Real)))), (:block,
        (:line, 90, :none),
        :x
      )),
    (:line, 91, :none),
    (:(=), (:call, :imag, (:(::), :x, (:curly, :AbstractArray, (:<:, :Real)))), (:block,
        (:line, 91, :none),
        (:call, :zero, :x)
      )),
    (:line, 93, :none),
    (:(=), (:call, :+, (:(::), :x, (:curly, :AbstractArray, (:<:, :Number)))), (:block,
        (:line, 93, :none),
        :x
      )),
    (:line, 94, :none),
    (:(=), (:call, :*, (:(::), :x, (:curly, :AbstractArray, (:<:, :Number), 2))), (:block,
        (:line, 94, :none),
        :x
      )),
    (:line, 98, :none),
    (:macrocall, :(Core.@doc), "    slicedim(A, d::Integer, i)\n\nReturn all the data of `A` where the index for dimension `d` equals `i`. Equivalent to\n`A[:,:,...,i,:,:,...]` where `i` is in position `d`.\n\n```jldoctest\njulia> A = [1 2 3 4; 5 6 7 8]\n2×4 Array{Int64,2}:\n 1  2  3  4\n 5  6  7  8\n\njulia> slicedim(A,2,3)\n2-element Array{Int64,1}:\n 3\n 7\n```\n", (:function, (:call, :slicedim, (:(::), :A, :AbstractArray), (:(::), :d, :Integer), :i), (:block,
          (:line, 117, :none),
          (:||, (:call, :(>=), :d, 1), (:call, :throw, (:call, :ArgumentError, "dimension must be ≥ 1"))),
          (:line, 118, :none),
          (:(=), :nd, (:call, :ndims, :A)),
          (:line, 119, :none),
          (:&&, (:call, :>, :d, :nd), (:||, (:call, :(==), :i, 1), (:call, :throw_boundserror, :A, (:tuple, (:..., (:call, :ntuple, (:->, :k, (:block,
                          (:line, 119, :none),
                          (:call, :Colon)
                        )), :nd)), (:..., (:call, :ntuple, (:->, :k, (:block,
                          (:line, 119, :none),
                          1
                        )), (:call, :-, (:call, :-, :d, 1), :nd))), :i)))),
          (:line, 120, :none),
          (:ref, :A, (:..., (:call, :setindex, (:call, :indices, :A), :i, :d)))
        ))),
    (:line, 123, :none),
    (:macrocall, :(Core.@doc), "    flipdim(A, d::Integer)\n\nReverse `A` in dimension `d`.\n\n```jldoctest\njulia> b = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> flipdim(b,2)\n2×2 Array{Int64,2}:\n 2  1\n 4  3\n```\n", (:function, (:call, :flipdim, (:(::), :A, :AbstractArray), (:(::), :d, :Integer)), (:block,
          (:line, 141, :none),
          (:(=), :nd, (:call, :ndims, :A)),
          (:line, 142, :none),
          (:||, (:comparison, 1, :≤, :d, :≤, :nd), (:call, :throw, (:call, :ArgumentError, (:string, "dimension ", :d, " is not 1 ≤ ", :d, " ≤ ", :nd)))),
          (:line, 143, :none),
          (:if, (:call, :isempty, :A), (:block,
              (:line, 144, :none),
              (:return, (:call, :copy, :A))
            ), (:block,
              (:line, 145, :none),
              (:if, (:call, :(==), :nd, 1), (:block,
                  (:line, 146, :none),
                  (:return, (:call, :reverse, :A))
                ))
            )),
          (:line, 148, :none),
          (:(=), :inds, (:call, :indices, :A)),
          (:line, 149, :none),
          (:(=), :B, (:call, :similar, :A)),
          (:line, 150, :none),
          (:(=), :nnd, 0),
          (:line, 151, :none),
          (:for, (:(=), :i, (:(:), 1, :nd)), (:block,
              (:line, 152, :none),
              (:+=, :nnd, (:call, :Int, (:||, (:call, :(==), (:call, :length, (:ref, :inds, :i)), 1), (:call, :(==), :i, :d))))
            )),
          (:line, 154, :none),
          (:(=), :indsd, (:ref, :inds, :d)),
          (:line, 155, :none),
          (:(=), :sd, (:call, :+, (:call, :first, :indsd), (:call, :last, :indsd))),
          (:line, 156, :none),
          (:if, (:call, :(==), :nnd, :nd), (:block,
              (:line, 158, :none),
              (:for, (:(=), :i, :indsd), (:block,
                  (:line, 159, :none),
                  (:(=), (:ref, :B, :i), (:ref, :A, (:call, :-, :sd, :i)))
                )),
              (:line, 161, :none),
              (:return, :B)
            )),
          (:line, 163, :none),
          (:(=), :alli, (:comprehension, (:generator, (:call, :indices, :B, :n), (:(=), :n, (:(:), 1, :nd))))),
          (:line, 164, :none),
          (:for, (:(=), :i, :indsd), (:block,
              (:line, 165, :none),
              (:(=), (:ref, :B, (:..., (:comprehension, (:generator, (:if, (:call, :(==), :n, :d), (:call, :-, :sd, :i), (:ref, :alli, :n)), (:(=), :n, (:(:), 1, :nd)))))), (:call, :slicedim, :A, :d, :i))
            )),
          (:line, 167, :none),
          (:return, :B)
        ))),
    (:line, 170, :none),
    (:function, (:call, :circshift, (:(::), :a, :AbstractArray), (:(::), :shiftamt, :Real)), (:block,
        (:line, 171, :none),
        (:call, :circshift!, (:call, :similar, :a), :a, (:tuple, (:call, :Integer, :shiftamt)))
      )),
    (:line, 173, :none),
    (:(=), (:call, :circshift, (:(::), :a, :AbstractArray), (:(::), :shiftamt, :DimsInteger)), (:block,
        (:line, 173, :none),
        (:call, :circshift!, (:call, :similar, :a), :a, :shiftamt)
      )),
    (:line, 174, :none),
    (:macrocall, :(Core.@doc), "    circshift(A, shifts)\n\nCircularly shift the data in an array. The second argument is a vector giving the amount to\nshift in each dimension.\n\n```jldoctest\njulia> b = reshape(collect(1:16), (4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> circshift(b, (0,2))\n4×4 Array{Int64,2}:\n  9  13  1  5\n 10  14  2  6\n 11  15  3  7\n 12  16  4  8\n\njulia> circshift(b, (-1,0))\n4×4 Array{Int64,2}:\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n 1  5   9  13\n```\n\nSee also [`circshift!`](@ref).\n", (:function, (:call, :circshift, (:(::), :a, :AbstractArray), :shiftamt), (:block,
          (:line, 206, :none),
          (:call, :circshift!, (:call, :similar, :a), :a, (:call, :map, :Integer, (:tuple, (:..., :shiftamt))))
        ))),
    (:line, 210, :none),
    (:function, (:where, (:call, :cumsum_kbn, (:(::), :v, (:curly, :AbstractVector, :T))), (:<:, :T, :AbstractFloat)), (:block,
        (:line, 211, :none),
        (:(=), :r, (:call, :similar, :v)),
        (:line, 212, :none),
        (:if, (:call, :isempty, :v), (:block,
            (:line, 212, :none),
            (:return, :r)
          )),
        (:line, 214, :none),
        (:(=), :inds, (:call, :indices, :v, 1)),
        (:line, 215, :none),
        (:(=), :i1, (:call, :first, :inds)),
        (:line, 216, :none),
        (:(=), :s, (:(=), (:ref, :r, :i1), (:ref, :v, :i1))),
        (:line, 217, :none),
        (:(=), :c, (:call, :zero, :T)),
        (:line, 218, :none),
        (:for, (:(=), :i, (:(:), (:call, :+, :i1, 1), (:call, :last, :inds))), (:block,
            (:line, 219, :none),
            (:(=), :vi, (:ref, :v, :i)),
            (:line, 220, :none),
            (:(=), :t, (:call, :+, :s, :vi)),
            (:line, 221, :none),
            (:if, (:call, :(>=), (:call, :abs, :s), (:call, :abs, :vi)), (:block,
                (:line, 222, :none),
                (:+=, :c, (:call, :+, (:call, :-, :s, :t), :vi))
              ), (:block,
                (:line, 224, :none),
                (:+=, :c, (:call, :+, (:call, :-, :vi, :t), :s))
              )),
            (:line, 226, :none),
            (:(=), :s, :t),
            (:line, 227, :none),
            (:(=), (:ref, :r, :i), (:call, :+, :s, :c))
          )),
        (:line, 229, :none),
        (:return, :r)
      )),
    (:line, 235, :none),
    (:macrocall, :(Core.@doc), "    cumsum_kbn(A, [dim::Integer=1])\n\nCumulative sum along a dimension, using the Kahan-Babuska-Neumaier compensated summation\nalgorithm for additional accuracy. The dimension defaults to 1.\n", (:function, (:where, (:call, :cumsum_kbn, (:(::), :A, (:curly, :AbstractArray, :T)), (:kw, (:(::), :axis, :Integer), 1)), (:<:, :T, :AbstractFloat)), (:block,
          (:line, 242, :none),
          (:(=), :dimsA, (:call, :size, :A)),
          (:line, 243, :none),
          (:(=), :ndimsA, (:call, :ndims, :A)),
          (:line, 244, :none),
          (:(=), :axis_size, (:ref, :dimsA, :axis)),
          (:line, 245, :none),
          (:(=), :axis_stride, 1),
          (:line, 246, :none),
          (:for, (:(=), :i, (:(:), 1, (:call, :-, :axis, 1))), (:block,
              (:line, 247, :none),
              (:*=, :axis_stride, (:call, :size, :A, :i))
            )),
          (:line, 250, :none),
          (:if, (:call, :(<=), :axis_size, 1), (:block,
              (:line, 251, :none),
              (:return, :A)
            )),
          (:line, 254, :none),
          (:(=), :B, (:call, :similar, :A)),
          (:line, 255, :none),
          (:(=), :C, (:call, :similar, :A)),
          (:line, 257, :none),
          (:for, (:(=), :i, (:(:), 1, (:call, :length, :A))), (:block,
              (:line, 258, :none),
              (:if, (:call, :(==), (:call, :%, (:call, :div, (:call, :-, :i, 1), :axis_stride), :axis_size), 0), (:block,
                  (:line, 259, :none),
                  (:(=), (:ref, :B, :i), (:ref, :A, :i)),
                  (:line, 260, :none),
                  (:(=), (:ref, :C, :i), (:call, :zero, :T))
                ), (:block,
                  (:line, 262, :none),
                  (:(=), :s, (:ref, :B, (:call, :-, :i, :axis_stride))),
                  (:line, 263, :none),
                  (:(=), :Ai, (:ref, :A, :i)),
                  (:line, 264, :none),
                  (:(=), (:ref, :B, :i), (:(=), :t, (:call, :+, :s, :Ai))),
                  (:line, 265, :none),
                  (:if, (:call, :(>=), (:call, :abs, :s), (:call, :abs, :Ai)), (:block,
                      (:line, 266, :none),
                      (:(=), (:ref, :C, :i), (:call, :+, (:ref, :C, (:call, :-, :i, :axis_stride)), (:call, :+, (:call, :-, :s, :t), :Ai)))
                    ), (:block,
                      (:line, 268, :none),
                      (:(=), (:ref, :C, :i), (:call, :+, (:ref, :C, (:call, :-, :i, :axis_stride)), (:call, :+, (:call, :-, :Ai, :t), :s)))
                    ))
                ))
            )),
          (:line, 273, :none),
          (:return, (:call, :+, :B, :C))
        ))),
    (:line, 278, :none),
    (:macrocall, :(Core.@doc), "    repmat(A, m::Integer, n::Integer=1)\n\nConstruct a matrix by repeating the given matrix (or vector) `m` times in dimension 1 and `n` times in\ndimension 2.\n\n```jldoctest\njulia> repmat([1, 2, 3], 2)\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 1\n 2\n 3\n\njulia> repmat([1, 2, 3], 2, 3)\n6×3 Array{Int64,2}:\n 1  1  1\n 2  2  2\n 3  3  3\n 1  1  1\n 2  2  2\n 3  3  3\n```\n", (:function, (:call, :repmat, (:(::), :a, :AbstractVecOrMat), (:(::), :m, :Int), (:kw, (:(::), :n, :Int), 1)), (:block,
          (:line, 305, :none),
          (:(=), (:tuple, :o, :p), (:tuple, (:call, :size, :a, 1), (:call, :size, :a, 2))),
          (:line, 306, :none),
          (:(=), :b, (:call, :similar, :a, (:call, :*, :o, :m), (:call, :*, :p, :n))),
          (:line, 307, :none),
          (:for, (:(=), :j, (:(:), 1, :n)), (:block,
              (:line, 308, :none),
              (:(=), :d, (:call, :+, (:call, :*, (:call, :-, :j, 1), :p), 1)),
              (:line, 309, :none),
              (:(=), :R, (:(:), :d, (:call, :-, (:call, :+, :d, :p), 1))),
              (:line, 310, :none),
              (:for, (:(=), :i, (:(:), 1, :m)), (:block,
                  (:line, 311, :none),
                  (:(=), :c, (:call, :+, (:call, :*, (:call, :-, :i, 1), :o), 1)),
                  (:line, 312, :none),
                  (:(=), (:ref, :b, (:(:), :c, (:call, :-, (:call, :+, :c, :o), 1)), :R), :a)
                ))
            )),
          (:line, 315, :none),
          (:return, :b)
        ))),
    (:line, 318, :none),
    (:function, (:call, :repmat, (:(::), :a, :AbstractVector), (:(::), :m, :Int)), (:block,
        (:line, 319, :none),
        (:(=), :o, (:call, :length, :a)),
        (:line, 320, :none),
        (:(=), :b, (:call, :similar, :a, (:call, :*, :o, :m))),
        (:line, 321, :none),
        (:for, (:(=), :i, (:(:), 1, :m)), (:block,
            (:line, 322, :none),
            (:(=), :c, (:call, :+, (:call, :*, (:call, :-, :i, 1), :o), 1)),
            (:line, 323, :none),
            (:(=), (:ref, :b, (:(:), :c, (:call, :-, (:call, :+, :c, :o), 1))), :a)
          )),
        (:line, 325, :none),
        (:return, :b)
      )),
    (:line, 328, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :repmat, (:(::), :a, :AbstractVecOrMat), (:(::), :m, :Integer), (:kw, (:(::), :n, :Integer), 1)), (:block,
          (:line, 328, :none),
          (:call, :repmat, :a, (:call, :Int, :m), (:call, :Int, :n))
        ))),
    (:line, 329, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :repmat, (:(::), :a, :AbstractVector), (:(::), :m, :Integer)), (:block,
          (:line, 329, :none),
          (:call, :repmat, :a, (:call, :Int, :m))
        ))),
    (:line, 331, :none),
    (:macrocall, :(Core.@doc), "    repeat(A::AbstractArray; inner=ntuple(x->1, ndims(A)), outer=ntuple(x->1, ndims(A)))\n\nConstruct an array by repeating the entries of `A`. The i-th element of `inner` specifies\nthe number of times that the individual entries of the i-th dimension of `A` should be\nrepeated. The i-th element of `outer` specifies the number of times that a slice along the\ni-th dimension of `A` should be repeated. If `inner` or `outer` are omitted, no repetition\nis performed.\n\n```jldoctest\njulia> repeat(1:2, inner=2)\n4-element Array{Int64,1}:\n 1\n 1\n 2\n 2\n\njulia> repeat(1:2, outer=2)\n4-element Array{Int64,1}:\n 1\n 2\n 1\n 2\n\njulia> repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))\n4×6 Array{Int64,2}:\n 1  2  1  2  1  2\n 1  2  1  2  1  2\n 3  4  3  4  3  4\n 3  4  3  4  3  4\n```\n", (:function, (:call, :repeat, (:parameters, (:kw, :inner, (:call, :ntuple, (:->, :n, (:block,
                    (:line, 364, :none),
                    1
                  )), (:curly, :Val, (:call, :ndims, :A)))), (:kw, :outer, (:call, :ntuple, (:->, :n, (:block,
                    (:line, 365, :none),
                    1
                  )), (:curly, :Val, (:call, :ndims, :A))))), (:(::), :A, :AbstractArray)), (:block,
          (:line, 366, :none),
          (:return, (:call, :_repeat, :A, (:call, :rep_kw2tup, :inner), (:call, :rep_kw2tup, :outer)))
        ))),
    (:line, 369, :none),
    (:(=), (:call, :rep_kw2tup, (:(::), :n, :Integer)), (:block,
        (:line, 369, :none),
        (:tuple, :n)
      )),
    (:line, 370, :none),
    (:(=), (:call, :rep_kw2tup, (:(::), :v, (:curly, :AbstractArray, (:<:, :Integer)))), (:block,
        (:line, 370, :none),
        (:tuple, (:..., :v))
      )),
    (:line, 371, :none),
    (:(=), (:call, :rep_kw2tup, (:(::), :t, :Tuple)), (:block,
        (:line, 371, :none),
        :t
      )),
    (:line, 373, :none),
    (:(=), (:call, :rep_shapes, :A, :i, :o), (:block,
        (:line, 373, :none),
        (:call, :_rshps, (:tuple,), (:tuple,), (:call, :size, :A), :i, :o)
      )),
    (:line, 375, :none),
    (:(=), (:call, :_rshps, :shp, :shp_i, (:(::), (:curly, :Tuple)), (:(::), (:curly, :Tuple)), (:(::), (:curly, :Tuple))), (:block,
        (:line, 375, :none),
        (:tuple, :shp, :shp_i)
      )),
    (:line, 376, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :_rshps, :shp, :shp_i, (:(::), (:curly, :Tuple)), (:(::), (:curly, :Tuple)), :o), (:block,
          (:line, 376, :none),
          (:call, :_rshps, (:tuple, (:..., :shp), (:ref, :o, 1)), (:tuple, (:..., :shp_i), 1), (:tuple,), (:tuple,), (:call, :tail, :o))
        ))),
    (:line, 378, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :_rshps, :shp, :shp_i, (:(::), (:curly, :Tuple)), :i, (:(::), (:curly, :Tuple))), (:block,
          (:line, 378, :none),
          (:block,
            (:(=), :n, (:ref, :i, 1)),
            (:call, :_rshps, (:tuple, (:..., :shp), :n), (:tuple, (:..., :shp_i), :n), (:tuple,), (:call, :tail, :i), (:tuple,))
          )
        ))),
    (:line, 380, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :_rshps, :shp, :shp_i, (:(::), (:curly, :Tuple)), :i, :o), (:block,
          (:line, 380, :none),
          (:block,
            (:(=), :n, (:ref, :i, 1)),
            (:call, :_rshps, (:tuple, (:..., :shp), (:call, :*, :n, (:ref, :o, 1))), (:tuple, (:..., :shp_i), :n), (:tuple,), (:call, :tail, :i), (:call, :tail, :o))
          )
        ))),
    (:line, 382, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :_rshps, :shp, :shp_i, :sz, :i, :o), (:block,
          (:line, 382, :none),
          (:block,
            (:(=), :n, (:call, :*, (:ref, :sz, 1), (:ref, :i, 1))),
            (:call, :_rshps, (:tuple, (:..., :shp), (:call, :*, :n, (:ref, :o, 1))), (:tuple, (:..., :shp_i), :n), (:call, :tail, :sz), (:call, :tail, :i), (:call, :tail, :o))
          )
        ))),
    (:line, 384, :none),
    (:(=), (:call, :_rshps, :shp, :shp_i, :sz, (:(::), (:curly, :Tuple)), (:(::), (:curly, :Tuple))), (:block,
        (:line, 384, :none),
        (:block,
          (:(=), :n, (:call, :length, :shp)),
          (:(=), :N, (:call, :+, :n, (:call, :length, :sz))),
          (:call, :_reperr, "inner", :n, :N)
        )
      )),
    (:line, 386, :none),
    (:(=), (:call, :_rshps, :shp, :shp_i, :sz, (:(::), (:curly, :Tuple)), :o), (:block,
        (:line, 386, :none),
        (:block,
          (:(=), :n, (:call, :length, :shp)),
          (:(=), :N, (:call, :+, :n, (:call, :length, :sz))),
          (:call, :_reperr, "inner", :n, :N)
        )
      )),
    (:line, 388, :none),
    (:(=), (:call, :_rshps, :shp, :shp_i, :sz, :i, (:(::), (:curly, :Tuple))), (:block,
        (:line, 388, :none),
        (:block,
          (:(=), :n, (:call, :length, :shp)),
          (:(=), :N, (:call, :+, :n, (:call, :length, :sz))),
          (:call, :_reperr, "outer", :n, :N)
        )
      )),
    (:line, 390, :none),
    (:(=), (:call, :_reperr, :s, :n, :N), (:block,
        (:line, 390, :none),
        (:call, :throw, (:call, :ArgumentError, (:call, :*, "number of ", :s, " repetitions ", (:string, "(", :n, ") cannot be less than number of dimensions of input (", :N, ")"))))
      )),
    (:line, 393, :none),
    (:macrocall, Symbol("@propagate_inbounds"), (:function, (:call, :_repeat, (:(::), :A, :AbstractArray), :inner, :outer), (:block,
          (:line, 394, :none),
          (:(=), (:tuple, :shape, :inner_shape), (:call, :rep_shapes, :A, :inner, :outer)),
          (:line, 396, :none),
          (:(=), :R, (:call, :similar, :A, :shape)),
          (:line, 397, :none),
          (:if, (:call, :any, :iszero, :shape), (:block,
              (:line, 398, :none),
              (:return, :R)
            )),
          (:line, 402, :none),
          (:if, (:call, :all, (:->, :x, (:block,
                  (:line, 402, :none),
                  (:call, :(==), :x, 1)
                )), :inner), (:block,
              (:line, 403, :none),
              (:(=), (:ref, :R, (:..., (:call, :indices, :A))), :A)
            ), (:block,
              (:line, 405, :none),
              (:(=), :inner_indices, (:comprehension, (:generator, (:(:), 1, :n), (:(=), :n, :inner)))),
              (:line, 406, :none),
              (:for, (:(=), :c, (:call, :CartesianRange, (:call, :indices, :A))), (:block,
                  (:line, 407, :none),
                  (:for, (:(=), :i, (:(:), 1, (:call, :ndims, :A))), (:block,
                      (:line, 408, :none),
                      (:(=), :n, (:ref, :inner, :i)),
                      (:line, 409, :none),
                      (:(=), (:ref, :inner_indices, :i), (:call, :+, (:(:), 1, :n), (:call, :*, (:call, :-, (:ref, :c, :i), 1), :n)))
                    )),
                  (:line, 411, :none),
                  (:(=), (:ref, :R, (:..., :inner_indices)), (:ref, :A, :c))
                ))
            )),
          (:line, 416, :none),
          (:if, (:call, :all, (:->, :x, (:block,
                  (:line, 416, :none),
                  (:call, :(==), :x, 1)
                )), :outer), (:block,
              (:line, 417, :none),
              (:return, :R)
            )),
          (:line, 419, :none),
          (:(=), :src_indices, (:comprehension, (:generator, (:(:), 1, :n), (:(=), :n, :inner_shape)))),
          (:line, 420, :none),
          (:(=), :dest_indices, (:call, :copy, :src_indices)),
          (:line, 421, :none),
          (:for, (:(=), :i, (:(:), 1, (:call, :length, :outer))), (:block,
              (:line, 422, :none),
              (:(=), :B, (:call, :view, :R, (:..., :src_indices))),
              (:line, 423, :none),
              (:for, (:(=), :j, (:(:), 2, (:ref, :outer, :i))), (:block,
                  (:line, 424, :none),
                  (:+=, (:ref, :dest_indices, :i), (:ref, :inner_shape, :i)),
                  (:line, 425, :none),
                  (:(=), (:ref, :R, (:..., :dest_indices)), :B)
                )),
              (:line, 427, :none),
              (:(=), (:ref, :src_indices, :i), (:(=), (:ref, :dest_indices, :i), (:(:), 1, (:ref, :shape, :i))))
            )),
          (:line, 430, :none),
          (:return, :R)
        )))
  ))