(:quote, (:block,
    (:line, 3, :none),
    (:module, true, :DSP, (:block,
        (:line, 3, :none),
        (:line, 5, :none),
        (:import, :Base, :trailingsize),
        (:line, 7, :none),
        (:export, :filt, :filt!, :deconv, :conv, :conv2, :xcorr),
        (:line, 9, :none),
        (:(=), (:call, :_zerosi, :b, :a, :T), (:block,
            (:line, 9, :none),
            (:call, :zeros, (:call, :promote_type, (:call, :eltype, :b), (:call, :eltype, :a), :T), (:call, :-, (:call, :max, (:call, :length, :a), (:call, :length, :b)), 1))
          )),
        (:line, 11, :none),
        (:macrocall, :(Core.@doc), "    filt(b, a, x, [si])\n\nApply filter described by vectors `a` and `b` to vector `x`, with an optional initial filter\nstate vector `si` (defaults to zeros).\n", (:function, (:where, (:call, :filt, (:(::), :b, (:curly, :Union, :AbstractVector, :Number)), (:(::), :a, (:curly, :Union, :AbstractVector, :Number)), (:(::), :x, (:curly, :AbstractArray, :T)), (:kw, (:(::), :si, (:curly, :AbstractArray, :S)), (:call, :_zerosi, :b, :a, :T))), :T, :S), (:block,
              (:line, 19, :none),
              (:call, :filt!, (:call, (:curly, :Array, (:call, :promote_type, (:call, :eltype, :b), (:call, :eltype, :a), :T, :S)), (:call, :size, :x)), :b, :a, :x, :si)
            ))),
        (:line, 25, :none),
        (:macrocall, :(Core.@doc), "    filt!(out, b, a, x, [si])\n\nSame as [`filt`](@ref) but writes the result into the `out` argument, which may\nalias the input `x` to modify it in-place.\n", (:function, (:where, (:call, :filt!, (:(::), :out, :AbstractArray), (:(::), :b, (:curly, :Union, :AbstractVector, :Number)), (:(::), :a, (:curly, :Union, :AbstractVector, :Number)), (:(::), :x, (:curly, :AbstractArray, :T)), (:kw, (:(::), :si, (:curly, :AbstractArray, :S, :N)), (:call, :_zerosi, :b, :a, :T))), :T, :S, :N), (:block,
              (:line, 33, :none),
              (:&&, (:call, :isempty, :b), (:call, :throw, (:call, :ArgumentError, "filter vector b must be non-empty"))),
              (:line, 34, :none),
              (:&&, (:call, :isempty, :a), (:call, :throw, (:call, :ArgumentError, "filter vector a must be non-empty"))),
              (:line, 35, :none),
              (:&&, (:call, :(==), (:ref, :a, 1), 0), (:call, :throw, (:call, :ArgumentError, "filter vector a[1] must be nonzero"))),
              (:line, 36, :none),
              (:if, (:call, :(!=), (:call, :size, :x), (:call, :size, :out)), (:block,
                  (:line, 37, :none),
                  (:call, :throw, (:call, :ArgumentError, (:string, "output size ", (:call, :size, :out), " must match input size ", (:call, :size, :x))))
                )),
              (:line, 40, :none),
              (:(=), :as, (:call, :length, :a)),
              (:line, 41, :none),
              (:(=), :bs, (:call, :length, :b)),
              (:line, 42, :none),
              (:(=), :sz, (:call, :max, :as, :bs)),
              (:line, 43, :none),
              (:(=), :silen, (:call, :-, :sz, 1)),
              (:line, 44, :none),
              (:(=), :ncols, (:call, :trailingsize, :x, 2)),
              (:line, 46, :none),
              (:if, (:call, :(!=), (:call, :size, :si, 1), :silen), (:block,
                  (:line, 47, :none),
                  (:call, :throw, (:call, :ArgumentError, "initial state vector si must have max(length(a),length(b))-1 rows"))
                )),
              (:line, 49, :none),
              (:if, (:&&, (:call, :>, :N, 1), (:call, :(!=), (:call, :trailingsize, :si, 2), :ncols)), (:block,
                  (:line, 50, :none),
                  (:call, :throw, (:call, :ArgumentError, "initial state vector si must be a vector or have the same number of columns as x"))
                )),
              (:line, 53, :none),
              (:&&, (:call, :(==), (:call, :size, :x, 1), 0), (:return, :out)),
              (:line, 54, :none),
              (:&&, (:call, :(==), :sz, 1), (:return, (:call, :scale!, :out, :x, (:call, :/, (:ref, :b, 1), (:ref, :a, 1))))),
              (:line, 57, :none),
              (:if, (:call, :(!=), (:ref, :a, 1), 1), (:block,
                  (:line, 58, :none),
                  (:(=), :norml, (:ref, :a, 1)),
                  (:line, 59, :none),
                  (:./=, :a, :norml),
                  (:line, 60, :none),
                  (:./=, :b, :norml)
                )),
              (:line, 63, :none),
              (:&&, (:call, :<, :bs, :sz), (:(=), :b, (:call, :copy!, (:call, :zeros, (:call, :eltype, :b), :sz), :b))),
              (:line, 64, :none),
              (:&&, (:comparison, 1, :<, :as, :<, :sz), (:(=), :a, (:call, :copy!, (:call, :zeros, (:call, :eltype, :a), :sz), :a))),
              (:line, 66, :none),
              (:(=), :initial_si, :si),
              (:line, 67, :none),
              (:for, (:(=), :col, (:(:), 1, :ncols)), (:block,
                  (:line, 69, :none),
                  (:(=), :si, (:ref, :initial_si, :(:), (:if, (:call, :>, :N, 1), :col, 1))),
                  (:line, 70, :none),
                  (:if, (:call, :>, :as, 1), (:block,
                      (:line, 71, :none),
                      (:call, :_filt_iir!, :out, :b, :a, :x, :si, :col)
                    ), (:block,
                      (:line, 73, :none),
                      (:call, :_filt_fir!, :out, :b, :x, :si, :col)
                    ))
                )),
              (:line, 76, :none),
              (:return, :out)
            ))),
        (:line, 79, :none),
        (:function, (:call, :_filt_iir!, :out, :b, :a, :x, :si, :col), (:block,
            (:line, 80, :none),
            (:(=), :silen, (:call, :length, :si)),
            (:line, 81, :none),
            (:macrocall, Symbol("@inbounds"), (:for, (:(=), :i, (:(:), 1, (:call, :size, :x, 1))), (:block,
                  (:line, 82, :none),
                  (:(=), :xi, (:ref, :x, :i, :col)),
                  (:line, 83, :none),
                  (:(=), :val, (:call, :+, (:ref, :si, 1), (:call, :*, (:ref, :b, 1), :xi))),
                  (:line, 84, :none),
                  (:for, (:(=), :j, (:(:), 1, (:call, :-, :silen, 1))), (:block,
                      (:line, 85, :none),
                      (:(=), (:ref, :si, :j), (:call, :-, (:call, :+, (:ref, :si, (:call, :+, :j, 1)), (:call, :*, (:ref, :b, (:call, :+, :j, 1)), :xi)), (:call, :*, (:ref, :a, (:call, :+, :j, 1)), :val)))
                    )),
                  (:line, 87, :none),
                  (:(=), (:ref, :si, :silen), (:call, :-, (:call, :*, (:ref, :b, (:call, :+, :silen, 1)), :xi), (:call, :*, (:ref, :a, (:call, :+, :silen, 1)), :val))),
                  (:line, 88, :none),
                  (:(=), (:ref, :out, :i, :col), :val)
                )))
          )),
        (:line, 92, :none),
        (:function, (:call, :_filt_fir!, :out, :b, :x, :si, :col), (:block,
            (:line, 93, :none),
            (:(=), :silen, (:call, :length, :si)),
            (:line, 94, :none),
            (:macrocall, Symbol("@inbounds"), (:for, (:(=), :i, (:(:), 1, (:call, :size, :x, 1))), (:block,
                  (:line, 95, :none),
                  (:(=), :xi, (:ref, :x, :i, :col)),
                  (:line, 96, :none),
                  (:(=), :val, (:call, :+, (:ref, :si, 1), (:call, :*, (:ref, :b, 1), :xi))),
                  (:line, 97, :none),
                  (:for, (:(=), :j, (:(:), 1, (:call, :-, :silen, 1))), (:block,
                      (:line, 98, :none),
                      (:(=), (:ref, :si, :j), (:call, :+, (:ref, :si, (:call, :+, :j, 1)), (:call, :*, (:ref, :b, (:call, :+, :j, 1)), :xi)))
                    )),
                  (:line, 100, :none),
                  (:(=), (:ref, :si, :silen), (:call, :*, (:ref, :b, (:call, :+, :silen, 1)), :xi)),
                  (:line, 101, :none),
                  (:(=), (:ref, :out, :i, :col), :val)
                )))
          )),
        (:line, 105, :none),
        (:macrocall, :(Core.@doc), "    deconv(b,a) -> c\n\nConstruct vector `c` such that `b = conv(a,c) + r`.\nEquivalent to polynomial division.\n", (:function, (:where, (:call, :deconv, (:(::), :b, (:curly, :StridedVector, :T)), (:(::), :a, (:curly, :StridedVector, :T))), :T), (:block,
              (:line, 112, :none),
              (:(=), :lb, (:call, :size, :b, 1)),
              (:line, 113, :none),
              (:(=), :la, (:call, :size, :a, 1)),
              (:line, 114, :none),
              (:if, (:call, :<, :lb, :la), (:block,
                  (:line, 115, :none),
                  (:return, (:vect, (:call, :zero, :T)))
                )),
              (:line, 117, :none),
              (:(=), :lx, (:call, :+, (:call, :-, :lb, :la), 1)),
              (:line, 118, :none),
              (:(=), :x, (:call, :zeros, :T, :lx)),
              (:line, 119, :none),
              (:(=), (:ref, :x, 1), 1),
              (:line, 120, :none),
              (:call, :filt, :b, :a, :x)
            ))),
        (:line, 123, :none),
        (:macrocall, :(Core.@doc), "    conv(u,v)\n\nConvolution of two vectors. Uses FFT algorithm.\n", (:function, (:where, (:call, :conv, (:(::), :u, (:curly, :StridedVector, :T)), (:(::), :v, (:curly, :StridedVector, :T))), (:<:, :T, (:., (:., :Base, (:quote, #QuoteNode
                      :LinAlg
                    )), (:quote, #QuoteNode
                    :BlasFloat
                  )))), (:block,
              (:line, 129, :none),
              (:(=), :nu, (:call, :length, :u)),
              (:line, 130, :none),
              (:(=), :nv, (:call, :length, :v)),
              (:line, 131, :none),
              (:(=), :n, (:call, :-, (:call, :+, :nu, :nv), 1)),
              (:line, 132, :none),
              (:(=), :np2, (:if, (:call, :>, :n, 1024), (:call, :nextprod, (:vect, 2, 3, 5), :n), (:call, :nextpow2, :n))),
              (:line, 133, :none),
              (:(=), :upad, (:vcat, :u, (:call, :zeros, :T, (:call, :-, :np2, :nu)))),
              (:line, 134, :none),
              (:(=), :vpad, (:vcat, :v, (:call, :zeros, :T, (:call, :-, :np2, :nv)))),
              (:line, 135, :none),
              (:if, (:<:, :T, :Real), (:block,
                  (:line, 136, :none),
                  (:(=), :p, (:call, :plan_rfft, :upad)),
                  (:line, 137, :none),
                  (:(=), :y, (:call, :irfft, (:call, :.*, (:call, :*, :p, :upad), (:call, :*, :p, :vpad)), :np2))
                ), (:block,
                  (:line, 139, :none),
                  (:(=), :p, (:call, :plan_fft!, :upad)),
                  (:line, 140, :none),
                  (:(=), :y, (:call, :ifft!, (:call, :.*, (:call, :*, :p, :upad), (:call, :*, :p, :vpad))))
                )),
              (:line, 142, :none),
              (:return, (:ref, :y, (:(:), 1, :n)))
            ))),
        (:line, 144, :none),
        (:(=), (:where, (:call, :conv, (:(::), :u, (:curly, :StridedVector, :T)), (:(::), :v, (:curly, :StridedVector, :T))), (:<:, :T, :Integer)), (:block,
            (:line, 144, :none),
            (:., :round, (:tuple, :Int, (:call, :conv, (:call, :float, :u), (:call, :float, :v))))
          )),
        (:line, 145, :none),
        (:(=), (:call, :conv, (:(::), :u, (:curly, :StridedVector, (:<:, :Integer))), (:(::), :v, (:curly, :StridedVector, (:<:, (:., (:., :Base, (:quote, #QuoteNode
                        :LinAlg
                      )), (:quote, #QuoteNode
                      :BlasFloat
                    )))))), (:block,
            (:line, 145, :none),
            (:call, :conv, (:call, :float, :u), :v)
          )),
        (:line, 146, :none),
        (:(=), (:call, :conv, (:(::), :u, (:curly, :StridedVector, (:<:, (:., (:., :Base, (:quote, #QuoteNode
                        :LinAlg
                      )), (:quote, #QuoteNode
                      :BlasFloat
                    ))))), (:(::), :v, (:curly, :StridedVector, (:<:, :Integer)))), (:block,
            (:line, 146, :none),
            (:call, :conv, :u, (:call, :float, :v))
          )),
        (:line, 148, :none),
        (:macrocall, :(Core.@doc), "    conv2(u,v,A)\n\n2-D convolution of the matrix `A` with the 2-D separable kernel generated by\nthe vectors `u` and `v`.\nUses 2-D FFT algorithm.\n", (:function, (:where, (:call, :conv2, (:(::), :u, (:curly, :StridedVector, :T)), (:(::), :v, (:curly, :StridedVector, :T)), (:(::), :A, (:curly, :StridedMatrix, :T))), :T), (:block,
              (:line, 156, :none),
              (:(=), :m, (:call, :-, (:call, :+, (:call, :length, :u), (:call, :size, :A, 1)), 1)),
              (:line, 157, :none),
              (:(=), :n, (:call, :-, (:call, :+, (:call, :length, :v), (:call, :size, :A, 2)), 1)),
              (:line, 158, :none),
              (:(=), :B, (:call, :zeros, :T, :m, :n)),
              (:line, 159, :none),
              (:(=), (:ref, :B, (:(:), 1, (:call, :size, :A, 1)), (:(:), 1, (:call, :size, :A, 2))), :A),
              (:line, 160, :none),
              (:(=), :u, (:call, :fft, (:vcat, :u, (:call, :zeros, :T, (:call, :-, :m, (:call, :length, :u)))))),
              (:line, 161, :none),
              (:(=), :v, (:call, :fft, (:vcat, :v, (:call, :zeros, :T, (:call, :-, :n, (:call, :length, :v)))))),
              (:line, 162, :none),
              (:(=), :C, (:call, :ifft, (:call, :.*, (:call, :fft, :B), (:call, :*, :u, (:.', :v))))),
              (:line, 163, :none),
              (:if, (:<:, :T, :Real), (:block,
                  (:line, 164, :none),
                  (:return, (:call, :real, :C))
                )),
              (:line, 166, :none),
              (:return, :C)
            ))),
        (:line, 169, :none),
        (:macrocall, :(Core.@doc), "    conv2(B,A)\n\n2-D convolution of the matrix `B` with the matrix `A`. Uses 2-D FFT algorithm.\n", (:function, (:where, (:call, :conv2, (:(::), :A, (:curly, :StridedMatrix, :T)), (:(::), :B, (:curly, :StridedMatrix, :T))), :T), (:block,
              (:line, 175, :none),
              (:(=), (:tuple, :sa, :sb), (:tuple, (:call, :size, :A), (:call, :size, :B))),
              (:line, 176, :none),
              (:(=), :At, (:call, :zeros, :T, (:call, :-, (:call, :+, (:ref, :sa, 1), (:ref, :sb, 1)), 1), (:call, :-, (:call, :+, (:ref, :sa, 2), (:ref, :sb, 2)), 1))),
              (:line, 177, :none),
              (:(=), :Bt, (:call, :zeros, :T, (:call, :-, (:call, :+, (:ref, :sa, 1), (:ref, :sb, 1)), 1), (:call, :-, (:call, :+, (:ref, :sa, 2), (:ref, :sb, 2)), 1))),
              (:line, 178, :none),
              (:(=), (:ref, :At, (:(:), 1, (:ref, :sa, 1)), (:(:), 1, (:ref, :sa, 2))), :A),
              (:line, 179, :none),
              (:(=), (:ref, :Bt, (:(:), 1, (:ref, :sb, 1)), (:(:), 1, (:ref, :sb, 2))), :B),
              (:line, 180, :none),
              (:(=), :p, (:call, :plan_fft, :At)),
              (:line, 181, :none),
              (:(=), :C, (:call, :ifft, (:call, :.*, (:call, :*, :p, :At), (:call, :*, :p, :Bt)))),
              (:line, 182, :none),
              (:if, (:<:, :T, :Real), (:block,
                  (:line, 183, :none),
                  (:return, (:call, :real, :C))
                )),
              (:line, 185, :none),
              (:return, :C)
            ))),
        (:line, 187, :none),
        (:(=), (:where, (:call, :conv2, (:(::), :A, (:curly, :StridedMatrix, :T)), (:(::), :B, (:curly, :StridedMatrix, :T))), (:<:, :T, :Integer)), (:block,
            (:line, 187, :none),
            (:., :round, (:tuple, :Int, (:call, :conv2, (:call, :float, :A), (:call, :float, :B))))
          )),
        (:line, 189, :none),
        (:(=), (:where, (:call, :conv2, (:(::), :u, (:curly, :StridedVector, :T)), (:(::), :v, (:curly, :StridedVector, :T)), (:(::), :A, (:curly, :StridedMatrix, :T))), (:<:, :T, :Integer)), (:block,
            (:line, 189, :none),
            (:., :round, (:tuple, :Int, (:call, :conv2, (:call, :float, :u), (:call, :float, :v), (:call, :float, :A))))
          )),
        (:line, 192, :none),
        (:macrocall, :(Core.@doc), "    xcorr(u,v)\n\nCompute the cross-correlation of two vectors.\n", (:function, (:call, :xcorr, :u, :v), (:block,
              (:line, 198, :none),
              (:(=), :su, (:call, :size, :u, 1)),
              (:line, 198, :none),
              (:(=), :sv, (:call, :size, :v, 1)),
              (:line, 199, :none),
              (:if, (:call, :<, :su, :sv), (:block,
                  (:line, 200, :none),
                  (:(=), :u, (:vcat, :u, (:call, :zeros, (:call, :eltype, :u), (:call, :-, :sv, :su))))
                ), (:block,
                  (:line, 201, :none),
                  (:if, (:call, :<, :sv, :su), (:block,
                      (:line, 202, :none),
                      (:(=), :v, (:vcat, :v, (:call, :zeros, (:call, :eltype, :v), (:call, :-, :su, :sv))))
                    ))
                )),
              (:line, 204, :none),
              (:call, :flipdim, (:call, :conv, (:call, :flipdim, :u, 1), :v), 1)
            )))
      ))
  ))