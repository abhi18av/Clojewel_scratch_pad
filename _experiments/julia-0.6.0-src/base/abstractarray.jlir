(:quote, (:block,
    (:line, 5, :none),
    (:macrocall, :(Core.@doc), "    AbstractArray{T, N}\n\nAbstract array supertype which arrays inherit from.\n", :AbstractArray),
    (:line, 12, :none),
    (:macrocall, :(Core.@doc), "    size(A::AbstractArray, [dim...])\n\nReturns a tuple containing the dimensions of `A`. Optionally you can specify the\ndimension(s) you want the length of, and get the length of that dimension, or a tuple of the\nlengths of dimensions you asked for.\n\n```jldoctest\njulia> A = ones(2,3,4);\n\njulia> size(A, 2)\n3\n\njulia> size(A,3,2)\n(4, 3)\n```\n", (:(=), (:where, (:call, :size, (:(::), :t, (:curly, :AbstractArray, :T, :N)), :d), :T, :N), (:block,
          (:line, 29, :none),
          (:if, (:call, :(<=), :d, :N), (:ref, (:call, :size, :t), :d), 1)
        ))),
    (:line, 30, :none),
    (:(=), (:where, (:call, :size, :x, (:(::), :d1, :Integer), (:(::), :d2, :Integer), (:(::), :dx, (:curly, :Vararg, :Integer, :N))), :N), (:block,
        (:line, 30, :none),
        (:tuple, (:call, :size, :x, :d1), (:call, :size, :x, :d2), (:..., (:call, :ntuple, (:->, :k, (:block,
                  (:line, 31, :none),
                  (:call, :size, :x, (:ref, :dx, :k))
                )), (:curly, :Val, :N))))
      )),
    (:line, 33, :none),
    (:macrocall, :(Core.@doc), "    indices(A, d)\n\nReturns the valid range of indices for array `A` along dimension `d`.\n\n```jldoctest\njulia> A = ones(5,6,7);\n\njulia> indices(A,2)\nBase.OneTo(6)\n```\n", (:function, (:where, (:call, :indices, (:(::), :A, (:curly, :AbstractArray, :T, :N)), :d), :T, :N), (:block,
          (:line, 46, :none),
          (:macrocall, Symbol("@_inline_meta")),
          (:line, 47, :none),
          (:if, (:call, :(<=), :d, :N), (:ref, (:call, :indices, :A), :d), (:call, :OneTo, 1))
        ))),
    (:line, 50, :none),
    (:macrocall, :(Core.@doc), "    indices(A)\n\nReturns the tuple of valid indices for array `A`.\n\n```jldoctest\njulia> A = ones(5,6,7);\n\njulia> indices(A)\n(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))\n```\n", (:function, (:call, :indices, :A), (:block,
          (:line, 63, :none),
          (:macrocall, Symbol("@_inline_meta")),
          (:line, 64, :none),
          (:call, :map, :OneTo, (:call, :size, :A))
        ))),
    (:line, 70, :none),
    (:(=), (:call, :indices1, (:(::), :A, (:curly, :AbstractArray, (:<:, :Any), 0))), (:block,
        (:line, 70, :none),
        (:call, :OneTo, 1)
      )),
    (:line, 71, :none),
    (:(=), (:call, :indices1, (:(::), :A, :AbstractArray)), (:block,
        (:line, 71, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:ref, (:call, :indices, :A), 1)
        )
      )),
    (:line, 72, :none),
    (:(=), (:call, :indices1, :iter), (:block,
        (:line, 72, :none),
        (:call, :OneTo, (:call, :length, :iter))
      )),
    (:line, 74, :none),
    (:(=), (:call, :unsafe_indices, :A), (:block,
        (:line, 74, :none),
        (:call, :indices, :A)
      )),
    (:line, 75, :none),
    (:(=), (:call, :unsafe_indices, (:(::), :r, :Range)), (:block,
        (:line, 75, :none),
        (:tuple, (:call, :OneTo, (:call, :unsafe_length, :r)))
      )),
    (:line, 77, :none),
    (:macrocall, :(Core.@doc), "    linearindices(A)\n\nReturns a `UnitRange` specifying the valid range of indices for `A[i]`\nwhere `i` is an `Int`. For arrays with conventional indexing (indices\nstart at 1), or any multidimensional array, this is `1:length(A)`;\nhowever, for one-dimensional arrays with unconventional indices, this\nis `indices(A, 1)`.\n\nCalling this function is the \"safe\" way to write algorithms that\nexploit linear indexing.\n\n```jldoctest\njulia> A = ones(5,6,7);\n\njulia> b = linearindices(A);\n\njulia> extrema(b)\n(1, 210)\n```\n", (:(=), (:call, :linearindices, :A), (:block,
          (:line, 98, :none),
          (:block,
            (:macrocall, Symbol("@_inline_meta")),
            (:call, :OneTo, (:call, :_length, :A))
          )
        ))),
    (:line, 99, :none),
    (:(=), (:call, :linearindices, (:(::), :A, :AbstractVector)), (:block,
        (:line, 99, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :indices1, :A)
        )
      )),
    (:line, 100, :none),
    (:(=), (:where, (:call, :eltype, (:(::), (:curly, :Type, (:<:, (:curly, :AbstractArray, :E))))), :E), (:block,
        (:line, 100, :none),
        :E
      )),
    (:line, 101, :none),
    (:(=), (:where, (:call, :elsize, (:(::), (:curly, :AbstractArray, :T))), :T), (:block,
        (:line, 101, :none),
        (:call, :sizeof, :T)
      )),
    (:line, 103, :none),
    (:macrocall, :(Core.@doc), "    ndims(A::AbstractArray) -> Integer\n\nReturns the number of dimensions of `A`.\n\n```jldoctest\njulia> A = ones(3,4,5);\n\njulia> ndims(A)\n3\n```\n", (:(=), (:where, (:call, :ndims, (:(::), (:curly, :AbstractArray, :T, :N))), :T, :N), (:block,
          (:line, 115, :none),
          :N
        ))),
    (:line, 116, :none),
    (:(=), (:where, (:call, :ndims, (:(::), (:curly, :Type, (:curly, :AbstractArray, :T, :N)))), :T, :N), (:block,
        (:line, 116, :none),
        :N
      )),
    (:line, 117, :none),
    (:(=), (:where, (:call, :ndims, (:(::), (:curly, :Type, :T))), (:<:, :T, :AbstractArray)), (:block,
        (:line, 117, :none),
        (:call, :ndims, (:call, :supertype, :T))
      )),
    (:line, 119, :none),
    (:macrocall, :(Core.@doc), "    length(A::AbstractArray) -> Integer\n\nReturns the number of elements in `A`.\n\n```jldoctest\njulia> A = ones(3,4,5);\n\njulia> length(A)\n60\n```\n", (:(=), (:call, :length, (:(::), :t, :AbstractArray)), (:block,
          (:line, 131, :none),
          (:block,
            (:macrocall, Symbol("@_inline_meta")),
            (:call, :prod, (:call, :size, :t))
          )
        ))),
    (:line, 132, :none),
    (:(=), (:call, :_length, (:(::), :A, :AbstractArray)), (:block,
        (:line, 132, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :prod, (:call, :map, :unsafe_length, (:call, :indices, :A)))
        )
      )),
    (:line, 133, :none),
    (:(=), (:call, :_length, :A), (:block,
        (:line, 133, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :length, :A)
        )
      )),
    (:line, 134, :none),
    (:(=), (:call, :endof, (:(::), :a, :AbstractArray)), (:block,
        (:line, 134, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :last, (:call, :linearindices, :a))
        )
      )),
    (:line, 135, :none),
    (:(=), (:call, :first, (:(::), :a, :AbstractArray)), (:block,
        (:line, 135, :none),
        (:ref, :a, (:call, :first, (:call, :eachindex, :a)))
      )),
    (:line, 137, :none),
    (:macrocall, :(Core.@doc), "    first(coll)\n\nGet the first element of an iterable collection. Returns the start point of a\n`Range` even if it is empty.\n\n```jldoctest\njulia> first(2:2:10)\n2\n\njulia> first([1; 2; 3; 4])\n1\n```\n", (:function, (:call, :first, :itr), (:block,
          (:line, 152, :none),
          (:(=), :state, (:call, :start, :itr)),
          (:line, 153, :none),
          (:&&, (:call, :done, :itr, :state), (:call, :throw, (:call, :ArgumentError, "collection must be non-empty"))),
          (:line, 154, :none),
          (:ref, (:call, :next, :itr, :state), 1)
        ))),
    (:line, 157, :none),
    (:macrocall, :(Core.@doc), "    last(coll)\n\nGet the last element of an ordered collection, if it can be computed in O(1) time. This is\naccomplished by calling [`endof`](@ref) to get the last index. Returns the end\npoint of a `Range` even if it is empty.\n\n```jldoctest\njulia> last(1:2:10)\n9\n\njulia> last([1; 2; 3; 4])\n4\n```\n", (:(=), (:call, :last, :a), (:block,
          (:line, 172, :none),
          (:ref, :a, :end)
        ))),
    (:line, 174, :none),
    (:macrocall, :(Core.@doc), "    stride(A, k::Integer)\n\nReturns the distance in memory (in number of elements) between adjacent elements in dimension `k`.\n\n```jldoctest\njulia> A = ones(3,4,5);\n\njulia> stride(A,2)\n3\n\njulia> stride(A,3)\n12\n```\n", (:function, (:call, :stride, (:(::), :a, :AbstractArray), (:(::), :i, :Integer)), (:block,
          (:line, 190, :none),
          (:if, (:call, :>, :i, (:call, :ndims, :a)), (:block,
              (:line, 191, :none),
              (:return, (:call, :length, :a))
            )),
          (:line, 193, :none),
          (:(=), :s, 1),
          (:line, 194, :none),
          (:for, (:(=), :n, (:(:), 1, (:call, :-, :i, 1))), (:block,
              (:line, 195, :none),
              (:*=, :s, (:call, :size, :a, :n))
            )),
          (:line, 197, :none),
          (:return, :s)
        ))),
    (:line, 200, :none),
    (:macrocall, :(Core.@doc), "    strides(A)\n\nReturns a tuple of the memory strides in each dimension.\n\n```jldoctest\njulia> A = ones(3,4,5);\n\njulia> strides(A)\n(1, 3, 12)\n```\n", (:(=), (:call, :strides, (:(::), :A, :AbstractArray)), (:block,
          (:line, 212, :none),
          (:call, :_strides, (:tuple, 1), :A)
        ))),
    (:line, 213, :none),
    (:(=), (:call, :_strides, (:(::), :out, (:curly, :Tuple, :Int)), (:(::), :A, (:curly, :AbstractArray, (:<:, :Any), 0))), (:block,
        (:line, 213, :none),
        (:tuple,)
      )),
    (:line, 214, :none),
    (:(=), (:where, (:call, :_strides, (:(::), :out, (:curly, :NTuple, :N, :Int)), (:(::), :A, (:curly, :AbstractArray, (:<:, :Any), :N))), :N), (:block,
        (:line, 214, :none),
        :out
      )),
    (:line, 215, :none),
    (:function, (:where, (:call, :_strides, (:(::), :out, (:curly, :NTuple, :M, :Int)), (:(::), :A, :AbstractArray)), :M), (:block,
        (:line, 216, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 217, :none),
        (:call, :_strides, (:tuple, (:..., :out), (:call, :*, (:ref, :out, :M), (:call, :size, :A, :M))), :A)
      )),
    (:line, 220, :none),
    (:function, (:call, :isassigned, (:(::), :a, :AbstractArray), (:..., (:(::), :i, :Int))), (:block,
        (:line, 221, :none),
        (:try, (:block,
            (:line, 222, :none),
            (:ref, :a, (:..., :i)),
            (:line, 223, :none),
            true
          ), :e, (:block,
            (:line, 225, :none),
            (:if, (:||, (:call, :isa, :e, :BoundsError), (:call, :isa, :e, :UndefRefError)), (:block,
                (:line, 226, :none),
                (:return, false)
              ), (:block,
                (:line, 228, :none),
                (:call, :rethrow, :e)
              ))
          ))
      )),
    (:line, 234, :none),
    (:function, (:call, :trailingsize, :A, :n), (:block,
        (:line, 235, :none),
        (:(=), :s, 1),
        (:line, 236, :none),
        (:for, (:(=), :i, (:(:), :n, (:call, :ndims, :A))), (:block,
            (:line, 237, :none),
            (:*=, :s, (:call, :size, :A, :i))
          )),
        (:line, 239, :none),
        (:return, :s)
      )),
    (:line, 241, :none),
    (:function, (:call, :trailingsize, (:(::), :inds, :Indices), :n), (:block,
        (:line, 242, :none),
        (:(=), :s, 1),
        (:line, 243, :none),
        (:for, (:(=), :i, (:(:), :n, (:call, :length, :inds))), (:block,
            (:line, 244, :none),
            (:*=, :s, (:call, :unsafe_length, (:ref, :inds, :i)))
          )),
        (:line, 246, :none),
        (:return, :s)
      )),
    (:line, 249, :none),
    (:function, (:call, :trailingsize, (:(::), :inds, :Indices)), (:block,
        (:line, 250, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 251, :none),
        (:call, :prod, (:call, :map, :unsafe_length, :inds))
      )),
    (:line, 256, :none),
    (:abstract, :IndexStyle),
    (:line, 257, :none),
    (:type, false, (:<:, :IndexLinear, :IndexStyle), (:block,
        (:line, 257, :none)
      )),
    (:line, 258, :none),
    (:type, false, (:<:, :IndexCartesian, :IndexStyle), (:block,
        (:line, 258, :none)
      )),
    (:line, 260, :none),
    (:macrocall, :(Core.@doc), "    IndexStyle(A)\n    IndexStyle(typeof(A))\n\n`IndexStyle` specifies the \"native indexing style\" for array `A`. When\nyou define a new `AbstractArray` type, you can choose to implement\neither linear indexing or cartesian indexing.  If you decide to\nimplement linear indexing, then you must set this trait for your array\ntype:\n\n    Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()\n\nThe default is `IndexCartesian()`.\n\nJulia's internal indexing machinery will automatically (and invisibly)\nconvert all indexing operations into the preferred style using\n[`sub2ind`](@ref) or [`ind2sub`](@ref). This allows users to access\nelements of your array using any indexing style, even when explicit\nmethods have not been provided.\n\nIf you define both styles of indexing for your `AbstractArray`, this\ntrait can be used to select the most performant indexing style. Some\nmethods check this trait on their inputs, and dispatch to different\nalgorithms depending on the most efficient access pattern. In\nparticular, [`eachindex`](@ref) creates an iterator whose type depends\non the setting of this trait.\n", (:(=), (:call, :IndexStyle, (:(::), :A, :AbstractArray)), (:block,
          (:line, 287, :none),
          (:call, :IndexStyle, (:call, :typeof, :A))
        ))),
    (:line, 288, :none),
    (:(=), (:call, :IndexStyle, (:(::), (:curly, :Type, (:curly, :Union)))), (:block,
        (:line, 288, :none),
        (:call, :IndexLinear)
      )),
    (:line, 289, :none),
    (:(=), (:call, :IndexStyle, (:(::), (:curly, :Type, (:<:, :AbstractArray)))), (:block,
        (:line, 289, :none),
        (:call, :IndexCartesian)
      )),
    (:line, 290, :none),
    (:(=), (:call, :IndexStyle, (:(::), (:curly, :Type, (:<:, :Array)))), (:block,
        (:line, 290, :none),
        (:call, :IndexLinear)
      )),
    (:line, 291, :none),
    (:(=), (:call, :IndexStyle, (:(::), (:curly, :Type, (:<:, :Range)))), (:block,
        (:line, 291, :none),
        (:call, :IndexLinear)
      )),
    (:line, 293, :none),
    (:(=), (:call, :IndexStyle, (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 293, :none),
        (:call, :IndexStyle, (:call, :IndexStyle, :A), (:call, :IndexStyle, :B))
      )),
    (:line, 294, :none),
    (:(=), (:call, :IndexStyle, (:(::), :A, :AbstractArray), (:..., (:(::), :B, :AbstractArray))), (:block,
        (:line, 294, :none),
        (:call, :IndexStyle, (:call, :IndexStyle, :A), (:call, :IndexStyle, (:..., :B)))
      )),
    (:line, 295, :none),
    (:(=), (:call, :IndexStyle, (:(::), :IndexLinear), (:(::), :IndexLinear)), (:block,
        (:line, 295, :none),
        (:call, :IndexLinear)
      )),
    (:line, 296, :none),
    (:(=), (:call, :IndexStyle, (:(::), :IndexStyle), (:(::), :IndexStyle)), (:block,
        (:line, 296, :none),
        (:call, :IndexCartesian)
      )),
    (:line, 314, :none),
    (:macrocall, :(Core.@doc), "    checkbounds(Bool, A, I...)\n\nReturn `true` if the specified indices `I` are in bounds for the given\narray `A`. Subtypes of `AbstractArray` should specialize this method\nif they need to provide custom bounds checking behaviors; however, in\nmany cases one can rely on `A`'s indices and [`checkindex`](@ref).\n\nSee also [`checkindex`](@ref).\n\n```jldoctest\njulia> A = rand(3, 3);\n\njulia> checkbounds(Bool, A, 2)\ntrue\n\njulia> checkbounds(Bool, A, 3, 4)\nfalse\n\njulia> checkbounds(Bool, A, 1:3)\ntrue\n\njulia> checkbounds(Bool, A, 1:3, 2:4)\nfalse\n```\n", (:function, (:call, :checkbounds, (:(::), (:curly, :Type, :Bool)), (:(::), :A, :AbstractArray), (:..., :I)), (:block,
          (:line, 341, :none),
          (:macrocall, Symbol("@_inline_meta")),
          (:line, 342, :none),
          (:call, :checkbounds_indices, :Bool, (:call, :indices, :A), :I)
        ))),
    (:line, 345, :none),
    (:function, (:call, :checkbounds, (:(::), (:curly, :Type, :Bool)), (:(::), :A, :AbstractArray), :i), (:block,
        (:line, 346, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 347, :none),
        (:call, :checkindex, :Bool, (:call, :linearindices, :A), :i)
      )),
    (:line, 350, :none),
    (:function, (:where, (:call, :checkbounds, (:(::), (:curly, :Type, :Bool)), (:(::), :A, (:curly, :AbstractArray, (:<:, :Any), :N)), (:(::), :I, (:curly, :AbstractArray, :Bool, :N))), :N), (:block,
        (:line, 351, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 352, :none),
        (:call, :(==), (:call, :indices, :A), (:call, :indices, :I))
      )),
    (:line, 355, :none),
    (:macrocall, :(Core.@doc), "    checkbounds(A, I...)\n\nThrow an error if the specified indices `I` are not in bounds for the given array `A`.\n", (:function, (:call, :checkbounds, (:(::), :A, :AbstractArray), (:..., :I)), (:block,
          (:line, 361, :none),
          (:macrocall, Symbol("@_inline_meta")),
          (:line, 362, :none),
          (:||, (:call, :checkbounds, :Bool, :A, (:..., :I)), (:call, :throw_boundserror, :A, :I)),
          (:line, 363, :none),
          :nothing
        ))),
    (:line, 365, :none),
    (:(=), (:call, :checkbounds, (:(::), :A, :AbstractArray)), (:block,
        (:line, 365, :none),
        (:call, :checkbounds, :A, 1)
      )),
    (:line, 367, :none),
    (:macrocall, :(Core.@doc), "    checkbounds_indices(Bool, IA, I)\n\nReturn `true` if the \"requested\" indices in the tuple `I` fall within\nthe bounds of the \"permitted\" indices specified by the tuple\n`IA`. This function recursively consumes elements of these tuples,\nusually in a 1-for-1 fashion,\n\n    checkbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &\n                                                          checkbounds_indices(Bool, IA, I)\n\nNote that [`checkindex`](@ref) is being used to perform the actual\nbounds-check for a single dimension of the array.\n\nThere are two important exceptions to the 1-1 rule: linear indexing and\nCartesianIndex{N}, both of which may \"consume\" more than one element\nof `IA`.\n\nSee also [`checkbounds`](@ref).\n", (:function, (:call, :checkbounds_indices, (:(::), (:curly, :Type, :Bool)), (:(::), :IA, :Tuple), (:(::), :I, :Tuple)), (:block,
          (:line, 388, :none),
          (:macrocall, Symbol("@_inline_meta")),
          (:line, 389, :none),
          (:call, :&, (:call, :checkindex, :Bool, (:ref, :IA, 1), (:ref, :I, 1)), (:call, :checkbounds_indices, :Bool, (:call, :tail, :IA), (:call, :tail, :I)))
        ))),
    (:line, 391, :none),
    (:(=), (:call, :checkbounds_indices, (:(::), (:curly, :Type, :Bool)), (:(::), (:curly, :Tuple)), (:(::), (:curly, :Tuple))), (:block,
        (:line, 391, :none),
        true
      )),
    (:line, 392, :none),
    (:function, (:call, :checkbounds_indices, (:(::), (:curly, :Type, :Bool)), (:(::), (:curly, :Tuple)), (:(::), :I, (:curly, :Tuple, :Any))), (:block,
        (:line, 393, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 394, :none),
        (:call, :checkindex, :Bool, (:(:), 1, 1), (:ref, :I, 1))
      )),
    (:line, 396, :none),
    (:function, (:call, :checkbounds_indices, (:(::), (:curly, :Type, :Bool)), (:(::), (:curly, :Tuple)), (:(::), :I, :Tuple)), (:block,
        (:line, 397, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 398, :none),
        (:call, :&, (:call, :checkindex, :Bool, (:(:), 1, 1), (:ref, :I, 1)), (:call, :checkbounds_indices, :Bool, (:tuple,), (:call, :tail, :I)))
      )),
    (:line, 400, :none),
    (:function, (:call, :checkbounds_indices, (:(::), (:curly, :Type, :Bool)), (:(::), :IA, (:curly, :Tuple, :Any)), (:(::), :I, (:curly, :Tuple, :Any))), (:block,
        (:line, 401, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 402, :none),
        (:call, :checkindex, :Bool, (:ref, :IA, 1), (:ref, :I, 1))
      )),
    (:line, 404, :none),
    (:function, (:call, :checkbounds_indices, (:(::), (:curly, :Type, :Bool)), (:(::), :IA, :Tuple), (:(::), :I, (:curly, :Tuple, :Any))), (:block,
        (:line, 405, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 406, :none),
        (:call, :checkbounds_linear_indices, :Bool, :IA, (:ref, :I, 1))
      )),
    (:line, 408, :none),
    (:function, (:call, :checkbounds_linear_indices, (:(::), (:curly, :Type, :Bool)), (:(::), :IA, (:curly, :Tuple, (:curly, :Vararg, :OneTo))), :i), (:block,
        (:line, 409, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 410, :none),
        (:if, (:call, :checkindex, :Bool, (:ref, :IA, 1), :i), (:block,
            (:line, 411, :none),
            (:return, true)
          ), (:block,
            (:line, 412, :none),
            (:if, (:call, :checkindex, :Bool, (:call, :OneTo, (:call, :trailingsize, :IA)), :i), (:block,
                (:line, 413, :none),
                (:call, :partial_linear_indexing_warning_lookup, (:call, :length, :IA)),
                (:line, 414, :none),
                (:return, true)
              ))
          )),
        (:line, 416, :none),
        (:return, false)
      )),
    (:line, 418, :none),
    (:function, (:call, :checkbounds_linear_indices, (:(::), (:curly, :Type, :Bool)), (:(::), :IA, (:curly, :Tuple, :AbstractUnitRange, (:curly, :Vararg, :AbstractUnitRange))), :i), (:block,
        (:line, 419, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 420, :none),
        (:call, :checkindex, :Bool, (:ref, :IA, 1), :i)
      )),
    (:line, 422, :none),
    (:function, (:call, :checkbounds_linear_indices, (:(::), (:curly, :Type, :Bool)), (:(::), :IA, (:curly, :Tuple, (:curly, :Vararg, :OneTo))), (:(::), :i, (:curly, :Union, :Slice, :Colon))), (:block,
        (:line, 423, :none),
        (:call, :partial_linear_indexing_warning_lookup, (:call, :length, :IA)),
        (:line, 424, :none),
        true
      )),
    (:line, 426, :none),
    (:function, (:call, :checkbounds_linear_indices, (:(::), (:curly, :Type, :Bool)), (:(::), :IA, (:curly, :Tuple, :AbstractUnitRange, (:curly, :Vararg, :AbstractUnitRange))), (:(::), :i, (:curly, :Union, :Slice, :Colon))), (:block,
        (:line, 428, :none),
        (:call, :partial_linear_indexing_warning_lookup, (:call, :length, :IA)),
        (:line, 429, :none),
        true
      )),
    (:line, 431, :none),
    (:(=), (:call, :checkbounds_indices, (:(::), (:curly, :Type, :Bool)), (:(::), :Tuple), (:(::), (:curly, :Tuple))), (:block,
        (:line, 431, :none),
        true
      )),
    (:line, 433, :none),
    (:(=), (:call, :throw_boundserror, :A, :I), (:block,
        (:line, 433, :none),
        (:block,
          (:macrocall, Symbol("@_noinline_meta")),
          (:call, :throw, (:call, :BoundsError, :A, :I))
        )
      )),
    (:line, 436, :none),
    (:macrocall, :(Core.@doc), "    checkindex(Bool, inds::AbstractUnitRange, index)\n\nReturn `true` if the given `index` is within the bounds of\n`inds`. Custom types that would like to behave as indices for all\narrays can extend this method in order to provide a specialized bounds\nchecking implementation.\n\n```jldoctest\njulia> checkindex(Bool,1:20,8)\ntrue\n\njulia> checkindex(Bool,1:20,21)\nfalse\n```\n", (:(=), (:call, :checkindex, (:(::), (:curly, :Type, :Bool)), (:(::), :inds, :AbstractUnitRange), :i), (:block,
          (:line, 452, :none),
          (:call, :throw, (:call, :ArgumentError, (:string, "unable to check bounds for indices of type ", (:call, :typeof, :i))))
        ))),
    (:line, 454, :none),
    (:(=), (:call, :checkindex, (:(::), (:curly, :Type, :Bool)), (:(::), :inds, :AbstractUnitRange), (:(::), :i, :Real)), (:block,
        (:line, 454, :none),
        (:call, :&, (:call, :(<=), (:call, :first, :inds), :i), (:call, :(<=), :i, (:call, :last, :inds)))
      )),
    (:line, 455, :none),
    (:(=), (:call, :checkindex, (:(::), (:curly, :Type, :Bool)), (:(::), :inds, :AbstractUnitRange), (:(::), :Colon)), (:block,
        (:line, 455, :none),
        true
      )),
    (:line, 456, :none),
    (:(=), (:call, :checkindex, (:(::), (:curly, :Type, :Bool)), (:(::), :inds, :AbstractUnitRange), (:(::), :Slice)), (:block,
        (:line, 456, :none),
        true
      )),
    (:line, 457, :none),
    (:function, (:call, :checkindex, (:(::), (:curly, :Type, :Bool)), (:(::), :inds, :AbstractUnitRange), (:(::), :r, :Range)), (:block,
        (:line, 458, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 459, :none),
        (:call, :|, (:call, :isempty, :r), (:call, :&, (:call, :checkindex, :Bool, :inds, (:call, :first, :r)), (:call, :checkindex, :Bool, :inds, (:call, :last, :r))))
      )),
    (:line, 461, :none),
    (:(=), (:call, :checkindex, (:(::), (:curly, :Type, :Bool)), (:(::), :indx, :AbstractUnitRange), (:(::), :I, (:curly, :AbstractVector, :Bool))), (:block,
        (:line, 461, :none),
        (:call, :(==), :indx, (:call, :indices1, :I))
      )),
    (:line, 462, :none),
    (:(=), (:call, :checkindex, (:(::), (:curly, :Type, :Bool)), (:(::), :indx, :AbstractUnitRange), (:(::), :I, (:curly, :AbstractArray, :Bool))), (:block,
        (:line, 462, :none),
        false
      )),
    (:line, 463, :none),
    (:function, (:call, :checkindex, (:(::), (:curly, :Type, :Bool)), (:(::), :inds, :AbstractUnitRange), (:(::), :I, :AbstractArray)), (:block,
        (:line, 464, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 465, :none),
        (:(=), :b, true),
        (:line, 466, :none),
        (:for, (:(=), :i, :I), (:block,
            (:line, 467, :none),
            (:&=, :b, (:call, :checkindex, :Bool, :inds, :i))
          )),
        (:line, 469, :none),
        :b
      )),
    (:line, 477, :none),
    (:macrocall, :(Core.@doc), "    similar(array, [element_type=eltype(array)], [dims=size(array)])\n\nCreate an uninitialized mutable array with the given element type and size, based upon the\ngiven source array. The second and third arguments are both optional, defaulting to the\ngiven array's `eltype` and `size`. The dimensions may be specified either as a single tuple\nargument or as a series of integer arguments.\n\nCustom AbstractArray subtypes may choose which specific array type is best-suited to return\nfor the given element type and dimensionality. If they do not specialize this method, the\ndefault is an `Array{element_type}(dims...)`.\n\nFor example, `similar(1:10, 1, 4)` returns an uninitialized `Array{Int,2}` since ranges are\nneither mutable nor support 2 dimensions:\n\n```julia-repl\njulia> similar(1:10, 1, 4)\n1×4 Array{Int64,2}:\n 4419743872  4374413872  4419743888  0\n```\n\nConversely, `similar(trues(10,10), 2)` returns an uninitialized `BitVector` with two\nelements since `BitArray`s are both mutable and can support 1-dimensional arrays:\n\n```julia-repl\njulia> similar(trues(10,10), 2)\n2-element BitArray{1}:\n false\n false\n```\n\nSince `BitArray`s can only store elements of type [`Bool`](@ref), however, if you request a\ndifferent element type it will create a regular `Array` instead:\n\n```julia-repl\njulia> similar(falses(10), Float64, 2, 4)\n2×4 Array{Float64,2}:\n 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n```\n\n", (:(=), (:where, (:call, :similar, (:(::), :a, (:curly, :AbstractArray, :T))), :T), (:block,
          (:line, 519, :none),
          (:call, :similar, :a, :T)
        ))),
    (:line, 520, :none),
    (:(=), (:where, (:call, :similar, (:(::), :a, :AbstractArray), (:(::), (:curly, :Type, :T))), :T), (:block,
        (:line, 520, :none),
        (:call, :similar, :a, :T, (:call, :to_shape, (:call, :indices, :a)))
      )),
    (:line, 521, :none),
    (:(=), (:where, (:call, :similar, (:(::), :a, (:curly, :AbstractArray, :T)), (:(::), :dims, :Tuple)), :T), (:block,
        (:line, 521, :none),
        (:call, :similar, :a, :T, (:call, :to_shape, :dims))
      )),
    (:line, 522, :none),
    (:(=), (:where, (:call, :similar, (:(::), :a, (:curly, :AbstractArray, :T)), (:..., (:(::), :dims, :DimOrInd))), :T), (:block,
        (:line, 522, :none),
        (:call, :similar, :a, :T, (:call, :to_shape, :dims))
      )),
    (:line, 523, :none),
    (:(=), (:where, (:call, :similar, (:(::), :a, :AbstractArray), (:(::), (:curly, :Type, :T)), (:..., (:(::), :dims, :DimOrInd))), :T), (:block,
        (:line, 523, :none),
        (:call, :similar, :a, :T, (:call, :to_shape, :dims))
      )),
    (:line, 524, :none),
    (:(=), (:where, (:call, :similar, (:(::), :a, :AbstractArray), (:(::), (:curly, :Type, :T)), (:(::), :dims, :NeedsShaping)), :T), (:block,
        (:line, 524, :none),
        (:call, :similar, :a, :T, (:call, :to_shape, :dims))
      )),
    (:line, 526, :none),
    (:(=), (:where, (:call, :similar, (:(::), :a, :AbstractArray), (:(::), (:curly, :Type, :T)), (:(::), :dims, (:curly, :Dims, :N))), :T, :N), (:block,
        (:line, 526, :none),
        (:call, (:curly, :Array, :T, :N), :dims)
      )),
    (:line, 528, :none),
    (:(=), (:call, :to_shape, (:(::), (:curly, :Tuple))), (:block,
        (:line, 528, :none),
        (:tuple,)
      )),
    (:line, 529, :none),
    (:(=), (:call, :to_shape, (:(::), :dims, :Dims)), (:block,
        (:line, 529, :none),
        :dims
      )),
    (:line, 530, :none),
    (:(=), (:call, :to_shape, (:(::), :dims, :DimsOrInds)), (:block,
        (:line, 530, :none),
        (:call, :map, :to_shape, :dims)
      )),
    (:line, 532, :none),
    (:(=), (:call, :to_shape, (:(::), :i, :Int)), (:block,
        (:line, 532, :none),
        :i
      )),
    (:line, 533, :none),
    (:(=), (:call, :to_shape, (:(::), :i, :Integer)), (:block,
        (:line, 533, :none),
        (:call, :Int, :i)
      )),
    (:line, 534, :none),
    (:(=), (:call, :to_shape, (:(::), :r, :OneTo)), (:block,
        (:line, 534, :none),
        (:call, :Int, (:call, :last, :r))
      )),
    (:line, 535, :none),
    (:(=), (:call, :to_shape, (:(::), :r, :AbstractUnitRange)), (:block,
        (:line, 535, :none),
        :r
      )),
    (:line, 537, :none),
    (:macrocall, :(Core.@doc), "    similar(storagetype, indices)\n\nCreate an uninitialized mutable array analogous to that specified by\n`storagetype`, but with `indices` specified by the last\nargument. `storagetype` might be a type or a function.\n\n**Examples**:\n\n    similar(Array{Int}, indices(A))\n\ncreates an array that \"acts like\" an `Array{Int}` (and might indeed be\nbacked by one), but which is indexed identically to `A`. If `A` has\nconventional indexing, this will be identical to\n`Array{Int}(size(A))`, but if `A` has unconventional indexing then the\nindices of the result will match `A`.\n\n    similar(BitArray, (indices(A, 2),))\n\nwould create a 1-dimensional logical array whose indices match those\nof the columns of `A`.\n\n    similar(dims->zeros(Int, dims), indices(A))\n\nwould create an array of `Int`, initialized to zero, matching the\nindices of `A`.\n", (:(=), (:call, :similar, :f, (:(::), :shape, :Tuple)), (:block,
          (:line, 564, :none),
          (:call, :f, (:call, :to_shape, :shape))
        ))),
    (:line, 565, :none),
    (:(=), (:call, :similar, :f, (:..., (:(::), :dims, :DimOrInd))), (:block,
        (:line, 565, :none),
        (:call, :similar, :f, :dims)
      )),
    (:line, 569, :none),
    (:function, (:call, :copy!, (:(::), :dest, :AbstractArray), :src), (:block,
        (:line, 570, :none),
        (:(=), :destiter, (:call, :eachindex, :dest)),
        (:line, 571, :none),
        (:(=), :state, (:call, :start, :destiter)),
        (:line, 572, :none),
        (:for, (:(=), :x, :src), (:block,
            (:line, 573, :none),
            (:(=), (:tuple, :i, :state), (:call, :next, :destiter, :state)),
            (:line, 574, :none),
            (:(=), (:ref, :dest, :i), :x)
          )),
        (:line, 576, :none),
        (:return, :dest)
      )),
    (:line, 579, :none),
    (:function, (:call, :copy!, (:(::), :dest, :AbstractArray), (:(::), :dstart, :Integer), :src), (:block,
        (:line, 580, :none),
        (:(=), :i, (:call, :Int, :dstart)),
        (:line, 581, :none),
        (:for, (:(=), :x, :src), (:block,
            (:line, 582, :none),
            (:(=), (:ref, :dest, :i), :x),
            (:line, 583, :none),
            (:+=, :i, 1)
          )),
        (:line, 585, :none),
        (:return, :dest)
      )),
    (:line, 589, :none),
    (:function, (:call, :copy!, (:(::), :dest, :AbstractArray), (:(::), :dstart, :Integer), :src, (:(::), :sstart, :Integer)), (:block,
        (:line, 590, :none),
        (:if, (:call, :<, :sstart, 1), (:block,
            (:line, 591, :none),
            (:call, :throw, (:call, :ArgumentError, (:call, :string, "source start offset (", :sstart, ") is < 1")))
          )),
        (:line, 593, :none),
        (:(=), :st, (:call, :start, :src)),
        (:line, 594, :none),
        (:for, (:(=), :j, (:(:), 1, (:call, :-, :sstart, 1))), (:block,
            (:line, 595, :none),
            (:if, (:call, :done, :src, :st), (:block,
                (:line, 596, :none),
                (:call, :throw, (:call, :ArgumentError, (:call, :string, "source has fewer elements than required, ", "expected at least ", :sstart, ", got ", (:call, :-, :j, 1))))
              )),
            (:line, 599, :none),
            (:(=), (:tuple, :_, :st), (:call, :next, :src, :st))
          )),
        (:line, 601, :none),
        (:(=), :dn, (:call, :done, :src, :st)),
        (:line, 602, :none),
        (:if, :dn, (:block,
            (:line, 603, :none),
            (:call, :throw, (:call, :ArgumentError, (:call, :string, "source has fewer elements than required, ", "expected at least ", :sstart, ", got ", (:call, :-, :sstart, 1))))
          )),
        (:line, 606, :none),
        (:(=), :i, (:call, :Int, :dstart)),
        (:line, 607, :none),
        (:while, (:call, :!, :dn), (:block,
            (:line, 608, :none),
            (:(=), (:tuple, :val, :st), (:call, :next, :src, :st)),
            (:line, 609, :none),
            (:(=), (:ref, :dest, :i), :val),
            (:line, 610, :none),
            (:+=, :i, 1),
            (:line, 611, :none),
            (:(=), :dn, (:call, :done, :src, :st))
          )),
        (:line, 613, :none),
        (:return, :dest)
      )),
    (:line, 617, :none),
    (:function, (:call, :copy!, (:(::), :dest, :AbstractArray), (:(::), :dstart, :Integer), :src, (:(::), :sstart, :Integer), (:(::), :n, :Integer)), (:block,
        (:line, 618, :none),
        (:&&, (:call, :<, :n, 0), (:call, :throw, (:call, :ArgumentError, (:call, :string, "tried to copy n=", :n, " elements, but n should be nonnegative")))),
        (:line, 619, :none),
        (:&&, (:call, :(==), :n, 0), (:return, :dest)),
        (:line, 620, :none),
        (:(=), :dmax, (:call, :-, (:call, :+, :dstart, :n), 1)),
        (:line, 621, :none),
        (:(=), :inds, (:call, :linearindices, :dest)),
        (:line, 622, :none),
        (:if, (:call, :|, (:||, (:call, :∉, :dstart, :inds), (:call, :∉, :dmax, :inds)), (:call, :<, :sstart, 1)), (:block,
            (:line, 623, :none),
            (:&&, (:call, :<, :sstart, 1), (:call, :throw, (:call, :ArgumentError, (:call, :string, "source start offset (", :sstart, ") is < 1")))),
            (:line, 624, :none),
            (:call, :throw, (:call, :BoundsError, :dest, (:(:), :dstart, :dmax)))
          )),
        (:line, 626, :none),
        (:(=), :st, (:call, :start, :src)),
        (:line, 627, :none),
        (:for, (:(=), :j, (:(:), 1, (:call, :-, :sstart, 1))), (:block,
            (:line, 628, :none),
            (:if, (:call, :done, :src, :st), (:block,
                (:line, 629, :none),
                (:call, :throw, (:call, :ArgumentError, (:call, :string, "source has fewer elements than required, ", "expected at least ", :sstart, ", got ", (:call, :-, :j, 1))))
              )),
            (:line, 632, :none),
            (:(=), (:tuple, :_, :st), (:call, :next, :src, :st))
          )),
        (:line, 634, :none),
        (:(=), :i, (:call, :Int, :dstart)),
        (:line, 635, :none),
        (:while, (:&&, (:call, :(<=), :i, :dmax), (:call, :!, (:call, :done, :src, :st))), (:block,
            (:line, 636, :none),
            (:(=), (:tuple, :val, :st), (:call, :next, :src, :st)),
            (:line, 637, :none),
            (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :dest, :i), :val)),
            (:line, 638, :none),
            (:+=, :i, 1)
          )),
        (:line, 640, :none),
        (:&&, (:call, :(<=), :i, :dmax), (:call, :throw, (:call, :BoundsError, :dest, :i))),
        (:line, 641, :none),
        (:return, :dest)
      )),
    (:line, 647, :none),
    (:(=), (:call, :copy!, (:(::), :dest, :AbstractArray), (:(::), :src, :AbstractArray)), (:block,
        (:line, 647, :none),
        (:call, :copy!, (:call, :IndexStyle, :dest), :dest, (:call, :IndexStyle, :src), :src)
      )),
    (:line, 650, :none),
    (:function, (:call, :copy!, (:(::), :IndexStyle), (:(::), :dest, :AbstractArray), (:(::), :IndexStyle), (:(::), :src, :AbstractArray)), (:block,
        (:line, 651, :none),
        (:(=), (:tuple, :destinds, :srcinds), (:tuple, (:call, :linearindices, :dest), (:call, :linearindices, :src))),
        (:line, 652, :none),
        (:||, (:call, :isempty, :srcinds), (:||, (:&&, (:call, :∈, (:call, :first, :srcinds), :destinds), (:call, :∈, (:call, :last, :srcinds), :destinds)), (:call, :throw, (:call, :BoundsError, :dest, :srcinds)))),
        (:line, 654, :none),
        (:macrocall, Symbol("@inbounds"), (:for, (:(=), :i, :srcinds), (:block,
              (:line, 655, :none),
              (:(=), (:ref, :dest, :i), (:ref, :src, :i))
            ))),
        (:line, 657, :none),
        (:return, :dest)
      )),
    (:line, 660, :none),
    (:function, (:call, :copy!, (:(::), :IndexStyle), (:(::), :dest, :AbstractArray), (:(::), :IndexCartesian), (:(::), :src, :AbstractArray)), (:block,
        (:line, 661, :none),
        (:(=), (:tuple, :destinds, :srcinds), (:tuple, (:call, :linearindices, :dest), (:call, :linearindices, :src))),
        (:line, 662, :none),
        (:||, (:call, :isempty, :srcinds), (:||, (:&&, (:call, :∈, (:call, :first, :srcinds), :destinds), (:call, :∈, (:call, :last, :srcinds), :destinds)), (:call, :throw, (:call, :BoundsError, :dest, :srcinds)))),
        (:line, 664, :none),
        (:(=), :i, 0),
        (:line, 665, :none),
        (:macrocall, Symbol("@inbounds"), (:for, (:(=), :a, :src), (:block,
              (:line, 666, :none),
              (:(=), (:ref, :dest, (:+=, :i, 1)), :a)
            ))),
        (:line, 668, :none),
        (:return, :dest)
      )),
    (:line, 671, :none),
    (:function, (:call, :copy!, (:(::), :dest, :AbstractArray), (:(::), :dstart, :Integer), (:(::), :src, :AbstractArray)), (:block,
        (:line, 672, :none),
        (:call, :copy!, :dest, :dstart, :src, (:call, :first, (:call, :linearindices, :src)), (:call, :_length, :src))
      )),
    (:line, 675, :none),
    (:function, (:call, :copy!, (:(::), :dest, :AbstractArray), (:(::), :dstart, :Integer), (:(::), :src, :AbstractArray), (:(::), :sstart, :Integer)), (:block,
        (:line, 676, :none),
        (:(=), :srcinds, (:call, :linearindices, :src)),
        (:line, 677, :none),
        (:||, (:call, :∈, :sstart, :srcinds), (:call, :throw, (:call, :BoundsError, :src, :sstart))),
        (:line, 678, :none),
        (:call, :copy!, :dest, :dstart, :src, :sstart, (:call, :+, (:call, :-, (:call, :last, :srcinds), :sstart), 1))
      )),
    (:line, 681, :none),
    (:function, (:call, :copy!, (:(::), :dest, :AbstractArray), (:(::), :dstart, :Integer), (:(::), :src, :AbstractArray), (:(::), :sstart, :Integer), (:(::), :n, :Integer)), (:block,
        (:line, 684, :none),
        (:&&, (:call, :(==), :n, 0), (:return, :dest)),
        (:line, 685, :none),
        (:&&, (:call, :<, :n, 0), (:call, :throw, (:call, :ArgumentError, (:call, :string, "tried to copy n=", :n, " elements, but n should be nonnegative")))),
        (:line, 686, :none),
        (:(=), (:tuple, :destinds, :srcinds), (:tuple, (:call, :linearindices, :dest), (:call, :linearindices, :src))),
        (:line, 687, :none),
        (:||, (:&&, (:call, :∈, :dstart, :destinds), (:call, :∈, (:call, :-, (:call, :+, :dstart, :n), 1), :destinds)), (:call, :throw, (:call, :BoundsError, :dest, (:(:), :dstart, (:call, :-, (:call, :+, :dstart, :n), 1))))),
        (:line, 688, :none),
        (:||, (:&&, (:call, :∈, :sstart, :srcinds), (:call, :∈, (:call, :-, (:call, :+, :sstart, :n), 1), :srcinds)), (:call, :throw, (:call, :BoundsError, :src, (:(:), :sstart, (:call, :-, (:call, :+, :sstart, :n), 1))))),
        (:line, 689, :none),
        (:macrocall, Symbol("@inbounds"), (:for, (:(=), :i, (:(:), 0, (:call, :-, :n, 1))), (:block,
              (:line, 690, :none),
              (:(=), (:ref, :dest, (:call, :+, :dstart, :i)), (:ref, :src, (:call, :+, :sstart, :i)))
            ))),
        (:line, 692, :none),
        (:return, :dest)
      )),
    (:line, 695, :none),
    (:function, (:call, :copy, (:(::), :a, :AbstractArray)), (:block,
        (:line, 696, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 697, :none),
        (:call, :copymutable, :a)
      )),
    (:line, 700, :none),
    (:function, (:where, (:call, :copy!, (:(::), :B, (:curly, :AbstractVecOrMat, :R)), (:(::), :ir_dest, (:curly, :Range, :Int)), (:(::), :jr_dest, (:curly, :Range, :Int)), (:(::), :A, (:curly, :AbstractVecOrMat, :S)), (:(::), :ir_src, (:curly, :Range, :Int)), (:(::), :jr_src, (:curly, :Range, :Int))), :R, :S), (:block,
        (:line, 702, :none),
        (:if, (:call, :(!=), (:call, :length, :ir_dest), (:call, :length, :ir_src)), (:block,
            (:line, 703, :none),
            (:call, :throw, (:call, :ArgumentError, (:call, :string, "source and destination must have same size (got ", (:call, :length, :ir_src), " and ", (:call, :length, :ir_dest), ")")))
          )),
        (:line, 706, :none),
        (:if, (:call, :(!=), (:call, :length, :jr_dest), (:call, :length, :jr_src)), (:block,
            (:line, 707, :none),
            (:call, :throw, (:call, :ArgumentError, (:call, :string, "source and destination must have same size (got ", (:call, :length, :jr_src), " and ", (:call, :length, :jr_dest), ")")))
          )),
        (:line, 710, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :B, :ir_dest, :jr_dest)),
        (:line, 711, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, :ir_src, :jr_src)),
        (:line, 712, :none),
        (:(=), :jdest, (:call, :first, :jr_dest)),
        (:line, 713, :none),
        (:for, (:(=), :jsrc, :jr_src), (:block,
            (:line, 714, :none),
            (:(=), :idest, (:call, :first, :ir_dest)),
            (:line, 715, :none),
            (:for, (:(=), :isrc, :ir_src), (:block,
                (:line, 716, :none),
                (:(=), (:ref, :B, :idest, :jdest), (:ref, :A, :isrc, :jsrc)),
                (:line, 717, :none),
                (:+=, :idest, (:call, :step, :ir_dest))
              )),
            (:line, 719, :none),
            (:+=, :jdest, (:call, :step, :jr_dest))
          )),
        (:line, 721, :none),
        (:return, :B)
      )),
    (:line, 725, :none),
    (:macrocall, :(Core.@doc), "    copymutable(a)\n\nMake a mutable copy of an array or iterable `a`.  For `a::Array`,\nthis is equivalent to `copy(a)`, but for other array types it may\ndiffer depending on the type of `similar(a)`.  For generic iterables\nthis is equivalent to `collect(a)`.\n\n```jldoctest\njulia> tup = (1, 2, 3)\n(1, 2, 3)\n\njulia> Base.copymutable(tup)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n```\n", (:function, (:call, :copymutable, (:(::), :a, :AbstractArray)), (:block,
          (:line, 745, :none),
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:line, 746, :none),
          (:call, :copy!, (:call, :similar, :a), :a)
        ))),
    (:line, 748, :none),
    (:(=), (:call, :copymutable, :itr), (:block,
        (:line, 748, :none),
        (:call, :collect, :itr)
      )),
    (:line, 750, :none),
    (:(=), (:where, (:call, :zero, (:(::), :x, (:curly, :AbstractArray, :T))), :T), (:block,
        (:line, 750, :none),
        (:call, :fill!, (:call, :similar, :x), (:call, :zero, :T))
      )),
    (:line, 758, :none),
    (:(=), (:call, :start, (:(::), :A, :AbstractArray)), (:block,
        (:line, 758, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:(=), :itr, (:call, :eachindex, :A)),
          (:tuple, :itr, (:call, :start, :itr))
        )
      )),
    (:line, 759, :none),
    (:(=), (:call, :next, (:(::), :A, :AbstractArray), :i), (:block,
        (:line, 759, :none),
        (:block,
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:(=), (:tuple, :idx, :s), (:call, :next, (:ref, :i, 1), (:ref, :i, 2))),
          (:tuple, (:ref, :A, :idx), (:tuple, (:ref, :i, 1), :s))
        )
      )),
    (:line, 760, :none),
    (:(=), (:call, :done, (:(::), :A, :AbstractArray), :i), (:block,
        (:line, 760, :none),
        (:block,
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:call, :done, (:ref, :i, 1), (:ref, :i, 2))
        )
      )),
    (:line, 763, :none),
    (:(=), (:call, :eachindex, (:(::), :A, :AbstractVector)), (:block,
        (:line, 763, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :indices1, :A)
        )
      )),
    (:line, 765, :none),
    (:macrocall, :(Core.@doc), "    eachindex(A...)\n\nCreates an iterable object for visiting each index of an AbstractArray `A` in an efficient\nmanner. For array types that have opted into fast linear indexing (like `Array`), this is\nsimply the range `1:length(A)`. For other array types, this returns a specialized Cartesian\nrange to efficiently index into the array with indices specified for every dimension. For\nother iterables, including strings and dictionaries, this returns an iterator object\nsupporting arbitrary index types (e.g. unevenly spaced or non-integer indices).\n\nExample for a sparse 2-d array:\n\n```jldoctest\njulia> A = sparse([1, 1, 2], [1, 3, 1], [1, 2, -5])\n2×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\n  [1, 1]  =  1\n  [2, 1]  =  -5\n  [1, 3]  =  2\n\njulia> for iter in eachindex(A)\n           @show iter.I[1], iter.I[2]\n           @show A[iter]\n       end\n(iter.I[1], iter.I[2]) = (1, 1)\nA[iter] = 1\n(iter.I[1], iter.I[2]) = (2, 1)\nA[iter] = -5\n(iter.I[1], iter.I[2]) = (1, 2)\nA[iter] = 0\n(iter.I[1], iter.I[2]) = (2, 2)\nA[iter] = 0\n(iter.I[1], iter.I[2]) = (1, 3)\nA[iter] = 2\n(iter.I[1], iter.I[2]) = (2, 3)\nA[iter] = 0\n```\n\nIf you supply more than one `AbstractArray` argument, `eachindex` will create an\niterable object that is fast for all arguments (a `UnitRange`\nif all inputs have fast linear indexing, a `CartesianRange`\notherwise).\nIf the arrays have different sizes and/or dimensionalities, `eachindex` returns an\niterable that spans the largest range along each dimension.\n", (:(=), (:call, :eachindex, (:(::), :A, :AbstractArray)), (:block,
          (:line, 809, :none),
          (:block,
            (:macrocall, Symbol("@_inline_meta")),
            (:call, :eachindex, (:call, :IndexStyle, :A), :A)
          )
        ))),
    (:line, 811, :none),
    (:function, (:call, :eachindex, (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 812, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 813, :none),
        (:call, :eachindex, (:call, :IndexStyle, :A, :B), :A, :B)
      )),
    (:line, 815, :none),
    (:function, (:call, :eachindex, (:(::), :A, :AbstractArray), (:..., (:(::), :B, :AbstractArray))), (:block,
        (:line, 816, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 817, :none),
        (:call, :eachindex, (:call, :IndexStyle, :A, (:..., :B)), :A, (:..., :B))
      )),
    (:line, 819, :none),
    (:(=), (:call, :eachindex, (:(::), :IndexLinear), (:(::), :A, :AbstractArray)), (:block,
        (:line, 819, :none),
        (:call, :linearindices, :A)
      )),
    (:line, 820, :none),
    (:function, (:call, :eachindex, (:(::), :IndexLinear), (:(::), :A, :AbstractArray), (:..., (:(::), :B, :AbstractArray))), (:block,
        (:line, 821, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 822, :none),
        (:(:), 1, (:call, :_maxlength, :A, (:..., :B)))
      )),
    (:line, 824, :none),
    (:(=), (:call, :_maxlength, :A), (:block,
        (:line, 824, :none),
        (:call, :length, :A)
      )),
    (:line, 825, :none),
    (:function, (:call, :_maxlength, :A, :B, (:..., :C)), (:block,
        (:line, 826, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 827, :none),
        (:call, :max, (:call, :length, :A), (:call, :_maxlength, :B, (:..., :C)))
      )),
    (:line, 830, :none),
    (:(=), (:call, :isempty, (:(::), :a, :AbstractArray)), (:block,
        (:line, 830, :none),
        (:call, :(==), (:call, :_length, :a), 0)
      )),
    (:line, 834, :none),
    (:(=), (:where, (:call, :convert, (:(::), (:curly, :Type, (:curly, :AbstractArray, :T, :N))), (:(::), :A, (:curly, :AbstractArray, :T, :N))), :T, :N), (:block,
        (:line, 834, :none),
        :A
      )),
    (:line, 835, :none),
    (:(=), (:where, (:call, :convert, (:(::), (:curly, :Type, (:curly, :AbstractArray, :T, :N))), (:(::), :A, (:curly, :AbstractArray, :S, :N))), :T, :S, :N), (:block,
        (:line, 835, :none),
        (:call, :copy!, (:call, :similar, :A, :T), :A)
      )),
    (:line, 836, :none),
    (:(=), (:where, (:call, :convert, (:(::), (:curly, :Type, (:curly, :AbstractArray, :T))), (:(::), :A, (:curly, :AbstractArray, :S, :N))), :T, :S, :N), (:block,
        (:line, 836, :none),
        (:call, :convert, (:curly, :AbstractArray, :T, :N), :A)
      )),
    (:line, 838, :none),
    (:(=), (:where, (:call, :convert, (:(::), (:curly, :Type, :Array)), (:(::), :A, (:curly, :AbstractArray, :T, :N))), :T, :N), (:block,
        (:line, 838, :none),
        (:call, :convert, (:curly, :Array, :T, :N), :A)
      )),
    (:line, 840, :none),
    (:macrocall, :(Core.@doc), "   of_indices(x, y)\n\nRepresents the array `y` as an array having the same indices type as `x`.\n", (:(=), (:call, :of_indices, :x, :y), (:block,
          (:line, 845, :none),
          (:call, :similar, (:->, :dims, (:block,
                (:line, 845, :none),
                :y
              )), (:call, :oftype, (:call, :indices, :x), (:call, :indices, :y)))
        ))),
    (:line, 847, :none),
    (:(=), (:call, :full, (:(::), :x, :AbstractArray)), (:block,
        (:line, 847, :none),
        :x
      )),
    (:line, 851, :none),
    (:(=), (:where, (:call, :map, (:(::), (:curly, :Type, :T)), (:(::), :r, :StepRange)), (:<:, :T, :Real)), (:block,
        (:line, 851, :none),
        (:(:), (:call, :T, (:., :r, (:quote, #QuoteNode
                :start
              ))), (:call, :T, (:., :r, (:quote, #QuoteNode
                :step
              ))), (:call, :T, (:call, :last, :r)))
      )),
    (:line, 852, :none),
    (:(=), (:where, (:call, :map, (:(::), (:curly, :Type, :T)), (:(::), :r, :UnitRange)), (:<:, :T, :Real)), (:block,
        (:line, 852, :none),
        (:(:), (:call, :T, (:., :r, (:quote, #QuoteNode
                :start
              ))), (:call, :T, (:call, :last, :r)))
      )),
    (:line, 853, :none),
    (:(=), (:where, (:call, :map, (:(::), (:curly, :Type, :T)), (:(::), :r, :StepRangeLen)), (:<:, :T, :AbstractFloat)), (:block,
        (:line, 853, :none),
        (:call, :convert, (:curly, :StepRangeLen, :T), :r)
      )),
    (:line, 854, :none),
    (:function, (:where, (:call, :map, (:(::), (:curly, :Type, :T)), (:(::), :r, :LinSpace)), (:<:, :T, :AbstractFloat)), (:block,
        (:line, 855, :none),
        (:call, :LinSpace, (:call, :T, (:., :r, (:quote, #QuoteNode
                :start
              ))), (:call, :T, (:., :r, (:quote, #QuoteNode
                :stop
              ))), (:call, :length, :r))
      )),
    (:line, 863, :none),
    (:(=), (:where, (:call, :pointer, (:(::), :x, (:curly, :AbstractArray, :T))), :T), (:block,
        (:line, 863, :none),
        (:call, :unsafe_convert, (:curly, :Ptr, :T), :x)
      )),
    (:line, 864, :none),
    (:function, (:where, (:call, :pointer, (:(::), :x, (:curly, :AbstractArray, :T)), (:(::), :i, :Integer)), :T), (:block,
        (:line, 865, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 866, :none),
        (:call, :+, (:call, :unsafe_convert, (:curly, :Ptr, :T), :x), (:call, :*, (:call, :-, :i, (:call, :first, (:call, :linearindices, :x))), (:call, :elsize, :x)))
      )),
    (:line, 879, :none),
    (:function, (:call, :getindex, (:(::), :A, :AbstractArray), (:..., :I)), (:block,
        (:line, 880, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 881, :none),
        (:call, :error_if_canonical_indexing, (:call, :IndexStyle, :A), :A, (:..., :I)),
        (:line, 882, :none),
        (:call, :_getindex, (:call, :IndexStyle, :A), :A, (:..., (:call, :to_indices, :A, :I)))
      )),
    (:line, 884, :none),
    (:function, (:call, :unsafe_getindex, (:(::), :A, :AbstractArray), (:..., :I)), (:block,
        (:line, 885, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 886, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :getindex, :A, (:..., :I)))),
        (:line, 887, :none),
        :r
      )),
    (:line, 890, :none),
    (:(=), (:call, :error_if_canonical_indexing, (:(::), :IndexLinear), (:(::), :A, :AbstractArray), (:(::), :Int)), (:block,
        (:line, 890, :none),
        (:call, :error, "indexing not defined for ", (:call, :typeof, :A))
      )),
    (:line, 892, :none),
    (:(=), (:where, (:call, :error_if_canonical_indexing, (:(::), :IndexCartesian), (:(::), :A, (:curly, :AbstractArray, :T, :N)), (:(::), (:curly, :Vararg, :Int, :N))), :T, :N), (:block,
        (:line, 892, :none),
        (:call, :error, "indexing not defined for ", (:call, :typeof, :A))
      )),
    (:line, 894, :none),
    (:(=), (:call, :error_if_canonical_indexing, (:(::), :IndexStyle), (:(::), :AbstractArray), (:..., (:(::), :Any))), (:block,
        (:line, 894, :none),
        :nothing
      )),
    (:line, 897, :none),
    (:(=), (:call, :_getindex, (:(::), :IndexStyle), (:(::), :A, :AbstractArray), (:..., :I)), (:block,
        (:line, 897, :none),
        (:call, :error, (:string, "indexing ", (:call, :typeof, :A), " with types ", (:call, :typeof, :I), " is not supported"))
      )),
    (:line, 901, :none),
    (:(=), (:call, :_getindex, (:(::), :IndexLinear), (:(::), :A, :AbstractArray), (:(::), :i, :Int)), (:block,
        (:line, 901, :none),
        (:block,
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:call, :getindex, :A, :i)
        )
      )),
    (:line, 902, :none),
    (:(=), (:call, :_getindex, (:(::), :IndexLinear), (:(::), :A, :AbstractArray)), (:block,
        (:line, 902, :none),
        (:block,
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:call, :getindex, :A, (:call, :_to_linear_index, :A))
        )
      )),
    (:line, 903, :none),
    (:function, (:call, :_getindex, (:(::), :IndexLinear), (:(::), :A, :AbstractArray), (:..., (:(::), :I, :Int))), (:block,
        (:line, 904, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 905, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, (:..., :I))),
        (:line, 906, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :getindex, :A, (:call, :_to_linear_index, :A, (:..., :I))))),
        (:line, 907, :none),
        :r
      )),
    (:line, 909, :none),
    (:(=), (:call, :_to_linear_index, (:(::), :A, :AbstractArray), (:(::), :i, :Int)), (:block,
        (:line, 909, :none),
        :i
      )),
    (:line, 910, :none),
    (:(=), (:call, :_to_linear_index, (:(::), :A, :AbstractVector), (:(::), :i, :Int), (:..., (:(::), :I, :Int))), (:block,
        (:line, 910, :none),
        :i
      )),
    (:line, 911, :none),
    (:(=), (:where, (:call, :_to_linear_index, (:(::), :A, (:curly, :AbstractArray, :T, :N)), (:(::), :I, (:curly, :Vararg, :Int, :N))), :T, :N), (:block,
        (:line, 911, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :sub2ind, :A, (:..., :I))
        )
      )),
    (:line, 912, :none),
    (:(=), (:call, :_to_linear_index, (:(::), :A, :AbstractArray)), (:block,
        (:line, 912, :none),
        1
      )),
    (:line, 913, :none),
    (:(=), (:call, :_to_linear_index, (:(::), :A, :AbstractArray), (:..., (:(::), :I, :Int))), (:block,
        (:line, 913, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :sub2ind, :A, (:..., :I))
        )
      )),
    (:line, 916, :none),
    (:function, (:call, :_getindex, (:(::), :IndexCartesian), (:(::), :A, :AbstractArray)), (:block,
        (:line, 917, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 918, :none),
        (:call, :getindex, :A, (:..., (:call, :_to_subscript_indices, :A)))
      )),
    (:line, 920, :none),
    (:function, (:call, :_getindex, (:(::), :IndexCartesian), (:(::), :A, :AbstractArray), (:..., (:(::), :I, :Int))), (:block,
        (:line, 921, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 922, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, (:..., :I))),
        (:line, 923, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :getindex, :A, (:..., (:call, :_to_subscript_indices, :A, (:..., :I)))))),
        (:line, 924, :none),
        :r
      )),
    (:line, 926, :none),
    (:function, (:where, (:call, :_getindex, (:(::), :IndexCartesian), (:(::), :A, (:curly, :AbstractArray, :T, :N)), (:(::), :I, (:curly, :Vararg, :Int, :N))), :T, :N), (:block,
        (:line, 927, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 928, :none),
        (:call, :getindex, :A, (:..., :I))
      )),
    (:line, 930, :none),
    (:(=), (:call, :_to_subscript_indices, (:(::), :A, :AbstractArray), (:(::), :i, :Int)), (:block,
        (:line, 930, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_unsafe_ind2sub, :A, :i)
        )
      )),
    (:line, 931, :none),
    (:(=), (:where, (:call, :_to_subscript_indices, (:(::), :A, (:curly, :AbstractArray, :T, :N))), :T, :N), (:block,
        (:line, 931, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :fill_to_length, (:tuple,), 1, (:curly, :Val, :N))
        )
      )),
    (:line, 932, :none),
    (:(=), (:where, (:call, :_to_subscript_indices, (:(::), :A, (:curly, :AbstractArray, :T, 0))), :T), (:block,
        (:line, 932, :none),
        (:tuple,)
      )),
    (:line, 933, :none),
    (:(=), (:where, (:call, :_to_subscript_indices, (:(::), :A, (:curly, :AbstractArray, :T, 0)), (:(::), :i, :Int)), :T), (:block,
        (:line, 933, :none),
        (:tuple,)
      )),
    (:line, 934, :none),
    (:(=), (:where, (:call, :_to_subscript_indices, (:(::), :A, (:curly, :AbstractArray, :T, 0)), (:..., (:(::), :I, :Int))), :T), (:block,
        (:line, 934, :none),
        (:tuple,)
      )),
    (:line, 935, :none),
    (:function, (:where, (:call, :_to_subscript_indices, (:(::), :A, (:curly, :AbstractArray, :T, :N)), (:..., (:(::), :I, :Int))), :T, :N), (:block,
        (:line, 936, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 937, :none),
        (:(=), (:tuple, :J, :Jrem), (:call, (:., :IteratorsMD, (:quote, #QuoteNode
                :split
              )), :I, (:curly, :Val, :N))),
        (:line, 938, :none),
        (:call, :_to_subscript_indices, :A, :J, :Jrem)
      )),
    (:line, 940, :none),
    (:(=), (:call, :_to_subscript_indices, (:(::), :A, :AbstractArray), (:(::), :J, :Tuple), (:(::), :Jrem, (:curly, :Tuple))), (:block,
        (:line, 940, :none),
        (:call, :__to_subscript_indices, :A, (:call, :indices, :A), :J, :Jrem)
      )),
    (:line, 943, :none),
    (:function, (:call, :__to_subscript_indices, (:(::), :A, :AbstractArray), (:(::), (:curly, :Tuple, (:curly, :Vararg, :OneTo))), (:(::), :J, :Tuple), (:(::), :Jrem, (:curly, :Tuple))), (:block,
        (:line, 944, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 945, :none),
        (:(=), :sz, (:call, :_remaining_size, :J, (:call, :indices, :A))),
        (:line, 946, :none),
        (:tuple, (:..., (:call, :front, :J)), (:..., (:call, :_unsafe_ind2sub, :sz, (:call, :last, :J))))
      )),
    (:line, 950, :none),
    (:function, (:call, :__to_subscript_indices, (:(::), :A, :AbstractArray), (:(::), (:curly, :Tuple, :AbstractUnitRange, (:curly, :Vararg, :AbstractUnitRange))), (:(::), :J, :Tuple), (:(::), :Jrem, (:curly, :Tuple))), (:block,
        (:line, 952, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 953, :none),
        (:tuple, (:..., :J), (:..., (:call, :map, :first, (:call, :tail, (:call, :_remaining_size, :J, (:call, :indices, :A))))))
      )),
    (:line, 955, :none),
    (:(=), (:call, :_to_subscript_indices, :A, (:(::), :J, :Tuple), (:(::), :Jrem, :Tuple)), (:block,
        (:line, 955, :none),
        :J
      )),
    (:line, 956, :none),
    (:(=), (:where, (:call, :_to_subscript_indices, (:(::), :A, (:curly, :AbstractArray, :T, :N)), (:(::), :I, (:curly, :Vararg, :Int, :N))), :T, :N), (:block,
        (:line, 956, :none),
        :I
      )),
    (:line, 957, :none),
    (:(=), (:call, :_remaining_size, (:(::), (:curly, :Tuple, :Any)), (:(::), :t, :Tuple)), (:block,
        (:line, 957, :none),
        :t
      )),
    (:line, 958, :none),
    (:(=), (:call, :_remaining_size, (:(::), :h, :Tuple), (:(::), :t, :Tuple)), (:block,
        (:line, 958, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_remaining_size, (:call, :tail, :h), (:call, :tail, :t))
        )
      )),
    (:line, 959, :none),
    (:(=), (:call, :_unsafe_ind2sub, (:(::), (:curly, :Tuple)), :i), (:block,
        (:line, 959, :none),
        (:tuple,)
      )),
    (:line, 960, :none),
    (:(=), (:call, :_unsafe_ind2sub, :sz, :i), (:block,
        (:line, 960, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :ind2sub, :sz, :i)
        )
      )),
    (:line, 964, :none),
    (:function, (:call, :setindex!, (:(::), :A, :AbstractArray), :v, (:..., :I)), (:block,
        (:line, 965, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 966, :none),
        (:call, :error_if_canonical_indexing, (:call, :IndexStyle, :A), :A, (:..., :I)),
        (:line, 967, :none),
        (:call, :_setindex!, (:call, :IndexStyle, :A), :A, :v, (:..., (:call, :to_indices, :A, :I)))
      )),
    (:line, 969, :none),
    (:function, (:call, :unsafe_setindex!, (:(::), :A, :AbstractArray), :v, (:..., :I)), (:block,
        (:line, 970, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 971, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :setindex!, :A, :v, (:..., :I)))),
        (:line, 972, :none),
        :r
      )),
    (:line, 975, :none),
    (:(=), (:call, :_setindex!, (:(::), :IndexStyle), (:(::), :A, :AbstractArray), :v, (:..., :I)), (:block,
        (:line, 975, :none),
        (:call, :error, (:string, "indexing ", (:call, :typeof, :A), " with types ", (:call, :typeof, :I), " is not supported"))
      )),
    (:line, 979, :none),
    (:(=), (:call, :_setindex!, (:(::), :IndexLinear), (:(::), :A, :AbstractArray), :v, (:(::), :i, :Int)), (:block,
        (:line, 979, :none),
        (:block,
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:call, :setindex!, :A, :v, :i)
        )
      )),
    (:line, 980, :none),
    (:(=), (:call, :_setindex!, (:(::), :IndexLinear), (:(::), :A, :AbstractArray), :v), (:block,
        (:line, 980, :none),
        (:block,
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:call, :setindex!, :A, :v, (:call, :_to_linear_index, :A))
        )
      )),
    (:line, 981, :none),
    (:function, (:call, :_setindex!, (:(::), :IndexLinear), (:(::), :A, :AbstractArray), :v, (:..., (:(::), :I, :Int))), (:block,
        (:line, 982, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 983, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, (:..., :I))),
        (:line, 984, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :setindex!, :A, :v, (:call, :_to_linear_index, :A, (:..., :I))))),
        (:line, 985, :none),
        :r
      )),
    (:line, 989, :none),
    (:function, (:where, (:call, :_setindex!, (:(::), :IndexCartesian), (:(::), :A, (:curly, :AbstractArray, :T, :N)), :v, (:(::), :I, (:curly, :Vararg, :Int, :N))), :T, :N), (:block,
        (:line, 990, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 991, :none),
        (:call, :setindex!, :A, :v, (:..., :I))
      )),
    (:line, 993, :none),
    (:function, (:call, :_setindex!, (:(::), :IndexCartesian), (:(::), :A, :AbstractArray), :v), (:block,
        (:line, 994, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 995, :none),
        (:call, :setindex!, :A, :v, (:..., (:call, :_to_subscript_indices, :A)))
      )),
    (:line, 997, :none),
    (:function, (:call, :_setindex!, (:(::), :IndexCartesian), (:(::), :A, :AbstractArray), :v, (:..., (:(::), :I, :Int))), (:block,
        (:line, 998, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 999, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, (:..., :I))),
        (:line, 1000, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :r, (:call, :setindex!, :A, :v, (:..., (:call, :_to_subscript_indices, :A, (:..., :I)))))),
        (:line, 1001, :none),
        :r
      )),
    (:line, 1006, :none),
    (:(=), (:curly, :RangeVecIntList, (:<:, :A, (:curly, :AbstractVector, :Int))), (:curly, :Union, (:curly, :Tuple, (:curly, :Vararg, (:curly, :Union, :Range, (:curly, :AbstractVector, :Int)))), (:curly, :AbstractVector, (:curly, :UnitRange, :Int)), (:curly, :AbstractVector, (:curly, :Range, :Int)), (:curly, :AbstractVector, :A))),
    (:line, 1009, :none),
    (:(=), (:call, :get, (:(::), :A, :AbstractArray), (:(::), :i, :Integer), :default), (:block,
        (:line, 1009, :none),
        (:if, (:call, :checkbounds, :Bool, :A, :i), (:ref, :A, :i), :default)
      )),
    (:line, 1010, :none),
    (:(=), (:call, :get, (:(::), :A, :AbstractArray), (:(::), :I, (:curly, :Tuple)), :default), (:block,
        (:line, 1010, :none),
        (:call, :similar, :A, (:call, :typeof, :default), 0)
      )),
    (:line, 1011, :none),
    (:(=), (:call, :get, (:(::), :A, :AbstractArray), (:(::), :I, :Dims), :default), (:block,
        (:line, 1011, :none),
        (:if, (:call, :checkbounds, :Bool, :A, (:..., :I)), (:ref, :A, (:..., :I)), :default)
      )),
    (:line, 1013, :none),
    (:function, (:where, (:call, :get!, (:(::), :X, (:curly, :AbstractVector, :T)), (:(::), :A, :AbstractVector), (:(::), :I, (:curly, :Union, :Range, (:curly, :AbstractVector, :Int))), (:(::), :default, :T)), :T), (:block,
        (:line, 1015, :none),
        (:(=), :ind, (:call, :findin, :I, (:call, :indices1, :A))),
        (:line, 1016, :none),
        (:(=), (:ref, :X, :ind), (:ref, :A, (:ref, :I, :ind))),
        (:line, 1017, :none),
        (:(=), :Xind, (:call, :indices1, :X)),
        (:line, 1018, :none),
        (:(=), (:ref, :X, (:(:), (:call, :first, :Xind), (:call, :-, (:call, :first, :ind), 1))), :default),
        (:line, 1019, :none),
        (:(=), (:ref, :X, (:(:), (:call, :+, (:call, :last, :ind), 1), (:call, :last, :Xind))), :default),
        (:line, 1020, :none),
        :X
      )),
    (:line, 1022, :none),
    (:function, (:where, (:call, :get!, (:(::), :X, (:curly, :AbstractArray, :T)), (:(::), :A, :AbstractArray), (:(::), :I, (:curly, :Union, :Range, (:curly, :AbstractVector, :Int))), (:(::), :default, :T)), :T), (:block,
        (:line, 1024, :none),
        (:(=), :ind, (:call, :findin, :I, (:(:), 1, (:call, :length, :A)))),
        (:line, 1025, :none),
        (:(=), (:ref, :X, :ind), (:ref, :A, (:ref, :I, :ind))),
        (:line, 1026, :none),
        (:(=), (:ref, :X, (:(:), 1, (:call, :-, (:call, :first, :ind), 1))), :default),
        (:line, 1027, :none),
        (:(=), (:ref, :X, (:(:), (:call, :+, (:call, :last, :ind), 1), (:call, :length, :X))), :default),
        (:line, 1028, :none),
        :X
      )),
    (:line, 1031, :none),
    (:(=), (:call, :get, (:(::), :A, :AbstractArray), (:(::), :I, :Range), :default), (:block,
        (:line, 1031, :none),
        (:call, :get!, (:call, :similar, :A, (:call, :typeof, :default), (:call, :index_shape, :I)), :A, :I, :default)
      )),
    (:line, 1034, :none),
    (:function, (:where, (:call, :get!, (:(::), :X, (:curly, :AbstractArray, :T)), (:(::), :A, :AbstractArray), (:(::), :I, :RangeVecIntList), (:(::), :default, :T)), :T), (:block,
        (:line, 1035, :none),
        (:call, :fill!, :X, :default),
        (:line, 1036, :none),
        (:(=), (:tuple, :dst, :src), (:call, :indcopy, (:call, :size, :A), :I)),
        (:line, 1037, :none),
        (:(=), (:ref, :X, (:..., :dst)), (:ref, :A, (:..., :src))),
        (:line, 1038, :none),
        :X
      )),
    (:line, 1041, :none),
    (:(=), (:call, :get, (:(::), :A, :AbstractArray), (:(::), :I, :RangeVecIntList), :default), (:block,
        (:line, 1041, :none),
        (:call, :get!, (:call, :similar, :A, (:call, :typeof, :default), (:call, :index_shape, (:..., :I))), :A, :I, :default)
      )),
    (:line, 1045, :none),
    (:(=), (:call, :replace_in_print_matrix, (:(::), :A, :AbstractMatrix), (:(::), :i, :Integer), (:(::), :j, :Integer), (:(::), :s, :AbstractString)), (:block,
        (:line, 1045, :none),
        :s
      )),
    (:line, 1046, :none),
    (:(=), (:call, :replace_in_print_matrix, (:(::), :A, :AbstractVector), (:(::), :i, :Integer), (:(::), :j, :Integer), (:(::), :s, :AbstractString)), (:block,
        (:line, 1046, :none),
        :s
      )),
    (:line, 1049, :none),
    (:(=), (:call, :eltypeof, :x), (:block,
        (:line, 1049, :none),
        (:call, :typeof, :x)
      )),
    (:line, 1050, :none),
    (:(=), (:call, :eltypeof, (:(::), :x, :AbstractArray)), (:block,
        (:line, 1050, :none),
        (:call, :eltype, :x)
      )),
    (:line, 1052, :none),
    (:(=), (:call, :promote_eltypeof), (:block,
        (:line, 1052, :none),
        :Bottom
      )),
    (:line, 1053, :none),
    (:(=), (:call, :promote_eltypeof, :v1, (:..., :vs)), (:block,
        (:line, 1053, :none),
        (:call, :promote_type, (:call, :eltypeof, :v1), (:call, :promote_eltypeof, (:..., :vs)))
      )),
    (:line, 1055, :none),
    (:(=), (:call, :promote_eltype), (:block,
        (:line, 1055, :none),
        :Bottom
      )),
    (:line, 1056, :none),
    (:(=), (:call, :promote_eltype, :v1, (:..., :vs)), (:block,
        (:line, 1056, :none),
        (:call, :promote_type, (:call, :eltype, :v1), (:call, :promote_eltype, (:..., :vs)))
      )),
    (:line, 1059, :none),
    (:(=), (:call, :cat, (:(::), :catdim, :Integer)), (:block,
        (:line, 1059, :none),
        (:call, (:curly, :Array, :Any, 1), 0)
      )),
    (:line, 1061, :none),
    (:(=), (:where, (:call, :typed_vcat, (:(::), (:curly, :Type, :T))), :T), (:block,
        (:line, 1061, :none),
        (:call, (:curly, :Array, :T, 1), 0)
      )),
    (:line, 1062, :none),
    (:(=), (:where, (:call, :typed_hcat, (:(::), (:curly, :Type, :T))), :T), (:block,
        (:line, 1062, :none),
        (:call, (:curly, :Array, :T, 1), 0)
      )),
    (:line, 1065, :none),
    (:(=), (:where, (:call, :vcat, (:..., (:(::), :X, :T))), :T), (:block,
        (:line, 1065, :none),
        (:typed_comprehension, :T, (:generator, (:ref, :X, :i), (:(=), :i, (:(:), 1, (:call, :length, :X)))))
      )),
    (:line, 1066, :none),
    (:(=), (:where, (:call, :vcat, (:..., (:(::), :X, :T))), (:<:, :T, :Number)), (:block,
        (:line, 1066, :none),
        (:typed_comprehension, :T, (:generator, (:ref, :X, :i), (:(=), :i, (:(:), 1, (:call, :length, :X)))))
      )),
    (:line, 1067, :none),
    (:(=), (:where, (:call, :hcat, (:..., (:(::), :X, :T))), :T), (:block,
        (:line, 1067, :none),
        (:typed_comprehension, :T, (:generator, (:ref, :X, :j), (:(=), :i, (:(:), 1, 1)), (:(=), :j, (:(:), 1, (:call, :length, :X)))))
      )),
    (:line, 1068, :none),
    (:(=), (:where, (:call, :hcat, (:..., (:(::), :X, :T))), (:<:, :T, :Number)), (:block,
        (:line, 1068, :none),
        (:typed_comprehension, :T, (:generator, (:ref, :X, :j), (:(=), :i, (:(:), 1, 1)), (:(=), :j, (:(:), 1, (:call, :length, :X)))))
      )),
    (:line, 1070, :none),
    (:(=), (:call, :vcat, (:..., (:(::), :X, :Number))), (:block,
        (:line, 1070, :none),
        (:call, :hvcat_fill, (:call, (:curly, :Array, (:call, :promote_typeof, (:..., :X))), (:call, :length, :X)), :X)
      )),
    (:line, 1071, :none),
    (:(=), (:call, :hcat, (:..., (:(::), :X, :Number))), (:block,
        (:line, 1071, :none),
        (:call, :hvcat_fill, (:call, (:curly, :Array, (:call, :promote_typeof, (:..., :X))), 1, (:call, :length, :X)), :X)
      )),
    (:line, 1072, :none),
    (:(=), (:where, (:call, :typed_vcat, (:(::), (:curly, :Type, :T)), (:..., (:(::), :X, :Number))), :T), (:block,
        (:line, 1072, :none),
        (:call, :hvcat_fill, (:call, (:curly, :Array, :T, 1), (:call, :length, :X)), :X)
      )),
    (:line, 1073, :none),
    (:(=), (:where, (:call, :typed_hcat, (:(::), (:curly, :Type, :T)), (:..., (:(::), :X, :Number))), :T), (:block,
        (:line, 1073, :none),
        (:call, :hvcat_fill, (:call, (:curly, :Array, :T, 2), 1, (:call, :length, :X)), :X)
      )),
    (:line, 1075, :none),
    (:(=), (:call, :vcat, (:..., (:(::), :V, :AbstractVector))), (:block,
        (:line, 1075, :none),
        (:call, :typed_vcat, (:call, :promote_eltype, (:..., :V)), (:..., :V))
      )),
    (:line, 1076, :none),
    (:(=), (:where, (:call, :vcat, (:..., (:(::), :V, (:curly, :AbstractVector, :T)))), :T), (:block,
        (:line, 1076, :none),
        (:call, :typed_vcat, :T, (:..., :V))
      )),
    (:line, 1078, :none),
    (:function, (:where, (:call, :typed_vcat, (:(::), (:curly, :Type, :T)), (:..., (:(::), :V, :AbstractVector))), :T), (:block,
        (:line, 1079, :none),
        (:(=), (:(::), :n, :Int), 0),
        (:line, 1080, :none),
        (:for, (:(=), :Vk, :V), (:block,
            (:line, 1081, :none),
            (:+=, :n, (:call, :length, :Vk))
          )),
        (:line, 1083, :none),
        (:(=), :a, (:call, :similar, (:ref, :V, 1), :T, :n)),
        (:line, 1084, :none),
        (:(=), :pos, 1),
        (:line, 1085, :none),
        (:for, (:(=), :k, (:(:), 1, (:call, :length, :V))), (:block,
            (:line, 1086, :none),
            (:(=), :Vk, (:ref, :V, :k)),
            (:line, 1087, :none),
            (:(=), :p1, (:call, :-, (:call, :+, :pos, (:call, :length, :Vk)), 1)),
            (:line, 1088, :none),
            (:(=), (:ref, :a, (:(:), :pos, :p1)), :Vk),
            (:line, 1089, :none),
            (:(=), :pos, (:call, :+, :p1, 1))
          )),
        (:line, 1091, :none),
        :a
      )),
    (:line, 1094, :none),
    (:(=), (:call, :hcat, (:..., (:(::), :A, :AbstractVecOrMat))), (:block,
        (:line, 1094, :none),
        (:call, :typed_hcat, (:call, :promote_eltype, (:..., :A)), (:..., :A))
      )),
    (:line, 1095, :none),
    (:(=), (:where, (:call, :hcat, (:..., (:(::), :A, (:curly, :AbstractVecOrMat, :T)))), :T), (:block,
        (:line, 1095, :none),
        (:call, :typed_hcat, :T, (:..., :A))
      )),
    (:line, 1097, :none),
    (:function, (:where, (:call, :typed_hcat, (:(::), (:curly, :Type, :T)), (:..., (:(::), :A, :AbstractVecOrMat))), :T), (:block,
        (:line, 1098, :none),
        (:(=), :nargs, (:call, :length, :A)),
        (:line, 1099, :none),
        (:(=), :nrows, (:call, :size, (:ref, :A, 1), 1)),
        (:line, 1100, :none),
        (:(=), :ncols, 0),
        (:line, 1101, :none),
        (:(=), :dense, true),
        (:line, 1102, :none),
        (:for, (:(=), :j, (:(:), 1, :nargs)), (:block,
            (:line, 1103, :none),
            (:(=), :Aj, (:ref, :A, :j)),
            (:line, 1104, :none),
            (:if, (:call, :(!=), (:call, :size, :Aj, 1), :nrows), (:block,
                (:line, 1105, :none),
                (:call, :throw, (:call, :ArgumentError, (:string, "number of rows of each array must match (got ", (:call, :map, (:->, :x, (:block,
                            (:line, 1105, :none),
                            (:call, :size, :x, 1)
                          )), :A), ")")))
              )),
            (:line, 1107, :none),
            (:&=, :dense, (:call, :isa, :Aj, :Array)),
            (:line, 1108, :none),
            (:(=), :nd, (:call, :ndims, :Aj)),
            (:line, 1109, :none),
            (:+=, :ncols, (:if, (:call, :(==), :nd, 2), (:call, :size, :Aj, 2), 1))
          )),
        (:line, 1111, :none),
        (:(=), :B, (:call, :similar, (:ref, :A, 1), :T, :nrows, :ncols)),
        (:line, 1112, :none),
        (:(=), :pos, 1),
        (:line, 1113, :none),
        (:if, :dense, (:block,
            (:line, 1114, :none),
            (:for, (:(=), :k, (:(:), 1, :nargs)), (:block,
                (:line, 1115, :none),
                (:(=), :Ak, (:ref, :A, :k)),
                (:line, 1116, :none),
                (:(=), :n, (:call, :length, :Ak)),
                (:line, 1117, :none),
                (:call, :copy!, :B, :pos, :Ak, 1, :n),
                (:line, 1118, :none),
                (:+=, :pos, :n)
              ))
          ), (:block,
            (:line, 1121, :none),
            (:for, (:(=), :k, (:(:), 1, :nargs)), (:block,
                (:line, 1122, :none),
                (:(=), :Ak, (:ref, :A, :k)),
                (:line, 1123, :none),
                (:(=), :p1, (:call, :-, (:call, :+, :pos, (:if, (:call, :isa, :Ak, :AbstractMatrix), (:call, :size, :Ak, 2), 1)), 1)),
                (:line, 1124, :none),
                (:(=), (:ref, :B, :(:), (:(:), :pos, :p1)), :Ak),
                (:line, 1125, :none),
                (:(=), :pos, (:call, :+, :p1, 1))
              ))
          )),
        (:line, 1128, :none),
        (:return, :B)
      )),
    (:line, 1131, :none),
    (:(=), (:call, :vcat, (:..., (:(::), :A, :AbstractMatrix))), (:block,
        (:line, 1131, :none),
        (:call, :typed_vcat, (:call, :promote_eltype, (:..., :A)), (:..., :A))
      )),
    (:line, 1132, :none),
    (:(=), (:where, (:call, :vcat, (:..., (:(::), :A, (:curly, :AbstractMatrix, :T)))), :T), (:block,
        (:line, 1132, :none),
        (:call, :typed_vcat, :T, (:..., :A))
      )),
    (:line, 1134, :none),
    (:function, (:where, (:call, :typed_vcat, (:(::), (:curly, :Type, :T)), (:..., (:(::), :A, :AbstractMatrix))), :T), (:block,
        (:line, 1135, :none),
        (:(=), :nargs, (:call, :length, :A)),
        (:line, 1136, :none),
        (:(=), :nrows, (:(::), (:call, :sum, (:->, :a, (:block,
                  (:line, 1136, :none),
                  (:call, :size, :a, 1)
                )), :A), :Int)),
        (:line, 1137, :none),
        (:(=), :ncols, (:call, :size, (:ref, :A, 1), 2)),
        (:line, 1138, :none),
        (:for, (:(=), :j, (:(:), 2, :nargs)), (:block,
            (:line, 1139, :none),
            (:if, (:call, :(!=), (:call, :size, (:ref, :A, :j), 2), :ncols), (:block,
                (:line, 1140, :none),
                (:call, :throw, (:call, :ArgumentError, (:string, "number of columns of each array must match (got ", (:call, :map, (:->, :x, (:block,
                            (:line, 1140, :none),
                            (:call, :size, :x, 2)
                          )), :A), ")")))
              ))
          )),
        (:line, 1143, :none),
        (:(=), :B, (:call, :similar, (:ref, :A, 1), :T, :nrows, :ncols)),
        (:line, 1144, :none),
        (:(=), :pos, 1),
        (:line, 1145, :none),
        (:for, (:(=), :k, (:(:), 1, :nargs)), (:block,
            (:line, 1146, :none),
            (:(=), :Ak, (:ref, :A, :k)),
            (:line, 1147, :none),
            (:(=), :p1, (:call, :-, (:call, :+, :pos, (:call, :size, :Ak, 1)), 1)),
            (:line, 1148, :none),
            (:(=), (:ref, :B, (:(:), :pos, :p1), :(:)), :Ak),
            (:line, 1149, :none),
            (:(=), :pos, (:call, :+, :p1, 1))
          )),
        (:line, 1151, :none),
        (:return, :B)
      )),
    (:line, 1157, :none),
    (:(=), (:call, :cat_size, :A), (:block,
        (:line, 1157, :none),
        (:tuple, 1)
      )),
    (:line, 1158, :none),
    (:(=), (:call, :cat_size, (:(::), :A, :AbstractArray)), (:block,
        (:line, 1158, :none),
        (:call, :size, :A)
      )),
    (:line, 1159, :none),
    (:(=), (:call, :cat_size, :A, :d), (:block,
        (:line, 1159, :none),
        1
      )),
    (:line, 1160, :none),
    (:(=), (:call, :cat_size, (:(::), :A, :AbstractArray), :d), (:block,
        (:line, 1160, :none),
        (:call, :size, :A, :d)
      )),
    (:line, 1162, :none),
    (:(=), (:call, :cat_indices, :A, :d), (:block,
        (:line, 1162, :none),
        (:call, :OneTo, 1)
      )),
    (:line, 1163, :none),
    (:(=), (:call, :cat_indices, (:(::), :A, :AbstractArray), :d), (:block,
        (:line, 1163, :none),
        (:call, :indices, :A, :d)
      )),
    (:line, 1165, :none),
    (:(=), (:call, :cat_similar, :A, :T, :shape), (:block,
        (:line, 1165, :none),
        (:call, (:curly, :Array, :T), :shape)
      )),
    (:line, 1166, :none),
    (:(=), (:call, :cat_similar, (:(::), :A, :AbstractArray), :T, :shape), (:block,
        (:line, 1166, :none),
        (:call, :similar, :A, :T, :shape)
      )),
    (:line, 1168, :none),
    (:(=), (:call, :cat_shape, :dims, (:(::), :shape, :Tuple)), (:block,
        (:line, 1168, :none),
        :shape
      )),
    (:line, 1169, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :cat_shape, :dims, (:(::), :shape, :Tuple), (:(::), :nshape, :Tuple), (:..., (:(::), :shapes, :Tuple))), (:block,
          (:line, 1169, :none),
          (:call, :cat_shape, :dims, (:call, :_cshp, :dims, (:tuple,), :shape, :nshape), (:..., :shapes))
        ))),
    (:line, 1172, :none),
    (:(=), (:call, :_cshp, (:(::), (:curly, :Tuple)), :out, (:(::), (:curly, :Tuple)), (:(::), (:curly, :Tuple))), (:block,
        (:line, 1172, :none),
        :out
      )),
    (:line, 1173, :none),
    (:(=), (:call, :_cshp, (:(::), (:curly, :Tuple)), :out, (:(::), (:curly, :Tuple)), :nshape), (:block,
        (:line, 1173, :none),
        (:tuple, (:..., :out), (:..., :nshape))
      )),
    (:line, 1174, :none),
    (:(=), (:call, :_cshp, :dims, :out, (:(::), (:curly, :Tuple)), (:(::), (:curly, :Tuple))), (:block,
        (:line, 1174, :none),
        (:tuple, (:..., :out), (:..., (:call, :map, (:->, :b, (:block,
                  (:line, 1174, :none),
                  1
                )), :dims)))
      )),
    (:line, 1175, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :_cshp, :dims, :out, :shape, (:(::), (:curly, :Tuple))), (:block,
          (:line, 1175, :none),
          (:call, :_cshp, (:call, :tail, :dims), (:tuple, (:..., :out), (:call, :+, (:ref, :shape, 1), (:ref, :dims, 1))), (:call, :tail, :shape), (:tuple,))
        ))),
    (:line, 1177, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :_cshp, :dims, :out, (:(::), (:curly, :Tuple)), :nshape), (:block,
          (:line, 1177, :none),
          (:call, :_cshp, (:call, :tail, :dims), (:tuple, (:..., :out), (:ref, :nshape, 1)), (:tuple,), (:call, :tail, :nshape))
        ))),
    (:line, 1179, :none),
    (:macrocall, Symbol("@inline"), (:function, (:call, :_cshp, (:(::), (:curly, :Tuple)), :out, :shape, (:(::), (:curly, :Tuple))), (:block,
          (:line, 1180, :none),
          (:call, :_cs, (:call, :+, (:call, :length, :out), 1), false, (:ref, :shape, 1), 1),
          (:line, 1181, :none),
          (:call, :_cshp, (:tuple,), (:tuple, (:..., :out), 1), (:call, :tail, :shape), (:tuple,))
        ))),
    (:line, 1183, :none),
    (:macrocall, Symbol("@inline"), (:function, (:call, :_cshp, (:(::), (:curly, :Tuple)), :out, :shape, :nshape), (:block,
          (:line, 1184, :none),
          (:(=), :next, (:call, :_cs, (:call, :+, (:call, :length, :out), 1), false, (:ref, :shape, 1), (:ref, :nshape, 1))),
          (:line, 1185, :none),
          (:call, :_cshp, (:tuple,), (:tuple, (:..., :out), :next), (:call, :tail, :shape), (:call, :tail, :nshape))
        ))),
    (:line, 1187, :none),
    (:macrocall, Symbol("@inline"), (:function, (:call, :_cshp, :dims, :out, :shape, :nshape), (:block,
          (:line, 1188, :none),
          (:(=), :next, (:call, :_cs, (:call, :+, (:call, :length, :out), 1), (:ref, :dims, 1), (:ref, :shape, 1), (:ref, :nshape, 1))),
          (:line, 1189, :none),
          (:call, :_cshp, (:call, :tail, :dims), (:tuple, (:..., :out), :next), (:call, :tail, :shape), (:call, :tail, :nshape))
        ))),
    (:line, 1192, :none),
    (:(=), (:call, :_cs, :d, :concat, :a, :b), (:block,
        (:line, 1192, :none),
        (:if, :concat, (:call, :+, :a, :b), (:if, (:call, :(==), :a, :b), :a, (:call, :throw, (:call, :DimensionMismatch, (:call, :string, "mismatch in dimension ", :d, " (expected ", :a, " got ", :b, ")")))))
      )),
    (:line, 1195, :none),
    (:(=), (:call, (:curly, :dims2cat, :n), (:(::), (:curly, :Type, (:curly, :Val, :n)))), (:block,
        (:line, 1195, :none),
        (:call, :ntuple, (:->, :i, (:block,
              (:line, 1195, :none),
              (:call, :(==), :i, :n)
            )), (:curly, :Val, :n))
      )),
    (:line, 1196, :none),
    (:(=), (:call, :dims2cat, :dims), (:block,
        (:line, 1196, :none),
        (:call, :ntuple, (:->, :i, (:block,
              (:line, 1196, :none),
              (:call, :in, :i, :dims)
            )), (:call, :maximum, :dims))
      )),
    (:line, 1198, :none),
    (:(=), (:call, :cat, :dims, (:..., :X)), (:block,
        (:line, 1198, :none),
        (:call, :cat_t, :dims, (:call, :promote_eltypeof, (:..., :X)), (:..., :X))
      )),
    (:line, 1200, :none),
    (:function, (:call, :cat_t, :dims, (:(::), :T, :Type), (:..., :X)), (:block,
        (:line, 1201, :none),
        (:(=), :catdims, (:call, :dims2cat, :dims)),
        (:line, 1202, :none),
        (:(=), :shape, (:call, :cat_shape, :catdims, (:tuple,), (:..., (:call, :map, :cat_size, :X)))),
        (:line, 1203, :none),
        (:(=), :A, (:call, :cat_similar, (:ref, :X, 1), :T, :shape)),
        (:line, 1204, :none),
        (:if, (:&&, (:<:, :T, :Number), (:call, :>, (:call, :countnz, :catdims), 1)), (:block,
            (:line, 1205, :none),
            (:call, :fill!, :A, (:call, :zero, :T))
          )),
        (:line, 1207, :none),
        (:return, (:call, :_cat, :A, :shape, :catdims, (:..., :X)))
      )),
    (:line, 1210, :none),
    (:function, (:where, (:call, :_cat, :A, (:(::), :shape, (:curly, :NTuple, :N)), :catdims, (:..., :X)), :N), (:block,
        (:line, 1211, :none),
        (:(=), :offsets, (:call, :zeros, :Int, :N)),
        (:line, 1212, :none),
        (:(=), :inds, (:call, (:curly, :Vector, (:curly, :UnitRange, :Int)), :N)),
        (:line, 1213, :none),
        (:(=), :concat, (:call, :copy!, (:call, :zeros, :Bool, :N), :catdims)),
        (:line, 1214, :none),
        (:for, (:(=), :x, :X), (:block,
            (:line, 1215, :none),
            (:for, (:(=), :i, (:(:), 1, :N)), (:block,
                (:line, 1216, :none),
                (:if, (:ref, :concat, :i), (:block,
                    (:line, 1217, :none),
                    (:(=), (:ref, :inds, :i), (:call, :+, (:ref, :offsets, :i), (:call, :cat_indices, :x, :i))),
                    (:line, 1218, :none),
                    (:+=, (:ref, :offsets, :i), (:call, :cat_size, :x, :i))
                  ), (:block,
                    (:line, 1220, :none),
                    (:(=), (:ref, :inds, :i), (:(:), 1, (:ref, :shape, :i)))
                  ))
              )),
            (:line, 1223, :none),
            (:(=), (:(::), :I, (:curly, :NTuple, :N, (:curly, :UnitRange, :Int))), (:tuple, (:..., :inds))),
            (:line, 1224, :none),
            (:(=), (:ref, :A, (:..., :I)), :x)
          )),
        (:line, 1226, :none),
        (:return, :A)
      )),
    (:line, 1229, :none),
    (:macrocall, :(Core.@doc), "    vcat(A...)\n\nConcatenate along dimension 1.\n\n```jldoctest\njulia> a = [1 2 3 4 5]\n1×5 Array{Int64,2}:\n 1  2  3  4  5\n\njulia> b = [6 7 8 9 10; 11 12 13 14 15]\n2×5 Array{Int64,2}:\n  6   7   8   9  10\n 11  12  13  14  15\n\njulia> vcat(a,b)\n3×5 Array{Int64,2}:\n  1   2   3   4   5\n  6   7   8   9  10\n 11  12  13  14  15\n\njulia> c = ([1 2 3], [4 5 6])\n([1 2 3], [4 5 6])\n\njulia> vcat(c...)\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n```\n", (:(=), (:call, :vcat, (:..., :X)), (:block,
          (:line, 1259, :none),
          (:call, :cat, (:curly, :Val, 1), (:..., :X))
        ))),
    (:line, 1260, :none),
    (:macrocall, :(Core.@doc), "    hcat(A...)\n\nConcatenate along dimension 2.\n\n```jldoctest\njulia> a = [1; 2; 3; 4; 5]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> b = [6 7; 8 9; 10 11; 12 13; 14 15]\n5×2 Array{Int64,2}:\n  6   7\n  8   9\n 10  11\n 12  13\n 14  15\n\njulia> hcat(a,b)\n5×3 Array{Int64,2}:\n 1   6   7\n 2   8   9\n 3  10  11\n 4  12  13\n 5  14  15\n\njulia> c = ([1; 2; 3], [4; 5; 6])\n([1, 2, 3], [4, 5, 6])\n\njulia> hcat(c...)\n3×2 Array{Int64,2}:\n 1  4\n 2  5\n 3  6\n```\n", (:(=), (:call, :hcat, (:..., :X)), (:block,
          (:line, 1300, :none),
          (:call, :cat, (:curly, :Val, 2), (:..., :X))
        ))),
    (:line, 1302, :none),
    (:(=), (:call, :typed_vcat, (:(::), :T, :Type), (:..., :X)), (:block,
        (:line, 1302, :none),
        (:call, :cat_t, (:curly, :Val, 1), :T, (:..., :X))
      )),
    (:line, 1303, :none),
    (:(=), (:call, :typed_hcat, (:(::), :T, :Type), (:..., :X)), (:block,
        (:line, 1303, :none),
        (:call, :cat_t, (:curly, :Val, 2), :T, (:..., :X))
      )),
    (:line, 1305, :none),
    (:(=), (:where, (:call, :cat, :catdims, (:..., (:(::), :A, (:curly, :AbstractArray, :T)))), :T), (:block,
        (:line, 1305, :none),
        (:call, :cat_t, :catdims, :T, (:..., :A))
      )),
    (:line, 1309, :none),
    (:(=), (:call, :vcat, (:(::), :A, :AbstractArray)), (:block,
        (:line, 1309, :none),
        (:call, :cat, (:curly, :Val, 1), :A)
      )),
    (:line, 1310, :none),
    (:(=), (:call, :vcat, (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1310, :none),
        (:call, :cat, (:curly, :Val, 1), :A, :B)
      )),
    (:line, 1311, :none),
    (:(=), (:call, :vcat, (:..., (:(::), :A, :AbstractArray))), (:block,
        (:line, 1311, :none),
        (:call, :cat, (:curly, :Val, 1), (:..., :A))
      )),
    (:line, 1312, :none),
    (:(=), (:call, :hcat, (:(::), :A, :AbstractArray)), (:block,
        (:line, 1312, :none),
        (:call, :cat, (:curly, :Val, 2), :A)
      )),
    (:line, 1313, :none),
    (:(=), (:call, :hcat, (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1313, :none),
        (:call, :cat, (:curly, :Val, 2), :A, :B)
      )),
    (:line, 1314, :none),
    (:(=), (:call, :hcat, (:..., (:(::), :A, :AbstractArray))), (:block,
        (:line, 1314, :none),
        (:call, :cat, (:curly, :Val, 2), (:..., :A))
      )),
    (:line, 1316, :none),
    (:(=), (:call, :typed_vcat, (:(::), :T, :Type), (:(::), :A, :AbstractArray)), (:block,
        (:line, 1316, :none),
        (:call, :cat_t, (:curly, :Val, 1), :T, :A)
      )),
    (:line, 1317, :none),
    (:(=), (:call, :typed_vcat, (:(::), :T, :Type), (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1317, :none),
        (:call, :cat_t, (:curly, :Val, 1), :T, :A, :B)
      )),
    (:line, 1318, :none),
    (:(=), (:call, :typed_vcat, (:(::), :T, :Type), (:..., (:(::), :A, :AbstractArray))), (:block,
        (:line, 1318, :none),
        (:call, :cat_t, (:curly, :Val, 1), :T, (:..., :A))
      )),
    (:line, 1319, :none),
    (:(=), (:call, :typed_hcat, (:(::), :T, :Type), (:(::), :A, :AbstractArray)), (:block,
        (:line, 1319, :none),
        (:call, :cat_t, (:curly, :Val, 2), :T, :A)
      )),
    (:line, 1320, :none),
    (:(=), (:call, :typed_hcat, (:(::), :T, :Type), (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1320, :none),
        (:call, :cat_t, (:curly, :Val, 2), :T, :A, :B)
      )),
    (:line, 1321, :none),
    (:(=), (:call, :typed_hcat, (:(::), :T, :Type), (:..., (:(::), :A, :AbstractArray))), (:block,
        (:line, 1321, :none),
        (:call, :cat_t, (:curly, :Val, 2), :T, (:..., :A))
      )),
    (:line, 1325, :none),
    (:function, (:call, :hvcat, (:(::), :nbc, :Integer), (:..., :as)), (:block,
        (:line, 1327, :none),
        (:(=), :n, (:call, :length, :as)),
        (:line, 1328, :none),
        (:&&, (:call, :(!=), (:call, :mod, :n, :nbc), 0), (:call, :throw, (:call, :ArgumentError, (:string, "number of arrays ", :n, " is not a multiple of the requested number of block columns ", :nbc)))),
        (:line, 1330, :none),
        (:(=), :nbr, (:call, :div, :n, :nbc)),
        (:line, 1331, :none),
        (:call, :hvcat, (:call, :ntuple, (:->, :i, (:block,
                (:line, 1331, :none),
                :nbc
              )), :nbr), (:..., :as))
      )),
    (:line, 1334, :none),
    (:macrocall, :(Core.@doc), "    hvcat(rows::Tuple{Vararg{Int}}, values...)\n\nHorizontal and vertical concatenation in one call. This function is called for block matrix\nsyntax. The first argument specifies the number of arguments to concatenate in each block\nrow.\n\n```jldoctest\njulia> a, b, c, d, e, f = 1, 2, 3, 4, 5, 6\n(1, 2, 3, 4, 5, 6)\n\njulia> [a b c; d e f]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> hvcat((3,3), a,b,c,d,e,f)\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> [a b;c d; e f]\n3×2 Array{Int64,2}:\n 1  2\n 3  4\n 5  6\n\njulia> hvcat((2,2,2), a,b,c,d,e,f)\n3×2 Array{Int64,2}:\n 1  2\n 3  4\n 5  6\n```\n\nIf the first argument is a single integer `n`, then all block rows are assumed to have `n`\nblock columns.\n", (:(=), (:call, :hvcat, (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., (:(::), :xs, :AbstractVecOrMat))), (:block,
          (:line, 1371, :none),
          (:call, :typed_hvcat, (:call, :promote_eltype, (:..., :xs)), :rows, (:..., :xs))
        ))),
    (:line, 1372, :none),
    (:(=), (:where, (:call, :hvcat, (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., (:(::), :xs, (:curly, :AbstractVecOrMat, :T)))), :T), (:block,
        (:line, 1372, :none),
        (:call, :typed_hvcat, :T, :rows, (:..., :xs))
      )),
    (:line, 1374, :none),
    (:function, (:where, (:call, :typed_hvcat, (:(::), (:curly, :Type, :T)), (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., (:(::), :as, :AbstractVecOrMat))), :T), (:block,
        (:line, 1375, :none),
        (:(=), :nbr, (:call, :length, :rows)),
        (:line, 1377, :none),
        (:(=), :nc, 0),
        (:line, 1378, :none),
        (:for, (:(=), :i, (:(:), 1, (:ref, :rows, 1))), (:block,
            (:line, 1379, :none),
            (:+=, :nc, (:call, :size, (:ref, :as, :i), 2))
          )),
        (:line, 1382, :none),
        (:(=), :nr, 0),
        (:line, 1383, :none),
        (:(=), :a, 1),
        (:line, 1384, :none),
        (:for, (:(=), :i, (:(:), 1, :nbr)), (:block,
            (:line, 1385, :none),
            (:+=, :nr, (:call, :size, (:ref, :as, :a), 1)),
            (:line, 1386, :none),
            (:+=, :a, (:ref, :rows, :i))
          )),
        (:line, 1389, :none),
        (:(=), :out, (:call, :similar, (:ref, :as, 1), :T, :nr, :nc)),
        (:line, 1391, :none),
        (:(=), :a, 1),
        (:line, 1392, :none),
        (:(=), :r, 1),
        (:line, 1393, :none),
        (:for, (:(=), :i, (:(:), 1, :nbr)), (:block,
            (:line, 1394, :none),
            (:(=), :c, 1),
            (:line, 1395, :none),
            (:(=), :szi, (:call, :size, (:ref, :as, :a), 1)),
            (:line, 1396, :none),
            (:for, (:(=), :j, (:(:), 1, (:ref, :rows, :i))), (:block,
                (:line, 1397, :none),
                (:(=), :Aj, (:ref, :as, (:call, :-, (:call, :+, :a, :j), 1))),
                (:line, 1398, :none),
                (:(=), :szj, (:call, :size, :Aj, 2)),
                (:line, 1399, :none),
                (:if, (:call, :(!=), (:call, :size, :Aj, 1), :szi), (:block,
                    (:line, 1400, :none),
                    (:call, :throw, (:call, :ArgumentError, (:string, "mismatched height in block row ", :i, " (expected ", :szi, ", got ", (:call, :size, :Aj, 1), ")")))
                  )),
                (:line, 1402, :none),
                (:if, (:call, :>, (:call, :+, (:call, :-, :c, 1), :szj), :nc), (:block,
                    (:line, 1403, :none),
                    (:call, :throw, (:call, :ArgumentError, (:string, "block row ", :i, " has mismatched number of columns (expected ", :nc, ", got ", (:call, :+, (:call, :-, :c, 1), :szj), ")")))
                  )),
                (:line, 1405, :none),
                (:(=), (:ref, :out, (:(:), :r, (:call, :+, (:call, :-, :r, 1), :szi)), (:(:), :c, (:call, :+, (:call, :-, :c, 1), :szj))), :Aj),
                (:line, 1406, :none),
                (:+=, :c, :szj)
              )),
            (:line, 1408, :none),
            (:if, (:call, :(!=), :c, (:call, :+, :nc, 1)), (:block,
                (:line, 1409, :none),
                (:call, :throw, (:call, :ArgumentError, (:string, "block row ", :i, " has mismatched number of columns (expected ", :nc, ", got ", (:call, :-, :c, 1), ")")))
              )),
            (:line, 1411, :none),
            (:+=, :r, :szi),
            (:line, 1412, :none),
            (:+=, :a, (:ref, :rows, :i))
          )),
        (:line, 1414, :none),
        :out
      )),
    (:line, 1417, :none),
    (:(=), (:call, :hvcat, (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int)))), (:block,
        (:line, 1417, :none),
        (:vect,)
      )),
    (:line, 1418, :none),
    (:(=), (:where, (:call, :typed_hvcat, (:(::), (:curly, :Type, :T)), (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int)))), :T), (:block,
        (:line, 1418, :none),
        (:call, (:curly, :Array, :T, 1), 0)
      )),
    (:line, 1420, :none),
    (:function, (:where, (:call, :hvcat, (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., (:(::), :xs, :T))), (:<:, :T, :Number)), (:block,
        (:line, 1421, :none),
        (:(=), :nr, (:call, :length, :rows)),
        (:line, 1422, :none),
        (:(=), :nc, (:ref, :rows, 1)),
        (:line, 1424, :none),
        (:(=), :a, (:call, (:curly, :Array, :T, 2), :nr, :nc)),
        (:line, 1425, :none),
        (:if, (:call, :(!=), (:call, :length, :a), (:call, :length, :xs)), (:block,
            (:line, 1426, :none),
            (:call, :throw, (:call, :ArgumentError, (:string, "argument count does not match specified shape (expected ", (:call, :length, :a), ", got ", (:call, :length, :xs), ")")))
          )),
        (:line, 1428, :none),
        (:(=), :k, 1),
        (:line, 1429, :none),
        (:macrocall, Symbol("@inbounds"), (:for, (:(=), :i, (:(:), 1, :nr)), (:block,
              (:line, 1430, :none),
              (:if, (:call, :(!=), :nc, (:ref, :rows, :i)), (:block,
                  (:line, 1431, :none),
                  (:call, :throw, (:call, :ArgumentError, (:string, "row ", :i, " has mismatched number of columns (expected ", :nc, ", got ", (:ref, :rows, :i), ")")))
                )),
              (:line, 1433, :none),
              (:for, (:(=), :j, (:(:), 1, :nc)), (:block,
                  (:line, 1434, :none),
                  (:(=), (:ref, :a, :i, :j), (:ref, :xs, :k)),
                  (:line, 1435, :none),
                  (:+=, :k, 1)
                ))
            ))),
        (:line, 1438, :none),
        :a
      )),
    (:line, 1441, :none),
    (:function, (:call, :hvcat_fill, (:(::), :a, :Array), (:(::), :xs, :Tuple)), (:block,
        (:line, 1442, :none),
        (:(=), :k, 1),
        (:line, 1443, :none),
        (:(=), (:tuple, :nr, :nc), (:tuple, (:call, :size, :a, 1), (:call, :size, :a, 2))),
        (:line, 1444, :none),
        (:for, (:(=), :i, (:(:), 1, :nr)), (:block,
            (:line, 1445, :none),
            (:macrocall, Symbol("@inbounds"), (:for, (:(=), :j, (:(:), 1, :nc)), (:block,
                  (:line, 1446, :none),
                  (:(=), (:ref, :a, :i, :j), (:ref, :xs, :k)),
                  (:line, 1447, :none),
                  (:+=, :k, 1)
                )))
          )),
        (:line, 1450, :none),
        :a
      )),
    (:line, 1453, :none),
    (:(=), (:call, :hvcat, (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., (:(::), :xs, :Number))), (:block,
        (:line, 1453, :none),
        (:call, :typed_hvcat, (:call, :promote_typeof, (:..., :xs)), :rows, (:..., :xs))
      )),
    (:line, 1455, :none),
    (:function, (:where, (:call, :typed_hvcat, (:(::), (:curly, :Type, :T)), (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., (:(::), :xs, :Number))), :T), (:block,
        (:line, 1456, :none),
        (:(=), :nr, (:call, :length, :rows)),
        (:line, 1457, :none),
        (:(=), :nc, (:ref, :rows, 1)),
        (:line, 1458, :none),
        (:for, (:(=), :i, (:(:), 2, :nr)), (:block,
            (:line, 1459, :none),
            (:if, (:call, :(!=), :nc, (:ref, :rows, :i)), (:block,
                (:line, 1460, :none),
                (:call, :throw, (:call, :ArgumentError, (:string, "row ", :i, " has mismatched number of columns (expected ", :nc, ", got ", (:ref, :rows, :i), ")")))
              ))
          )),
        (:line, 1463, :none),
        (:(=), :len, (:call, :length, :xs)),
        (:line, 1464, :none),
        (:if, (:call, :(!=), (:call, :*, :nr, :nc), :len), (:block,
            (:line, 1465, :none),
            (:call, :throw, (:call, :ArgumentError, (:string, "argument count ", :len, " does not match specified shape ", (:tuple, :nr, :nc))))
          )),
        (:line, 1467, :none),
        (:call, :hvcat_fill, (:call, (:curly, :Array, :T, 2), :nr, :nc), :xs)
      )),
    (:line, 1471, :none),
    (:function, (:call, :hvcat, (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., :as)), (:block,
        (:line, 1472, :none),
        (:(=), :nbr, (:call, :length, :rows)),
        (:line, 1473, :none),
        (:(=), :rs, (:call, (:curly, :Array, :Any, 1), :nbr)),
        (:line, 1474, :none),
        (:(=), :a, 1),
        (:line, 1475, :none),
        (:for, (:(=), :i, (:(:), 1, :nbr)), (:block,
            (:line, 1476, :none),
            (:(=), (:ref, :rs, :i), (:call, :hcat, (:..., (:ref, :as, (:(:), :a, (:call, :+, (:call, :-, :a, 1), (:ref, :rows, :i))))))),
            (:line, 1477, :none),
            (:+=, :a, (:ref, :rows, :i))
          )),
        (:line, 1479, :none),
        (:call, :vcat, (:..., :rs))
      )),
    (:line, 1482, :none),
    (:function, (:where, (:call, :typed_hvcat, (:(::), (:curly, :Type, :T)), (:(::), :rows, (:curly, :Tuple, (:curly, :Vararg, :Int))), (:..., :as)), :T), (:block,
        (:line, 1483, :none),
        (:(=), :nbr, (:call, :length, :rows)),
        (:line, 1484, :none),
        (:(=), :rs, (:call, (:curly, :Array, :Any, 1), :nbr)),
        (:line, 1485, :none),
        (:(=), :a, 1),
        (:line, 1486, :none),
        (:for, (:(=), :i, (:(:), 1, :nbr)), (:block,
            (:line, 1487, :none),
            (:(=), (:ref, :rs, :i), (:call, :typed_hcat, :T, (:..., (:ref, :as, (:(:), :a, (:call, :+, (:call, :-, :a, 1), (:ref, :rows, :i))))))),
            (:line, 1488, :none),
            (:+=, :a, (:ref, :rows, :i))
          )),
        (:line, 1490, :none),
        (:typed_vcat, :T, (:..., :rs))
      )),
    (:line, 1495, :none),
    (:function, (:call, :isequal, (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1496, :none),
        (:if, (:call, :(===), :A, :B), (:block,
            (:line, 1496, :none),
            (:return, true)
          )),
        (:line, 1497, :none),
        (:if, (:call, :(!=), (:call, :indices, :A), (:call, :indices, :B)), (:block,
            (:line, 1498, :none),
            (:return, false)
          )),
        (:line, 1500, :none),
        (:if, (:call, :(!=), (:call, :isa, :A, :Range), (:call, :isa, :B, :Range)), (:block,
            (:line, 1501, :none),
            (:return, false)
          )),
        (:line, 1503, :none),
        (:for, (:(=), (:tuple, :a, :b), (:call, :zip, :A, :B)), (:block,
            (:line, 1504, :none),
            (:if, (:call, :!, (:call, :isequal, :a, :b)), (:block,
                (:line, 1505, :none),
                (:return, false)
              ))
          )),
        (:line, 1508, :none),
        (:return, true)
      )),
    (:line, 1511, :none),
    (:function, (:call, :lexcmp, (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1512, :none),
        (:for, (:(=), (:tuple, :a, :b), (:call, :zip, :A, :B)), (:block,
            (:line, 1513, :none),
            (:(=), :res, (:call, :lexcmp, :a, :b)),
            (:line, 1514, :none),
            (:||, (:call, :(==), :res, 0), (:return, :res))
          )),
        (:line, 1516, :none),
        (:return, (:call, :cmp, (:call, :length, :A), (:call, :length, :B)))
      )),
    (:line, 1519, :none),
    (:function, (:call, :(==), (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), (:block,
        (:line, 1520, :none),
        (:if, (:call, :(!=), (:call, :indices, :A), (:call, :indices, :B)), (:block,
            (:line, 1521, :none),
            (:return, false)
          )),
        (:line, 1523, :none),
        (:if, (:call, :(!=), (:call, :isa, :A, :Range), (:call, :isa, :B, :Range)), (:block,
            (:line, 1524, :none),
            (:return, false)
          )),
        (:line, 1526, :none),
        (:for, (:(=), (:tuple, :a, :b), (:call, :zip, :A, :B)), (:block,
            (:line, 1527, :none),
            (:if, (:call, :!, (:call, :(==), :a, :b)), (:block,
                (:line, 1528, :none),
                (:return, false)
              ))
          )),
        (:line, 1531, :none),
        (:return, true)
      )),
    (:line, 1536, :none),
    (:function, (:call, :sub2ind, (:(::), :A, :AbstractArray), (:..., :I)), (:block,
        (:line, 1537, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 1538, :none),
        (:call, :sub2ind, (:call, :indices, :A), (:..., :I))
      )),
    (:line, 1541, :none),
    (:macrocall, :(Core.@doc), "    ind2sub(a, index) -> subscripts\n\nReturns a tuple of subscripts into array `a` corresponding to the linear index `index`.\n\n```jldoctest\njulia> A = ones(5,6,7);\n\njulia> ind2sub(A,35)\n(5, 1, 2)\n\njulia> ind2sub(A,70)\n(5, 2, 3)\n```\n", (:function, (:call, :ind2sub, (:(::), :A, :AbstractArray), :ind), (:block,
          (:line, 1557, :none),
          (:macrocall, Symbol("@_inline_meta")),
          (:line, 1558, :none),
          (:call, :ind2sub, (:call, :indices, :A), :ind)
        ))),
    (:line, 1562, :none),
    (:(=), (:call, :sub2ind, (:(::), (:curly, :Tuple))), (:block,
        (:line, 1562, :none),
        1
      )),
    (:line, 1563, :none),
    (:(=), (:call, :sub2ind, (:(::), :DimsInteger)), (:block,
        (:line, 1563, :none),
        1
      )),
    (:line, 1564, :none),
    (:(=), (:call, :sub2ind, (:(::), :Indices)), (:block,
        (:line, 1564, :none),
        1
      )),
    (:line, 1565, :none),
    (:(=), (:call, :sub2ind, (:(::), (:curly, :Tuple)), (:..., (:(::), :I, :Integer))), (:block,
        (:line, 1565, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_sub2ind, (:tuple,), 1, 1, (:..., :I))
        )
      )),
    (:line, 1568, :none),
    (:macrocall, :(Core.@doc), "    sub2ind(dims, i, j, k...) -> index\n\nThe inverse of [`ind2sub`](@ref), returns the linear index corresponding to the provided subscripts.\n\n```jldoctest\njulia> sub2ind((5,6,7),1,2,3)\n66\n\njulia> sub2ind((5,6,7),1,6,3)\n86\n```\n", (:(=), (:call, :sub2ind, (:(::), :dims, :DimsInteger), (:..., (:(::), :I, :Integer))), (:block,
          (:line, 1581, :none),
          (:block,
            (:macrocall, Symbol("@_inline_meta")),
            (:call, :_sub2ind, :dims, 1, 1, (:..., :I))
          )
        ))),
    (:line, 1582, :none),
    (:(=), (:call, :sub2ind, (:(::), :inds, :Indices), (:..., (:(::), :I, :Integer))), (:block,
        (:line, 1582, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_sub2ind, :inds, 1, 1, (:..., :I))
        )
      )),
    (:line, 1585, :none),
    (:(=), (:call, :sub2ind, (:(::), :inds, (:curly, :Indices, 1)), (:..., (:(::), :I, :Integer))), (:block,
        (:line, 1585, :none),
        (:call, :throw, (:call, :ArgumentError, "Linear indexing is not defined for one-dimensional arrays"))
      )),
    (:line, 1587, :none),
    (:(=), (:call, :sub2ind, (:(::), :inds, (:curly, :Tuple, :OneTo)), (:..., (:(::), :I, :Integer))), (:block,
        (:line, 1587, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_sub2ind, :inds, 1, 1, (:..., :I))
        )
      )),
    (:line, 1588, :none),
    (:(=), (:call, :sub2ind, (:(::), :inds, (:curly, :Tuple, :OneTo)), (:(::), :i, :Integer)), (:block,
        (:line, 1588, :none),
        :i
      )),
    (:line, 1590, :none),
    (:(=), (:call, :_sub2ind, (:(::), :Any), :L, :ind), (:block,
        (:line, 1590, :none),
        :ind
      )),
    (:line, 1591, :none),
    (:function, (:call, :_sub2ind, (:(::), (:curly, :Tuple)), :L, :ind, (:(::), :i, :Integer), (:..., (:(::), :I, :Integer))), (:block,
        (:line, 1592, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 1593, :none),
        (:call, :_sub2ind, (:tuple,), :L, (:call, :+, :ind, (:call, :*, (:call, :-, :i, 1), :L)), (:..., :I))
      )),
    (:line, 1595, :none),
    (:function, (:call, :_sub2ind, :inds, :L, :ind, (:(::), :i, :Integer), (:..., (:(::), :I, :Integer))), (:block,
        (:line, 1596, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 1597, :none),
        (:(=), :r1, (:ref, :inds, 1)),
        (:line, 1598, :none),
        (:call, :_sub2ind, (:call, :tail, :inds), (:call, :nextL, :L, :r1), (:call, :+, :ind, (:call, :*, (:call, :offsetin, :i, :r1), :L)), (:..., :I))
      )),
    (:line, 1601, :none),
    (:(=), (:call, :nextL, :L, (:(::), :l, :Integer)), (:block,
        (:line, 1601, :none),
        (:call, :*, :L, :l)
      )),
    (:line, 1602, :none),
    (:(=), (:call, :nextL, :L, (:(::), :r, :AbstractUnitRange)), (:block,
        (:line, 1602, :none),
        (:call, :*, :L, (:call, :unsafe_length, :r))
      )),
    (:line, 1603, :none),
    (:(=), (:call, :offsetin, :i, (:(::), :l, :Integer)), (:block,
        (:line, 1603, :none),
        (:call, :-, :i, 1)
      )),
    (:line, 1604, :none),
    (:(=), (:call, :offsetin, :i, (:(::), :r, :AbstractUnitRange)), (:block,
        (:line, 1604, :none),
        (:call, :-, :i, (:call, :first, :r))
      )),
    (:line, 1606, :none),
    (:(=), (:call, :ind2sub, (:(::), (:curly, :Tuple)), (:(::), :ind, :Integer)), (:block,
        (:line, 1606, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:if, (:call, :(==), :ind, 1), (:tuple,), (:call, :throw, (:call, :BoundsError)))
        )
      )),
    (:line, 1608, :none),
    (:macrocall, :(Core.@doc), "    ind2sub(dims, index) -> subscripts\n\nReturns a tuple of subscripts into an array with dimensions `dims`,\ncorresponding to the linear index `index`.\n\n**Example**:\n\n```\ni, j, ... = ind2sub(size(A), indmax(A))\n```\n\nprovides the indices of the maximum element.\n\n```jldoctest\njulia> ind2sub((3,4),2)\n(2, 1)\n\njulia> ind2sub((3,4),3)\n(3, 1)\n\njulia> ind2sub((3,4),4)\n(1, 2)\n```\n", (:(=), (:call, :ind2sub, (:(::), :dims, :DimsInteger), (:(::), :ind, :Integer)), (:block,
          (:line, 1633, :none),
          (:block,
            (:macrocall, Symbol("@_inline_meta")),
            (:call, :_ind2sub, :dims, (:call, :-, :ind, 1))
          )
        ))),
    (:line, 1634, :none),
    (:(=), (:call, :ind2sub, (:(::), :inds, :Indices), (:(::), :ind, :Integer)), (:block,
        (:line, 1634, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_ind2sub, :inds, (:call, :-, :ind, 1))
        )
      )),
    (:line, 1635, :none),
    (:(=), (:call, :ind2sub, (:(::), :inds, (:curly, :Indices, 1)), (:(::), :ind, :Integer)), (:block,
        (:line, 1635, :none),
        (:call, :throw, (:call, :ArgumentError, "Linear indexing is not defined for one-dimensional arrays"))
      )),
    (:line, 1637, :none),
    (:(=), (:call, :ind2sub, (:(::), :inds, (:curly, :Tuple, :OneTo)), (:(::), :ind, :Integer)), (:block,
        (:line, 1637, :none),
        (:tuple, :ind)
      )),
    (:line, 1639, :none),
    (:(=), (:call, :_ind2sub, (:(::), (:curly, :Tuple)), :ind), (:block,
        (:line, 1639, :none),
        (:tuple, (:call, :+, :ind, 1))
      )),
    (:line, 1640, :none),
    (:function, (:call, :_ind2sub, (:(::), :indslast, (:curly, :NTuple, 1)), :ind), (:block,
        (:line, 1641, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 1642, :none),
        (:tuple, (:call, :_lookup, :ind, (:ref, :indslast, 1)))
      )),
    (:line, 1644, :none),
    (:function, (:call, :_ind2sub, :inds, :ind), (:block,
        (:line, 1645, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 1646, :none),
        (:(=), :r1, (:ref, :inds, 1)),
        (:line, 1647, :none),
        (:(=), (:tuple, :indnext, :f, :l), (:call, :_div, :ind, :r1)),
        (:line, 1648, :none),
        (:tuple, (:call, :+, (:call, :-, :ind, (:call, :*, :l, :indnext)), :f), (:..., (:call, :_ind2sub, (:call, :tail, :inds), :indnext)))
      )),
    (:line, 1651, :none),
    (:(=), (:call, :_lookup, :ind, (:(::), :d, :Integer)), (:block,
        (:line, 1651, :none),
        (:call, :+, :ind, 1)
      )),
    (:line, 1652, :none),
    (:(=), (:call, :_lookup, :ind, (:(::), :r, :AbstractUnitRange)), (:block,
        (:line, 1652, :none),
        (:call, :+, :ind, (:call, :first, :r))
      )),
    (:line, 1653, :none),
    (:(=), (:call, :_div, :ind, (:(::), :d, :Integer)), (:block,
        (:line, 1653, :none),
        (:tuple, (:call, :div, :ind, :d), 1, :d)
      )),
    (:line, 1654, :none),
    (:(=), (:call, :_div, :ind, (:(::), :r, :AbstractUnitRange)), (:block,
        (:line, 1654, :none),
        (:block,
          (:(=), :d, (:call, :unsafe_length, :r)),
          (:tuple, (:call, :div, :ind, :d), (:call, :first, :r), :d)
        )
      )),
    (:line, 1657, :none),
    (:function, (:where, (:call, :sub2ind, (:(::), :inds, (:curly, :Indices, 1)), (:(::), :I1, (:curly, :AbstractVector, :T)), (:..., (:(::), :I, (:curly, :AbstractVector, :T)))), (:<:, :T, :Integer)), (:block,
        (:line, 1658, :none),
        (:call, :throw, (:call, :ArgumentError, "Linear indexing is not defined for one-dimensional arrays"))
      )),
    (:line, 1660, :none),
    (:(=), (:where, (:call, :sub2ind, (:(::), :inds, (:curly, :Tuple, :OneTo)), (:(::), :I1, (:curly, :AbstractVector, :T)), (:..., (:(::), :I, (:curly, :AbstractVector, :T)))), (:<:, :T, :Integer)), (:block,
        (:line, 1660, :none),
        (:call, :_sub2ind_vecs, :inds, :I1, (:..., :I))
      )),
    (:line, 1662, :none),
    (:(=), (:where, (:call, :sub2ind, (:(::), :inds, (:curly, :Union, :DimsInteger, :Indices)), (:(::), :I1, (:curly, :AbstractVector, :T)), (:..., (:(::), :I, (:curly, :AbstractVector, :T)))), (:<:, :T, :Integer)), (:block,
        (:line, 1662, :none),
        (:call, :_sub2ind_vecs, :inds, :I1, (:..., :I))
      )),
    (:line, 1664, :none),
    (:function, (:call, :_sub2ind_vecs, :inds, (:..., (:(::), :I, :AbstractVector))), (:block,
        (:line, 1665, :none),
        (:(=), :I1, (:ref, :I, 1)),
        (:line, 1666, :none),
        (:(=), :Iinds, (:call, :indices1, :I1)),
        (:line, 1667, :none),
        (:for, (:(=), :j, (:(:), 2, (:call, :length, :I))), (:block,
            (:line, 1668, :none),
            (:||, (:call, :(==), (:call, :indices1, (:ref, :I, :j)), :Iinds), (:call, :throw, (:call, :DimensionMismatch, (:string, "indices of I[1] (", :Iinds, ") does not match indices of I[", :j, "] (", (:call, :indices1, (:ref, :I, :j)), ")"))))
          )),
        (:line, 1670, :none),
        (:(=), :Iout, (:call, :similar, :I1)),
        (:line, 1671, :none),
        (:call, :_sub2ind!, :Iout, :inds, :Iinds, :I),
        (:line, 1672, :none),
        :Iout
      )),
    (:line, 1675, :none),
    (:function, (:call, :_sub2ind!, :Iout, :inds, :Iinds, :I), (:block,
        (:line, 1676, :none),
        (:macrocall, Symbol("@_noinline_meta")),
        (:line, 1677, :none),
        (:for, (:(=), :i, :Iinds), (:block,
            (:line, 1679, :none),
            (:(=), (:ref, :Iout, :i), (:call, :sub2ind_vec, :inds, :i, :I))
          )),
        (:line, 1681, :none),
        :Iout
      )),
    (:line, 1684, :none),
    (:(=), (:call, :sub2ind_vec, :inds, :i, :I), (:block,
        (:line, 1684, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_sub2ind_vec, :inds, (:tuple,), :i, (:..., :I))
        )
      )),
    (:line, 1685, :none),
    (:(=), (:call, :_sub2ind_vec, :inds, :out, :i, :I1, (:..., :I)), (:block,
        (:line, 1685, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_sub2ind_vec, :inds, (:tuple, (:..., :out), (:ref, :I1, :i)), :i, (:..., :I))
        )
      )),
    (:line, 1686, :none),
    (:(=), (:call, :_sub2ind_vec, :inds, :out, :i), (:block,
        (:line, 1686, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :sub2ind, :inds, (:..., :out))
        )
      )),
    (:line, 1688, :none),
    (:function, (:where, (:call, :ind2sub, (:(::), :inds, (:curly, :Union, (:curly, :DimsInteger, :N), (:curly, :Indices, :N))), (:(::), :ind, (:curly, :AbstractVector, (:<:, :Integer)))), :N), (:block,
        (:line, 1689, :none),
        (:(=), :M, (:call, :length, :ind)),
        (:line, 1690, :none),
        (:(=), :t, (:call, :ntuple, (:->, :n, (:block,
                (:line, 1690, :none),
                (:call, :similar, :ind)
              )), (:curly, :Val, :N))),
        (:line, 1691, :none),
        (:for, (:(=), (:tuple, :i, :idx), (:call, :enumerate, (:call, :IndexLinear), :ind)), (:block,
            (:line, 1692, :none),
            (:(=), :sub, (:call, :ind2sub, :inds, :idx)),
            (:line, 1693, :none),
            (:for, (:(=), :j, (:(:), 1, :N)), (:block,
                (:line, 1694, :none),
                (:(=), (:ref, (:ref, :t, :j), :i), (:ref, :sub, :j))
              ))
          )),
        (:line, 1697, :none),
        :t
      )),
    (:line, 1700, :none),
    (:function, (:where, (:call, :ind2sub!, (:(::), :sub, (:curly, :Array, :T)), (:(::), :dims, (:curly, :Tuple, (:curly, :Vararg, :T))), (:(::), :ind, :T)), (:<:, :T, :Integer)), (:block,
        (:line, 1701, :none),
        (:(=), :ndims, (:call, :length, :dims)),
        (:line, 1702, :none),
        (:for, (:(=), :i, (:(:), 1, (:call, :-, :ndims, 1))), (:block,
            (:line, 1703, :none),
            (:(=), :ind2, (:call, :+, (:call, :div, (:call, :-, :ind, 1), (:ref, :dims, :i)), 1)),
            (:line, 1704, :none),
            (:(=), (:ref, :sub, :i), (:call, :-, :ind, (:call, :*, (:ref, :dims, :i), (:call, :-, :ind2, 1)))),
            (:line, 1705, :none),
            (:(=), :ind, :ind2)
          )),
        (:line, 1707, :none),
        (:(=), (:ref, :sub, :ndims), :ind),
        (:line, 1708, :none),
        (:return, :sub)
      )),
    (:line, 1713, :none),
    (:macrocall, :(Core.@doc), "    foreach(f, c...) -> Void\n\nCall function `f` on each element of iterable `c`.\nFor multiple iterable arguments, `f` is called elementwise.\n`foreach` should be used instead of `map` when the results of `f` are not\nneeded, for example in `foreach(println, array)`.\n\n```jldoctest\njulia> a = 1:3:7;\n\njulia> foreach(x -> println(x^2), a)\n1\n16\n49\n```\n", (:(=), (:call, :foreach, :f), (:block,
          (:line, 1730, :none),
          (:block,
            (:call, :f),
            :nothing
          )
        ))),
    (:line, 1731, :none),
    (:(=), (:call, :foreach, :f, :itr), (:block,
        (:line, 1731, :none),
        (:block,
          (:for, (:(=), :x, :itr), (:block,
              (:line, 1731, :none),
              (:call, :f, :x)
            )),
          :nothing
        )
      )),
    (:line, 1732, :none),
    (:(=), (:call, :foreach, :f, (:..., :itrs)), (:block,
        (:line, 1732, :none),
        (:block,
          (:for, (:(=), :z, (:call, :zip, (:..., :itrs))), (:block,
              (:line, 1732, :none),
              (:call, :f, (:..., :z))
            )),
          :nothing
        )
      )),
    (:line, 1739, :none),
    (:macrocall, :(Core.@doc), "    mapslices(f, A, dims)\n\nTransform the given dimensions of array `A` using function `f`. `f` is called on each slice\nof `A` of the form `A[...,:,...,:,...]`. `dims` is an integer vector specifying where the\ncolons go in this expression. The results are concatenated along the remaining dimensions.\nFor example, if `dims` is `[1,2]` and `A` is 4-dimensional, `f` is called on `A[:,:,i,j]`\nfor all `i` and `j`.\n\n```jldoctest\njulia> a = reshape(collect(1:16),(2,2,2,2))\n2×2×2×2 Array{Int64,4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\n[:, :, 2, 1] =\n 5  7\n 6  8\n\n[:, :, 1, 2] =\n  9  11\n 10  12\n\n[:, :, 2, 2] =\n 13  15\n 14  16\n\njulia> mapslices(sum, a, [1,2])\n1×1×2×2 Array{Int64,4}:\n[:, :, 1, 1] =\n 10\n\n[:, :, 2, 1] =\n 26\n\n[:, :, 1, 2] =\n 42\n\n[:, :, 2, 2] =\n 58\n```\n", (:(=), (:call, :mapslices, :f, (:(::), :A, :AbstractArray), :dims), (:block,
          (:line, 1782, :none),
          (:call, :mapslices, :f, :A, (:vect, (:..., :dims)))
        ))),
    (:line, 1783, :none),
    (:function, (:call, :mapslices, :f, (:(::), :A, :AbstractArray), (:(::), :dims, :AbstractVector)), (:block,
        (:line, 1784, :none),
        (:if, (:call, :isempty, :dims), (:block,
            (:line, 1785, :none),
            (:return, (:call, :map, :f, :A))
          )),
        (:line, 1788, :none),
        (:(=), :dimsA, (:vect, (:..., (:call, :indices, :A)))),
        (:line, 1789, :none),
        (:(=), :ndimsA, (:call, :ndims, :A)),
        (:line, 1790, :none),
        (:(=), :alldims, (:vcat, (:(:), 1, :ndimsA))),
        (:line, 1792, :none),
        (:(=), :otherdims, (:call, :setdiff, :alldims, :dims)),
        (:line, 1794, :none),
        (:(=), :idx, (:typed_comprehension, :Any, (:generator, (:call, :first, :ind), (:(=), :ind, (:call, :indices, :A))))),
        (:line, 1795, :none),
        (:(=), :itershape, (:call, :tuple, (:..., (:ref, :dimsA, :otherdims)))),
        (:line, 1796, :none),
        (:for, (:(=), :d, :dims), (:block,
            (:line, 1797, :none),
            (:(=), (:ref, :idx, :d), (:call, :Slice, (:call, :indices, :A, :d)))
          )),
        (:line, 1801, :none),
        (:(=), :Aslice, (:ref, :A, (:..., :idx))),
        (:line, 1802, :none),
        (:(=), :r1, (:call, :f, :Aslice)),
        (:line, 1807, :none),
        (:(=), :safe_for_reuse, (:&&, (:call, :isa, :Aslice, :StridedArray), (:||, (:call, :isa, :r1, :Number), (:&&, (:call, :isa, :r1, :AbstractArray), (:<:, (:call, :eltype, :r1), :Number))))),
        (:line, 1811, :none),
        (:(=), :Rsize, (:call, :copy, :dimsA)),
        (:line, 1813, :none),
        (:if, (:||, (:call, :!, (:call, :isa, :r1, :AbstractArray)), (:call, :(==), (:call, :ndims, :r1), 0)), (:block,
            (:line, 1814, :none),
            (:(=), :r1, (:vect, :r1))
          )),
        (:line, 1816, :none),
        (:(=), :nextra, (:call, :max, 0, (:call, :-, (:call, :length, :dims), (:call, :ndims, :r1)))),
        (:line, 1817, :none),
        (:if, (:call, :(==), (:call, :eltype, :Rsize), :Int), (:block,
            (:line, 1818, :none),
            (:(=), (:ref, :Rsize, :dims), (:vect, (:..., (:call, :size, :r1)), (:..., (:call, :ntuple, (:->, :d, (:block,
                        (:line, 1818, :none),
                        1
                      )), :nextra))))
          ), (:block,
            (:line, 1820, :none),
            (:(=), (:ref, :Rsize, :dims), (:vect, (:..., (:call, :indices, :r1)), (:..., (:call, :ntuple, (:->, :d, (:block,
                        (:line, 1820, :none),
                        (:call, :OneTo, 1)
                      )), :nextra))))
          )),
        (:line, 1822, :none),
        (:(=), :R, (:call, :similar, :r1, (:call, :tuple, (:..., :Rsize)))),
        (:line, 1824, :none),
        (:(=), :ridx, (:ref, :Any, (:..., (:call, :map, :first, (:call, :indices, :R))))),
        (:line, 1825, :none),
        (:for, (:(=), :d, :dims), (:block,
            (:line, 1826, :none),
            (:(=), (:ref, :ridx, :d), (:call, :indices, :R, :d))
          )),
        (:line, 1829, :none),
        (:(=), (:ref, :R, (:..., :ridx)), :r1),
        (:line, 1831, :none),
        (:(=), :nidx, (:call, :length, :otherdims)),
        (:line, 1832, :none),
        (:if, :safe_for_reuse, (:block,
            (:line, 1835, :none),
            (:for, (:(=), :I, (:call, (:., :Iterators, (:quote, #QuoteNode
                      :drop
                    )), (:call, :CartesianRange, :itershape), 1)), (:block,
                (:line, 1836, :none),
                (:for, (:(=), :i, (:(:), 1, :nidx)), (:block,
                    (:line, 1837, :none),
                    (:(=), (:ref, :idx, (:ref, :otherdims, :i)), (:(=), (:ref, :ridx, (:ref, :otherdims, :i)), (:ref, (:., :I, (:quote, #QuoteNode
                              :I
                            )), :i)))
                  )),
                (:line, 1839, :none),
                (:call, :_unsafe_getindex!, :Aslice, :A, (:..., :idx)),
                (:line, 1840, :none),
                (:(=), (:ref, :R, (:..., :ridx)), (:call, :f, :Aslice))
              ))
          ), (:block,
            (:line, 1844, :none),
            (:for, (:(=), :I, (:call, (:., :Iterators, (:quote, #QuoteNode
                      :drop
                    )), (:call, :CartesianRange, :itershape), 1)), (:block,
                (:line, 1845, :none),
                (:for, (:(=), :i, (:(:), 1, :nidx)), (:block,
                    (:line, 1846, :none),
                    (:(=), (:ref, :idx, (:ref, :otherdims, :i)), (:(=), (:ref, :ridx, (:ref, :otherdims, :i)), (:ref, (:., :I, (:quote, #QuoteNode
                              :I
                            )), :i)))
                  )),
                (:line, 1848, :none),
                (:(=), (:ref, :R, (:..., :ridx)), (:call, :f, (:ref, :A, (:..., :idx))))
              ))
          )),
        (:line, 1852, :none),
        (:return, :R)
      )),
    (:line, 1857, :none),
    (:function, (:where, (:call, :map!, (:(::), :f, :F), (:(::), :dest, :AbstractArray), (:(::), :A, :AbstractArray)), :F), (:block,
        (:line, 1858, :none),
        (:for, (:(=), (:tuple, :i, :j), (:call, :zip, (:call, :eachindex, :dest), (:call, :eachindex, :A))), (:block,
            (:line, 1859, :none),
            (:(=), (:ref, :dest, :i), (:call, :f, (:ref, :A, :j)))
          )),
        (:line, 1861, :none),
        (:return, :dest)
      )),
    (:line, 1865, :none),
    (:(=), (:call, :map, :f, (:(::), :A, (:curly, :Union, :AbstractArray, :AbstractSet, :Associative))), (:block,
        (:line, 1865, :none),
        (:call, :collect_similar, :A, (:call, :Generator, :f, :A))
      )),
    (:line, 1868, :none),
    (:macrocall, :(Core.@doc), "    map(f, c...) -> collection\n\nTransform collection `c` by applying `f` to each element. For multiple collection arguments,\napply `f` elementwise.\n\n```jldoctest\njulia> map(x -> x * 2, [1, 2, 3])\n3-element Array{Int64,1}:\n 2\n 4\n 6\n\njulia> map(+, [1, 2, 3], [10, 20, 30])\n3-element Array{Int64,1}:\n 11\n 22\n 33\n```\n", (:(=), (:call, :map, :f, :A), (:block,
          (:line, 1888, :none),
          (:call, :collect, (:call, :Generator, :f, :A))
        ))),
    (:line, 1891, :none),
    (:function, (:where, (:call, :map!, (:(::), :f, :F), (:(::), :dest, :AbstractArray), (:(::), :A, :AbstractArray), (:(::), :B, :AbstractArray)), :F), (:block,
        (:line, 1892, :none),
        (:for, (:(=), (:tuple, :i, :j, :k), (:call, :zip, (:call, :eachindex, :dest), (:call, :eachindex, :A), (:call, :eachindex, :B))), (:block,
            (:line, 1893, :none),
            (:(=), (:ref, :dest, :i), (:call, :f, (:ref, :A, :j), (:ref, :B, :k)))
          )),
        (:line, 1895, :none),
        (:return, :dest)
      )),
    (:line, 1900, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :ith_all, :i, (:(::), (:curly, :Tuple))), (:block,
          (:line, 1900, :none),
          (:tuple,)
        ))),
    (:line, 1901, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :ith_all, :i, :as), (:block,
          (:line, 1901, :none),
          (:tuple, (:ref, (:ref, :as, 1), :i), (:..., (:call, :ith_all, :i, (:call, :tail, :as))))
        ))),
    (:line, 1903, :none),
    (:function, (:where, (:call, :map_n!, (:(::), :f, :F), (:(::), :dest, :AbstractArray), :As), :F), (:block,
        (:line, 1904, :none),
        (:for, (:(=), :i, (:call, :linearindices, (:ref, :As, 1))), (:block,
            (:line, 1905, :none),
            (:(=), (:ref, :dest, :i), (:call, :f, (:..., (:call, :ith_all, :i, :As))))
          )),
        (:line, 1907, :none),
        (:return, :dest)
      )),
    (:line, 1910, :none),
    (:macrocall, :(Core.@doc), "    map!(function, destination, collection...)\n\nLike [`map`](@ref), but stores the result in `destination` rather than a new\ncollection. `destination` must be at least as large as the first collection.\n\n```jldoctest\njulia> x = zeros(3);\n\njulia> map!(x -> x * 2, x, [1, 2, 3]);\n\njulia> x\n3-element Array{Float64,1}:\n 2.0\n 4.0\n 6.0\n```\n", (:(=), (:where, (:call, :map!, (:(::), :f, :F), (:(::), :dest, :AbstractArray), (:..., (:(::), :As, :AbstractArray))), :F), (:block,
          (:line, 1928, :none),
          (:call, :map_n!, :f, :dest, :As)
        ))),
    (:line, 1930, :none),
    (:(=), (:call, :map, :f), (:block,
        (:line, 1930, :none),
        (:call, :f)
      )),
    (:line, 1931, :none),
    (:(=), (:call, :map, :f, (:..., :iters)), (:block,
        (:line, 1931, :none),
        (:call, :collect, (:call, :Generator, :f, (:..., :iters)))
      )),
    (:line, 1935, :none),
    (:(=), (:call, :push!, :A, :a, :b), (:block,
        (:line, 1935, :none),
        (:call, :push!, (:call, :push!, :A, :a), :b)
      )),
    (:line, 1936, :none),
    (:(=), (:call, :push!, :A, :a, :b, (:..., :c)), (:block,
        (:line, 1936, :none),
        (:call, :push!, (:call, :push!, :A, :a, :b), (:..., :c))
      )),
    (:line, 1937, :none),
    (:(=), (:call, :unshift!, :A, :a, :b), (:block,
        (:line, 1937, :none),
        (:call, :unshift!, (:call, :unshift!, :A, :b), :a)
      )),
    (:line, 1938, :none),
    (:(=), (:call, :unshift!, :A, :a, :b, (:..., :c)), (:block,
        (:line, 1938, :none),
        (:call, :unshift!, (:call, :unshift!, :A, (:..., :c)), :a, :b)
      )),
    (:line, 1942, :none),
    (:const, (:(=), :hashaa_seed, (:if, (:call, :(===), :UInt, :UInt64), 0x7f53e68ceb575e76, 0xeb575e76))),
    (:line, 1943, :none),
    (:const, (:(=), :hashrle_seed, (:if, (:call, :(===), :UInt, :UInt64), 0x2aab8909bfea414c, 0xbfea414c))),
    (:line, 1944, :none),
    (:function, (:call, :hash, (:(::), :a, :AbstractArray), (:(::), :h, :UInt)), (:block,
        (:line, 1945, :none),
        (:+=, :h, :hashaa_seed),
        (:line, 1946, :none),
        (:+=, :h, (:call, :hash, (:call, :size, :a))),
        (:line, 1948, :none),
        (:(=), :state, (:call, :start, :a)),
        (:line, 1949, :none),
        (:&&, (:call, :done, :a, :state), (:return, :h)),
        (:line, 1950, :none),
        (:(=), (:tuple, :x2, :state), (:call, :next, :a, :state)),
        (:line, 1951, :none),
        (:&&, (:call, :done, :a, :state), (:return, (:call, :hash, :x2, :h))),
        (:line, 1953, :none),
        (:(=), :x1, :x2),
        (:line, 1954, :none),
        (:while, (:call, :!, (:call, :done, :a, :state)), (:block,
            (:line, 1955, :none),
            (:(=), :x1, :x2),
            (:line, 1956, :none),
            (:(=), (:tuple, :x2, :state), (:call, :next, :a, :state)),
            (:line, 1957, :none),
            (:if, (:call, :isequal, :x2, :x1), (:block,
                (:line, 1960, :none),
                (:(=), :runlength, 2),
                (:line, 1961, :none),
                (:while, (:call, :!, (:call, :done, :a, :state)), (:block,
                    (:line, 1962, :none),
                    (:(=), (:tuple, :x2, :state), (:call, :next, :a, :state)),
                    (:line, 1963, :none),
                    (:||, (:call, :isequal, :x1, :x2), (:break,)),
                    (:line, 1964, :none),
                    (:+=, :runlength, 1)
                  )),
                (:line, 1966, :none),
                (:+=, :h, :hashrle_seed),
                (:line, 1967, :none),
                (:(=), :h, (:call, :hash, :runlength, :h))
              )),
            (:line, 1969, :none),
            (:(=), :h, (:call, :hash, :x1, :h))
          )),
        (:line, 1971, :none),
        (:&&, (:call, :!, (:call, :isequal, :x2, :x1)), (:(=), :h, (:call, :hash, :x2, :h))),
        (:line, 1972, :none),
        (:return, :h)
      ))
  ))