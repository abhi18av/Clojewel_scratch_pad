(:quote, (:block,
    (:line, 5, :none),
    (:const, (:(=), :_fact_table64, (:ref, :Int64, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200, 1307674368000, 20922789888000, 355687428096000, 6402373705728000, 121645100408832000, 2432902008176640000))),
    (:line, 10, :none),
    (:const, (:(=), :_fact_table128, (:ref, :UInt128, (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000000001"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000000002"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000000006"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000000018"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000000078"), (:macrocall, Symbol("@uint128_str"), "0x000000000000000000000000000002d0"), (:macrocall, Symbol("@uint128_str"), "0x000000000000000000000000000013b0"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000009d80"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000058980"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000000375f00"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000000002611500"), (:macrocall, Symbol("@uint128_str"), "0x0000000000000000000000001c8cfc00"), (:macrocall, Symbol("@uint128_str"), "0x0000000000000000000000017328cc00"), (:macrocall, Symbol("@uint128_str"), "0x0000000000000000000000144c3b2800"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000013077775800"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000000130777758000"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000001437eeecd8000"), (:macrocall, Symbol("@uint128_str"), "0x00000000000000000016beecca730000"), (:macrocall, Symbol("@uint128_str"), "0x000000000000000001b02b9306890000"), (:macrocall, Symbol("@uint128_str"), "0x000000000000000021c3677c82b40000"), (:macrocall, Symbol("@uint128_str"), "0x0000000000000002c5077d36b8c40000"), (:macrocall, Symbol("@uint128_str"), "0x000000000000003ceea4c2b3e0d80000"), (:macrocall, Symbol("@uint128_str"), "0x000000000000057970cd7e2933680000"), (:macrocall, Symbol("@uint128_str"), "0x00000000000083629343d3dcd1c00000"), (:macrocall, Symbol("@uint128_str"), "0x00000000000cd4a0619fb0907bc00000"), (:macrocall, Symbol("@uint128_str"), "0x00000000014d9849ea37eeac91800000"), (:macrocall, Symbol("@uint128_str"), "0x00000000232f0fcbb3e62c3358800000"), (:macrocall, Symbol("@uint128_str"), "0x00000003d925ba47ad2cd59dae000000"), (:macrocall, Symbol("@uint128_str"), "0x0000006f99461a1e9e1432dcb6000000"), (:macrocall, Symbol("@uint128_str"), "0x00000d13f6370f96865df5dd54000000"), (:macrocall, Symbol("@uint128_str"), "0x0001956ad0aae33a4560c5cd2c000000"), (:macrocall, Symbol("@uint128_str"), "0x0032ad5a155c6748ac18b9a580000000"), (:macrocall, Symbol("@uint128_str"), "0x0688589cc0e9505e2f2fee5580000000"), (:macrocall, Symbol("@uint128_str"), "0xde1bc4d19efcac82445da75b00000000")))),
    (:line, 29, :none),
    (:function, (:call, :factorial_lookup, (:(::), :n, :Integer), :table, :lim), (:block,
        (:line, 30, :none),
        (:&&, (:call, :<, :n, 0), (:call, :throw, (:call, :DomainError))),
        (:line, 31, :none),
        (:&&, (:call, :>, :n, :lim), (:call, :throw, (:call, :OverflowError))),
        (:line, 32, :none),
        (:&&, (:call, :(==), :n, 0), (:return, (:call, :one, :n))),
        (:line, 33, :none),
        (:macrocall, Symbol("@inbounds"), (:(=), :f, (:ref, :table, :n))),
        (:line, 34, :none),
        (:return, (:call, :oftype, :n, :f))
      )),
    (:line, 37, :none),
    (:(=), (:call, :factorial, (:(::), :n, :Int128)), (:block,
        (:line, 37, :none),
        (:call, :factorial_lookup, :n, :_fact_table128, 33)
      )),
    (:line, 38, :none),
    (:(=), (:call, :factorial, (:(::), :n, :UInt128)), (:block,
        (:line, 38, :none),
        (:call, :factorial_lookup, :n, :_fact_table128, 34)
      )),
    (:line, 39, :none),
    (:(=), (:call, :factorial, (:(::), :n, (:curly, :Union, :Int64, :UInt64))), (:block,
        (:line, 39, :none),
        (:call, :factorial_lookup, :n, :_fact_table64, 20)
      )),
    (:line, 41, :none),
    (:if, (:call, :(===), :Int, :Int32), (:block,
        (:line, 42, :none),
        (:(=), (:call, :factorial, (:(::), :n, (:curly, :Union, :Int8, :UInt8, :Int16, :UInt16))), (:block,
            (:line, 42, :none),
            (:call, :factorial, (:call, :Int32, :n))
          )),
        (:line, 43, :none),
        (:(=), (:call, :factorial, (:(::), :n, (:curly, :Union, :Int32, :UInt32))), (:block,
            (:line, 43, :none),
            (:call, :factorial_lookup, :n, :_fact_table64, 12)
          ))
      ), (:block,
        (:line, 45, :none),
        (:(=), (:call, :factorial, (:(::), :n, (:curly, :Union, :Int8, :UInt8, :Int16, :UInt16, :Int32, :UInt32))), (:block,
            (:line, 45, :none),
            (:call, :factorial, (:call, :Int64, :n))
          ))
      )),
    (:line, 48, :none),
    (:function, (:call, :gamma, (:(::), :n, (:curly, :Union, :Int8, :UInt8, :Int16, :UInt16, :Int32, :UInt32, :Int64, :UInt64))), (:block,
        (:line, 49, :none),
        (:&&, (:call, :<, :n, 0), (:call, :throw, (:call, :DomainError))),
        (:line, 50, :none),
        (:&&, (:call, :(==), :n, 0), (:return, :Inf)),
        (:line, 51, :none),
        (:&&, (:call, :(<=), :n, 2), (:return, 1.0)),
        (:line, 52, :none),
        (:&&, (:call, :>, :n, 20), (:return, (:call, :gamma, (:call, :Float64, :n)))),
        (:line, 53, :none),
        (:macrocall, Symbol("@inbounds"), (:return, (:call, :Float64, (:ref, :_fact_table64, (:call, :-, :n, 1)))))
      )),
    (:line, 59, :none),
    (:macrocall, :(Core.@doc), "    isperm(v) -> Bool\n\nReturns `true` if `v` is a valid permutation.\n\n```jldoctest\njulia> isperm([1; 2])\ntrue\n\njulia> isperm([1; 3])\nfalse\n```\n", (:function, (:call, :isperm, :A), (:block,
          (:line, 73, :none),
          (:(=), :n, (:call, :length, :A)),
          (:line, 74, :none),
          (:(=), :used, (:call, :falses, :n)),
          (:line, 75, :none),
          (:for, (:(=), :a, :A), (:block,
              (:line, 76, :none),
              (:||, (:&&, (:comparison, 0, :<, :a, :(<=), :n), (:âŠ»=, (:ref, :used, :a), true)), (:return, false))
            )),
          (:line, 78, :none),
          true
        ))),
    (:line, 81, :none),
    (:(=), (:call, :isperm, (:(::), :p, (:curly, :Tuple))), (:block,
        (:line, 81, :none),
        true
      )),
    (:line, 82, :none),
    (:(=), (:call, :isperm, (:(::), :p, (:curly, :Tuple, :Int))), (:block,
        (:line, 82, :none),
        (:call, :(==), (:ref, :p, 1), 1)
      )),
    (:line, 83, :none),
    (:(=), (:call, :isperm, (:(::), :p, (:curly, :Tuple, :Int, :Int))), (:block,
        (:line, 83, :none),
        (:call, :|, (:call, :&, (:call, :(==), (:ref, :p, 1), 1), (:call, :(==), (:ref, :p, 2), 2)), (:call, :&, (:call, :(==), (:ref, :p, 1), 2), (:call, :(==), (:ref, :p, 2), 1)))
      )),
    (:line, 85, :none),
    (:function, (:call, :permute!!, :a, (:(::), :p, (:curly, :AbstractVector, (:<:, :Integer)))), (:block,
        (:line, 86, :none),
        (:(=), :count, 0),
        (:line, 87, :none),
        (:(=), :start, 0),
        (:line, 88, :none),
        (:while, (:call, :<, :count, (:call, :length, :a)), (:block,
            (:line, 89, :none),
            (:(=), :ptr, (:(=), :start, (:call, :findnext, :p, (:call, :+, :start, 1)))),
            (:line, 90, :none),
            (:(=), :temp, (:ref, :a, :start)),
            (:line, 91, :none),
            (:(=), :next, (:ref, :p, :start)),
            (:line, 92, :none),
            (:+=, :count, 1),
            (:line, 93, :none),
            (:while, (:call, :(!=), :next, :start), (:block,
                (:line, 94, :none),
                (:(=), (:ref, :a, :ptr), (:ref, :a, :next)),
                (:line, 95, :none),
                (:(=), (:ref, :p, :ptr), 0),
                (:line, 96, :none),
                (:(=), :ptr, :next),
                (:line, 97, :none),
                (:(=), :next, (:ref, :p, :next)),
                (:line, 98, :none),
                (:+=, :count, 1)
              )),
            (:line, 100, :none),
            (:(=), (:ref, :a, :ptr), :temp),
            (:line, 101, :none),
            (:(=), (:ref, :p, :ptr), 0)
          )),
        (:line, 103, :none),
        :a
      )),
    (:line, 106, :none),
    (:macrocall, :(Core.@doc), "    permute!(v, p)\n\nPermute vector `v` in-place, according to permutation `p`. No checking is done\nto verify that `p` is a permutation.\n\nTo return a new permutation, use `v[p]`. Note that this is generally faster than\n`permute!(v,p)` for large vectors.\n\nSee also [`ipermute!`](@ref)\n\n```jldoctest\njulia> A = [1, 1, 3, 4];\n\njulia> perm = [2, 4, 3, 1];\n\njulia> permute!(A, perm);\n\njulia> A\n4-element Array{Int64,1}:\n 1\n 4\n 3\n 1\n```\n", (:(=), (:call, :permute!, :a, (:(::), :p, :AbstractVector)), (:block,
          (:line, 132, :none),
          (:call, :permute!!, :a, (:call, :copymutable, :p))
        ))),
    (:line, 134, :none),
    (:function, (:call, :ipermute!!, :a, (:(::), :p, (:curly, :AbstractVector, (:<:, :Integer)))), (:block,
        (:line, 135, :none),
        (:(=), :count, 0),
        (:line, 136, :none),
        (:(=), :start, 0),
        (:line, 137, :none),
        (:while, (:call, :<, :count, (:call, :length, :a)), (:block,
            (:line, 138, :none),
            (:(=), :start, (:call, :findnext, :p, (:call, :+, :start, 1))),
            (:line, 139, :none),
            (:(=), :temp, (:ref, :a, :start)),
            (:line, 140, :none),
            (:(=), :next, (:ref, :p, :start)),
            (:line, 141, :none),
            (:+=, :count, 1),
            (:line, 142, :none),
            (:while, (:call, :(!=), :next, :start), (:block,
                (:line, 143, :none),
                (:(=), :temp_next, (:ref, :a, :next)),
                (:line, 144, :none),
                (:(=), (:ref, :a, :next), :temp),
                (:line, 145, :none),
                (:(=), :temp, :temp_next),
                (:line, 146, :none),
                (:(=), :ptr, (:ref, :p, :next)),
                (:line, 147, :none),
                (:(=), (:ref, :p, :next), 0),
                (:line, 148, :none),
                (:(=), :next, :ptr),
                (:line, 149, :none),
                (:+=, :count, 1)
              )),
            (:line, 151, :none),
            (:(=), (:ref, :a, :next), :temp),
            (:line, 152, :none),
            (:(=), (:ref, :p, :next), 0)
          )),
        (:line, 154, :none),
        :a
      )),
    (:line, 157, :none),
    (:macrocall, :(Core.@doc), "    ipermute!(v, p)\n\nLike `permute!`, but the inverse of the given permutation is applied.\n\n```jldoctest\njulia> A = [1, 1, 3, 4];\n\njulia> perm = [2, 4, 3, 1];\n\njulia> ipermute!(A, perm);\n\njulia> A\n4-element Array{Int64,1}:\n 4\n 1\n 3\n 1\n```\n", (:(=), (:call, :ipermute!, :a, (:(::), :p, :AbstractVector)), (:block,
          (:line, 177, :none),
          (:call, :ipermute!!, :a, (:call, :copymutable, :p))
        ))),
    (:line, 179, :none),
    (:macrocall, :(Core.@doc), "    invperm(v)\n\nReturn the inverse permutation of `v`.\nIf `B = A[v]`, then `A == B[invperm(v)]`.\n\n```jldoctest\njulia> v = [2; 4; 3; 1];\n\njulia> invperm(v)\n4-element Array{Int64,1}:\n 4\n 1\n 3\n 2\n\njulia> A = ['a','b','c','d'];\n\njulia> B = A[v]\n4-element Array{Char,1}:\n 'b'\n 'd'\n 'c'\n 'a'\n\njulia> B[invperm(v)]\n4-element Array{Char,1}:\n 'a'\n 'b'\n 'c'\n 'd'\n```\n", (:function, (:call, :invperm, (:(::), :a, :AbstractVector)), (:block,
          (:line, 213, :none),
          (:(=), :b, (:call, :zero, :a)),
          (:line, 214, :none),
          (:(=), :n, (:call, :length, :a)),
          (:line, 215, :none),
          (:macrocall, Symbol("@inbounds"), (:for, (:(=), (:tuple, :i, :j), (:call, :enumerate, :a)), (:block,
                (:line, 216, :none),
                (:||, (:&&, (:comparison, 1, :(<=), :j, :(<=), :n), (:call, :(==), (:ref, :b, :j), 0)), (:call, :throw, (:call, :ArgumentError, "argument is not a permutation"))),
                (:line, 218, :none),
                (:(=), (:ref, :b, :j), :i)
              ))),
          (:line, 220, :none),
          :b
        ))),
    (:line, 223, :none),
    (:function, (:call, :invperm, (:(::), :p, (:curly, :Union, (:curly, :Tuple), (:curly, :Tuple, :Int), (:curly, :Tuple, :Int, :Int)))), (:block,
        (:line, 224, :none),
        (:||, (:call, :isperm, :p), (:call, :throw, (:call, :ArgumentError, "argument is not a permutation"))),
        (:line, 225, :none),
        :p
      )),
    (:line, 227, :none),
    (:(=), (:call, :invperm, (:(::), :a, :Tuple)), (:block,
        (:line, 227, :none),
        (:tuple, (:..., (:call, :invperm, (:vect, (:..., :a)))))
      )),
    (:line, 230, :none),
    (:macrocall, :(Core.@doc), "    nextprod([k_1, k_2,...], n)\n\nNext integer greater than or equal to `n` that can be written as ``\\prod k_i^{p_i}`` for integers\n``p_1``, ``p_2``, etc.\n\n```jldoctest\njulia> nextprod([2, 3], 105)\n108\n\njulia> 2^2 * 3^3\n108\n```\n", (:function, (:call, :nextprod, (:(::), :a, (:curly, :Vector, :Int)), :x), (:block,
          (:line, 245, :none),
          (:if, (:call, :>, :x, (:call, :typemax, :Int)), (:block,
              (:line, 246, :none),
              (:call, :throw, (:call, :ArgumentError, (:string, "unsafe for x > typemax(Int), got ", :x)))
            )),
          (:line, 248, :none),
          (:(=), :k, (:call, :length, :a)),
          (:line, 249, :none),
          (:(=), :v, (:call, :ones, :Int, :k)),
          (:line, 250, :none),
          (:(=), :mx, (:comprehension, (:generator, (:call, :nextpow, :ai, :x), (:(=), :ai, :a)))),
          (:line, 251, :none),
          (:(=), (:ref, :v, 1), (:ref, :mx, 1)),
          (:line, 252, :none),
          (:(=), (:(::), :p, (:call, :widen, :Int)), (:ref, :mx, 1)),
          (:line, 253, :none),
          (:(=), :best, :p),
          (:line, 254, :none),
          (:(=), :icarry, 1),
          (:line, 256, :none),
          (:while, (:call, :<, (:ref, :v, :end), (:ref, :mx, :end)), (:block,
              (:line, 257, :none),
              (:if, (:call, :(>=), :p, :x), (:block,
                  (:line, 258, :none),
                  (:(=), :best, (:if, (:call, :<, :p, :best), :p, :best)),
                  (:line, 259, :none),
                  (:(=), :carrytest, true),
                  (:line, 260, :none),
                  (:while, :carrytest, (:block,
                      (:line, 261, :none),
                      (:(=), :p, (:call, :div, :p, (:ref, :v, :icarry))),
                      (:line, 262, :none),
                      (:(=), (:ref, :v, :icarry), 1),
                      (:line, 263, :none),
                      (:+=, :icarry, 1),
                      (:line, 264, :none),
                      (:*=, :p, (:ref, :a, :icarry)),
                      (:line, 265, :none),
                      (:*=, (:ref, :v, :icarry), (:ref, :a, :icarry)),
                      (:line, 266, :none),
                      (:(=), :carrytest, (:&&, (:call, :>, (:ref, :v, :icarry), (:ref, :mx, :icarry)), (:call, :<, :icarry, :k)))
                    )),
                  (:line, 268, :none),
                  (:if, (:call, :<, :p, :x), (:block,
                      (:line, 269, :none),
                      (:(=), :icarry, 1)
                    ))
                ), (:block,
                  (:line, 272, :none),
                  (:while, (:call, :<, :p, :x), (:block,
                      (:line, 273, :none),
                      (:*=, :p, (:ref, :a, 1)),
                      (:line, 274, :none),
                      (:*=, (:ref, :v, 1), (:ref, :a, 1))
                    ))
                ))
            )),
          (:line, 279, :none),
          (:return, (:if, (:call, :<, (:ref, :mx, :end), :best), (:call, :Int, (:ref, :mx, :end)), (:call, :Int, :best)))
        )))
  ))