(:quote, (:block,
    (:line, 7, :none),
    (:const, (:(=), (:curly, :AbstractVector, :T), (:curly, :AbstractArray, :T, 1))),
    (:line, 8, :none),
    (:const, (:(=), (:curly, :AbstractMatrix, :T), (:curly, :AbstractArray, :T, 2))),
    (:line, 9, :none),
    (:const, (:(=), (:curly, :AbstractVecOrMat, :T), (:curly, :Union, (:curly, :AbstractVector, :T), (:curly, :AbstractMatrix, :T)))),
    (:line, 10, :none),
    (:const, (:(=), :RangeIndex, (:curly, :Union, :Int, (:curly, :Range, :Int), (:curly, :AbstractUnitRange, :Int)))),
    (:line, 11, :none),
    (:const, (:(=), :DimOrInd, (:curly, :Union, :Integer, :AbstractUnitRange))),
    (:line, 12, :none),
    (:const, (:(=), :IntOrInd, (:curly, :Union, :Int, :AbstractUnitRange))),
    (:line, 13, :none),
    (:const, (:(=), (:curly, :DimsOrInds, :N), (:curly, :NTuple, :N, :DimOrInd))),
    (:line, 14, :none),
    (:const, (:(=), :NeedsShaping, (:curly, :Union, (:curly, :Tuple, :Integer, (:curly, :Vararg, :Integer)), (:curly, :Tuple, :OneTo, (:curly, :Vararg, :OneTo))))),
    (:line, 16, :none),
    (:const, (:(=), (:curly, :Vector, :T), (:curly, :Array, :T, 1))),
    (:line, 17, :none),
    (:const, (:(=), (:curly, :Matrix, :T), (:curly, :Array, :T, 2))),
    (:line, 18, :none),
    (:const, (:(=), (:curly, :VecOrMat, :T), (:curly, :Union, (:curly, :Vector, :T), (:curly, :Matrix, :T)))),
    (:line, 20, :none),
    (:const, (:(=), (:curly, :DenseVector, :T), (:curly, :DenseArray, :T, 1))),
    (:line, 21, :none),
    (:const, (:(=), (:curly, :DenseMatrix, :T), (:curly, :DenseArray, :T, 2))),
    (:line, 22, :none),
    (:const, (:(=), (:curly, :DenseVecOrMat, :T), (:curly, :Union, (:curly, :DenseVector, :T), (:curly, :DenseMatrix, :T)))),
    (:line, 26, :none),
    (:macrocall, :(Core.@doc), "    eltype(type)\n\nDetermine the type of the elements generated by iterating a collection of the given `type`.\nFor associative collection types, this will be a `Pair{KeyType,ValType}`. The definition\n`eltype(x) = eltype(typeof(x))` is provided for convenience so that instances can be passed\ninstead of types. However the form that accepts a type argument should be defined for new\ntypes.\n\n```jldoctest\njulia> eltype(ones(Float32,2,2))\nFloat32\n\njulia> eltype(ones(Int8,2,2))\nInt8\n```\n", (:(=), (:call, :eltype, (:(::), :Type)), (:block,
          (:line, 43, :none),
          :Any
        ))),
    (:line, 44, :none),
    (:(=), (:call, :eltype, (:(::), (:curly, :Type, :Any))), (:block,
        (:line, 44, :none),
        :Any
      )),
    (:line, 45, :none),
    (:(=), (:call, :eltype, (:(::), (:curly, :Type, :Bottom))), (:block,
        (:line, 45, :none),
        (:call, :throw, (:call, :ArgumentError, "Union{} does not have elements"))
      )),
    (:line, 46, :none),
    (:(=), (:call, :eltype, (:(::), :t, :DataType)), (:block,
        (:line, 46, :none),
        (:call, :eltype, (:call, :supertype, :t))
      )),
    (:line, 47, :none),
    (:(=), (:call, :eltype, :x), (:block,
        (:line, 47, :none),
        (:call, :eltype, (:call, :typeof, :x))
      )),
    (:line, 49, :none),
    (:toplevel, (:import, :Core, :arraysize), (:import, :Core, :arrayset), (:import, :Core, :arrayref)),
    (:line, 51, :none),
    (:macrocall, :(Core.@doc), "    Array{T}(dims)\n    Array{T,N}(dims)\n\nConstruct an uninitialized `N`-dimensional dense array with element type `T`,\nwhere `N` is determined from the length or number of `dims`. `dims` may\nbe a tuple or a series of integer arguments corresponding to the lengths in each dimension.\nIf the rank `N` is supplied explicitly as in `Array{T,N}(dims)`, then it must\nmatch the length or number of `dims`.\n\n# Example\n\n```jldoctest\njulia> A = Array{Float64, 2}(2, 2);\n\njulia> ndims(A)\n2\n\njulia> eltype(A)\nFloat64\n```\n", :Array),
    (:line, 75, :none),
    (:(=), (:call, :vect), (:block,
        (:line, 75, :none),
        (:call, (:curly, :Array, :Any, 1), 0)
      )),
    (:line, 76, :none),
    (:(=), (:where, (:call, :vect, (:..., (:(::), :X, :T))), :T), (:block,
        (:line, 76, :none),
        (:typed_comprehension, :T, (:generator, (:ref, :X, :i), (:(=), :i, (:(:), 1, (:call, :length, :X)))))
      )),
    (:line, 78, :none),
    (:function, (:call, :vect, (:..., :X)), (:block,
        (:line, 79, :none),
        (:(=), :T, (:call, :promote_typeof, (:..., :X))),
        (:line, 82, :none),
        (:return, (:call, :copy!, (:call, (:curly, :Array, :T, 1), (:call, :length, :X)), :X))
      )),
    (:line, 85, :none),
    (:(=), (:call, :size, (:(::), :a, :Array), :d), (:block,
        (:line, 85, :none),
        (:call, :arraysize, :a, :d)
      )),
    (:line, 86, :none),
    (:(=), (:call, :size, (:(::), :a, :Vector)), (:block,
        (:line, 86, :none),
        (:tuple, (:call, :arraysize, :a, 1))
      )),
    (:line, 87, :none),
    (:(=), (:call, :size, (:(::), :a, :Matrix)), (:block,
        (:line, 87, :none),
        (:tuple, (:call, :arraysize, :a, 1), (:call, :arraysize, :a, 2))
      )),
    (:line, 88, :none),
    (:(=), (:call, :size, (:(::), :a, :Array)), (:block,
        (:line, 88, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :_size, (:tuple,), :a)
        )
      )),
    (:line, 89, :none),
    (:(=), (:where, (:call, :_size, (:(::), :out, (:curly, :NTuple, :N)), (:(::), :A, (:curly, :Array, :_, :N))), :_, :N), (:block,
        (:line, 89, :none),
        :out
      )),
    (:line, 90, :none),
    (:function, (:where, (:where, (:where, (:call, :_size, (:(::), :out, (:curly, :NTuple, :M)), (:(::), :A, (:curly, :Array, :_, :N))), :_), :M), :N), (:block,
        (:line, 91, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 92, :none),
        (:call, :_size, (:tuple, (:..., :out), (:call, :size, :A, (:call, :+, :M, 1))), :A)
      )),
    (:line, 95, :none),
    (:(=), (:call, :asize_from, (:(::), :a, :Array), :n), (:block,
        (:line, 95, :none),
        (:if, (:call, :>, :n, (:call, :ndims, :a)), (:tuple,), (:tuple, (:call, :arraysize, :a, :n), (:..., (:call, :asize_from, :a, (:call, :+, :n, 1)))))
      )),
    (:line, 97, :none),
    (:(=), (:call, :length, (:(::), :a, :Array)), (:block,
        (:line, 97, :none),
        (:call, :arraylen, :a)
      )),
    (:line, 98, :none),
    (:(=), (:where, (:call, :elsize, (:(::), :a, (:curly, :Array, :T))), :T), (:block,
        (:line, 98, :none),
        (:if, (:call, :isbits, :T), (:call, :sizeof, :T), (:call, :sizeof, :Ptr))
      )),
    (:line, 99, :none),
    (:(=), (:call, :sizeof, (:(::), :a, :Array)), (:block,
        (:line, 99, :none),
        (:call, :*, (:call, :elsize, :a), (:call, :length, :a))
      )),
    (:line, 101, :none),
    (:function, (:call, :isassigned, (:(::), :a, :Array), (:..., (:(::), :i, :Int))), (:block,
        (:line, 102, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 103, :none),
        (:(=), :ii, (:call, :-, (:call, :%, (:call, :sub2ind, (:call, :size, :a), (:..., :i)), :UInt), 1)),
        (:line, 104, :none),
        (:||, (:call, :<, :ii, (:call, :%, (:call, :length, :a), :UInt)), (:return, false)),
        (:line, 105, :none),
        (:call, :(==), (:call, :ccall, (:quote, #QuoteNode
              :jl_array_isassigned
            ), :Cint, (:tuple, :Any, :UInt), :a, :ii), 1)
      )),
    (:line, 110, :none),
    (:function, (:where, (:call, :unsafe_copy!, (:(::), :dest, (:curly, :Ptr, :T)), (:(::), :src, (:curly, :Ptr, :T)), :n), :T), (:block,
        (:line, 113, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :memmove
          ), (:curly, :Ptr, :Void), (:tuple, (:curly, :Ptr, :Void), (:curly, :Ptr, :Void), :UInt), :dest, :src, (:call, :*, :n, (:call, :sizeof, :T))),
        (:line, 115, :none),
        (:return, :dest)
      )),
    (:line, 118, :none),
    (:function, (:where, (:call, :unsafe_copy!, (:(::), :dest, (:curly, :Array, :T)), :doffs, (:(::), :src, (:curly, :Array, :T)), :soffs, :n), :T), (:block,
        (:line, 119, :none),
        (:if, (:call, :isbits, :T), (:block,
            (:line, 120, :none),
            (:call, :unsafe_copy!, (:call, :pointer, :dest, :doffs), (:call, :pointer, :src, :soffs), :n)
          ), (:block,
            (:line, 122, :none),
            (:call, :ccall, (:quote, #QuoteNode
                :jl_array_ptr_copy
              ), :Void, (:tuple, :Any, (:curly, :Ptr, :Void), :Any, (:curly, :Ptr, :Void), :Int), :dest, (:call, :pointer, :dest, :doffs), :src, (:call, :pointer, :src, :soffs), :n)
          )),
        (:line, 125, :none),
        (:return, :dest)
      )),
    (:line, 128, :none),
    (:function, (:where, (:call, :copy!, (:(::), :dest, (:curly, :Array, :T)), (:(::), :doffs, :Integer), (:(::), :src, (:curly, :Array, :T)), (:(::), :soffs, :Integer), (:(::), :n, :Integer)), :T), (:block,
        (:line, 129, :none),
        (:&&, (:call, :(==), :n, 0), (:return, :dest)),
        (:line, 130, :none),
        (:||, (:call, :>, :n, 0), (:call, :throw, (:call, :ArgumentError, (:call, :string, "tried to copy n=", :n, " elements, but n should be nonnegative")))),
        (:line, 131, :none),
        (:if, (:||, (:call, :<, :soffs, 1), (:||, (:call, :<, :doffs, 1), (:||, (:call, :>, (:call, :-, (:call, :+, :soffs, :n), 1), (:call, :length, :src)), (:call, :>, (:call, :-, (:call, :+, :doffs, :n), 1), (:call, :length, :dest))))), (:block,
            (:line, 132, :none),
            (:call, :throw, (:call, :BoundsError))
          )),
        (:line, 134, :none),
        (:call, :unsafe_copy!, :dest, :doffs, :src, :soffs, :n)
      )),
    (:line, 137, :none),
    (:(=), (:where, (:call, :copy!, (:(::), :dest, (:curly, :Array, :T)), (:(::), :src, (:curly, :Array, :T))), :T), (:block,
        (:line, 137, :none),
        (:call, :copy!, :dest, 1, :src, 1, (:call, :length, :src))
      )),
    (:line, 139, :none),
    (:(=), (:where, (:call, :copy, (:(::), :a, :T)), (:<:, :T, :Array)), (:block,
        (:line, 139, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_array_copy
          ), (:curly, :Ref, :T), (:tuple, :Any), :a)
      )),
    (:line, 141, :none),
    (:function, (:where, (:where, (:call, :reinterpret, (:(::), (:curly, :Type, :T)), (:(::), :a, (:curly, :Array, :S, 1))), :T), :S), (:block,
        (:line, 142, :none),
        (:(=), :nel, (:call, :Int, (:call, :div, (:call, :*, (:call, :length, :a), (:call, :sizeof, :S)), (:call, :sizeof, :T)))),
        (:line, 144, :none),
        (:return, (:call, :reinterpret, :T, :a, (:tuple, :nel)))
      )),
    (:line, 147, :none),
    (:function, (:where, (:where, (:call, :reinterpret, (:(::), (:curly, :Type, :T)), (:(::), :a, (:curly, :Array, :S))), :T), :S), (:block,
        (:line, 148, :none),
        (:if, (:call, :(!=), (:call, :sizeof, :S), (:call, :sizeof, :T)), (:block,
            (:line, 149, :none),
            (:call, :throw, (:call, :ArgumentError, "result shape not specified"))
          )),
        (:line, 151, :none),
        (:call, :reinterpret, :T, :a, (:call, :size, :a))
      )),
    (:line, 154, :none),
    (:function, (:where, (:where, (:where, (:call, :reinterpret, (:(::), (:curly, :Type, :T)), (:(::), :a, (:curly, :Array, :S)), (:(::), :dims, (:curly, :NTuple, :N, :Int))), :T), :S), :N), (:block,
        (:line, 155, :none),
        (:if, (:call, :!, (:call, :isbits, :T)), (:block,
            (:line, 156, :none),
            (:call, :throw, (:call, :ArgumentError, (:string, "cannot reinterpret Array{", :S, "} to ::Type{Array{", :T, "}}, type ", :T, " is not a bits type")))
          )),
        (:line, 158, :none),
        (:if, (:call, :!, (:call, :isbits, :S)), (:block,
            (:line, 159, :none),
            (:call, :throw, (:call, :ArgumentError, (:string, "cannot reinterpret Array{", :S, "} to ::Type{Array{", :T, "}}, type ", :S, " is not a bits type")))
          )),
        (:line, 161, :none),
        (:(=), :nel, (:call, :div, (:call, :*, (:call, :length, :a), (:call, :sizeof, :S)), (:call, :sizeof, :T))),
        (:line, 162, :none),
        (:if, (:call, :(!=), (:call, :prod, :dims), :nel), (:block,
            (:line, 163, :none),
            (:call, :throw, (:call, :DimensionMismatch, (:string, "new dimensions ", :dims, " must be consistent with array size ", :nel)))
          )),
        (:line, 165, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_reshape_array
          ), (:curly, :Array, :T, :N), (:tuple, :Any, :Any, :Any), (:curly, :Array, :T, :N), :a, :dims)
      )),
    (:line, 169, :none),
    (:function, (:where, (:where, (:call, :reshape, (:(::), :a, (:curly, :Array, :T, :N)), (:(::), :dims, (:curly, :NTuple, :N, :Int))), :T), :N), (:block,
        (:line, 170, :none),
        (:if, (:call, :(!=), (:call, :prod, :dims), (:call, :length, :a)), (:block,
            (:line, 171, :none),
            (:call, :throw, (:call, :DimensionMismatch, (:string, "new dimensions ", :dims, " must be consistent with array size ", (:call, :length, :a))))
          )),
        (:line, 173, :none),
        (:if, (:call, :(==), :dims, (:call, :size, :a)), (:block,
            (:line, 174, :none),
            (:return, :a)
          )),
        (:line, 176, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_reshape_array
          ), (:curly, :Array, :T, :N), (:tuple, :Any, :Any, :Any), (:curly, :Array, :T, :N), :a, :dims)
      )),
    (:line, 180, :none),
    (:function, (:where, (:where, (:call, :reshape, (:(::), :a, (:curly, :Array, :T)), (:(::), :dims, (:curly, :NTuple, :N, :Int))), :T), :N), (:block,
        (:line, 181, :none),
        (:if, (:call, :(!=), (:call, :prod, :dims), (:call, :length, :a)), (:block,
            (:line, 182, :none),
            (:call, :throw, (:call, :DimensionMismatch, (:string, "new dimensions ", :dims, " must be consistent with array size ", (:call, :length, :a))))
          )),
        (:line, 184, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_reshape_array
          ), (:curly, :Array, :T, :N), (:tuple, :Any, :Any, :Any), (:curly, :Array, :T, :N), :a, :dims)
      )),
    (:line, 189, :none),
    (:(=), (:where, (:call, :similar, (:(::), :a, (:curly, :Array, :T, 1))), :T), (:block,
        (:line, 189, :none),
        (:call, (:curly, :Array, :T, 1), (:call, :size, :a, 1))
      )),
    (:line, 190, :none),
    (:(=), (:where, (:call, :similar, (:(::), :a, (:curly, :Array, :T, 2))), :T), (:block,
        (:line, 190, :none),
        (:call, (:curly, :Array, :T, 2), (:call, :size, :a, 1), (:call, :size, :a, 2))
      )),
    (:line, 191, :none),
    (:(=), (:where, (:call, :similar, (:(::), :a, (:curly, :Array, :T, 1)), (:(::), :S, :Type)), :T), (:block,
        (:line, 191, :none),
        (:call, (:curly, :Array, :S, 1), (:call, :size, :a, 1))
      )),
    (:line, 192, :none),
    (:(=), (:where, (:call, :similar, (:(::), :a, (:curly, :Array, :T, 2)), (:(::), :S, :Type)), :T), (:block,
        (:line, 192, :none),
        (:call, (:curly, :Array, :S, 2), (:call, :size, :a, 1), (:call, :size, :a, 2))
      )),
    (:line, 193, :none),
    (:(=), (:where, (:call, :similar, (:(::), :a, (:curly, :Array, :T)), (:(::), :m, :Int)), :T), (:block,
        (:line, 193, :none),
        (:call, (:curly, :Array, :T, 1), :m)
      )),
    (:line, 194, :none),
    (:(=), (:where, (:call, :similar, (:(::), :a, :Array), (:(::), :T, :Type), (:(::), :dims, (:curly, :Dims, :N))), :N), (:block,
        (:line, 194, :none),
        (:call, (:curly, :Array, :T, :N), :dims)
      )),
    (:line, 195, :none),
    (:(=), (:where, (:call, :similar, (:(::), :a, (:curly, :Array, :T)), (:(::), :dims, (:curly, :Dims, :N))), :T, :N), (:block,
        (:line, 195, :none),
        (:call, (:curly, :Array, :T, :N), :dims)
      )),
    (:line, 198, :none),
    (:function, (:where, (:call, :getindex, (:(::), (:curly, :Type, :T)), (:..., :vals)), :T), (:block,
        (:line, 199, :none),
        (:(=), :a, (:call, (:curly, :Array, :T, 1), (:call, :length, :vals))),
        (:line, 200, :none),
        (:macrocall, Symbol("@inbounds"), (:for, (:(=), :i, (:(:), 1, (:call, :length, :vals))), (:block,
              (:line, 201, :none),
              (:(=), (:ref, :a, :i), (:ref, :vals, :i))
            ))),
        (:line, 203, :none),
        (:return, :a)
      )),
    (:line, 206, :none),
    (:(=), (:where, (:call, :getindex, (:(::), (:curly, :Type, :T))), :T), (:block,
        (:line, 206, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, (:curly, :Array, :T, 1), 0)
        )
      )),
    (:line, 207, :none),
    (:(=), (:where, (:call, :getindex, (:(::), (:curly, :Type, :T)), :x), :T), (:block,
        (:line, 207, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:(=), :a, (:call, (:curly, :Array, :T, 1), 1)),
          (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :a, 1), :x)),
          :a
        )
      )),
    (:line, 208, :none),
    (:(=), (:where, (:call, :getindex, (:(::), (:curly, :Type, :T)), :x, :y), :T), (:block,
        (:line, 208, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:(=), :a, (:call, (:curly, :Array, :T, 1), 2)),
          (:macrocall, Symbol("@inbounds"), (:block,
              (:(=), (:ref, :a, 1), :x),
              (:(=), (:ref, :a, 2), :y)
            )),
          :a
        )
      )),
    (:line, 209, :none),
    (:(=), (:where, (:call, :getindex, (:(::), (:curly, :Type, :T)), :x, :y, :z), :T), (:block,
        (:line, 209, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:(=), :a, (:call, (:curly, :Array, :T, 1), 3)),
          (:macrocall, Symbol("@inbounds"), (:block,
              (:(=), (:ref, :a, 1), :x),
              (:(=), (:ref, :a, 2), :y),
              (:(=), (:ref, :a, 3), :z)
            )),
          :a
        )
      )),
    (:line, 211, :none),
    (:function, (:call, :getindex, (:(::), (:curly, :Type, :Any)), (:..., (:(::), :vals, :ANY))), (:block,
        (:line, 212, :none),
        (:(=), :a, (:call, (:curly, :Array, :Any, 1), (:call, :length, :vals))),
        (:line, 213, :none),
        (:macrocall, Symbol("@inbounds"), (:for, (:(=), :i, (:(:), 1, (:call, :length, :vals))), (:block,
              (:line, 214, :none),
              (:(=), (:ref, :a, :i), (:ref, :vals, :i))
            ))),
        (:line, 216, :none),
        (:return, :a)
      )),
    (:line, 218, :none),
    (:(=), (:call, :getindex, (:(::), (:curly, :Type, :Any))), (:block,
        (:line, 218, :none),
        (:call, (:curly, :Array, :Any, 1), 0)
      )),
    (:line, 220, :none),
    (:function, (:call, :fill!, (:(::), :a, (:curly, :Union, (:curly, :Array, :UInt8), (:curly, :Array, :Int8))), (:(::), :x, :Integer)), (:block,
        (:line, 221, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :memset
          ), (:curly, :Ptr, :Void), (:tuple, (:curly, :Ptr, :Void), :Cint, :Csize_t), :a, :x, (:call, :length, :a)),
        (:line, 222, :none),
        (:return, :a)
      )),
    (:line, 225, :none),
    (:function, (:where, (:call, :fill!, (:(::), :a, (:curly, :Array, :T)), :x), (:<:, :T, (:curly, :Union, :Integer, :AbstractFloat))), (:block,
        (:line, 226, :none),
        (:(=), :xT, (:call, :convert, :T, :x)),
        (:line, 227, :none),
        (:for, (:(=), :i, (:call, :eachindex, :a)), (:block,
            (:line, 228, :none),
            (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :a, :i), :xT))
          )),
        (:line, 230, :none),
        (:return, :a)
      )),
    (:line, 234, :none),
    (:macrocall, :(Core.@doc), "    fill(x, dims)\n\nCreate an array filled with the value `x`. For example, `fill(1.0, (5,5))` returns a 5×5\narray of floats, with each element initialized to `1.0`.\n\n```jldoctest\njulia> fill(1.0, (5,5))\n5×5 Array{Float64,2}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n```\n\nIf `x` is an object reference, all elements will refer to the same object. `fill(Foo(),\ndims)` will return an array filled with the result of evaluating `Foo()` once.\n", (:(=), (:call, :fill, :v, (:(::), :dims, :Dims)), (:block,
          (:line, 253, :none),
          (:call, :fill!, (:call, (:curly, :Array, (:call, :typeof, :v)), :dims), :v)
        ))),
    (:line, 254, :none),
    (:(=), (:call, :fill, :v, (:..., (:(::), :dims, :Integer))), (:block,
        (:line, 254, :none),
        (:call, :fill!, (:call, (:curly, :Array, (:call, :typeof, :v)), (:..., :dims)), :v)
      )),
    (:line, 256, :none),
    (:for, (:(=), (:tuple, :fname, :felt), (:tuple, (:tuple, (:quote, #QuoteNode
              :zeros
            ), (:quote, #QuoteNode
              :zero
            )), (:tuple, (:quote, #QuoteNode
              :ones
            ), (:quote, #QuoteNode
              :one
            )))), (:block,
        (:line, 257, :none),
        (:macrocall, Symbol("@eval"), (:block,
            (:line, 259, :none),
            (:(=), (:call, (:$, :fname), (:(::), :a, :AbstractArray), (:(::), :T, :Type), (:(::), :dims, :Tuple)), (:block,
                (:line, 259, :none),
                (:call, :fill!, (:call, :similar, :a, :T, :dims), (:call, (:$, :felt), :T))
              )),
            (:line, 260, :none),
            (:(=), (:call, (:$, :fname), (:(::), :a, :AbstractArray), (:(::), :T, :Type), (:..., :dims)), (:block,
                (:line, 260, :none),
                (:call, :fill!, (:call, :similar, :a, :T, (:..., :dims)), (:call, (:$, :felt), :T))
              )),
            (:line, 261, :none),
            (:(=), (:call, (:$, :fname), (:(::), :a, :AbstractArray), (:kw, (:(::), :T, :Type), (:call, :eltype, :a))), (:block,
                (:line, 261, :none),
                (:call, :fill!, (:call, :similar, :a, :T), (:call, (:$, :felt), :T))
              )),
            (:line, 263, :none),
            (:(=), (:call, (:$, :fname), (:(::), :T, :Type), (:(::), :dims, :Tuple)), (:block,
                (:line, 263, :none),
                (:call, :fill!, (:call, (:curly, :Array, :T), (:call, :Dims, :dims)), (:call, (:$, :felt), :T))
              )),
            (:line, 264, :none),
            (:(=), (:call, (:$, :fname), (:(::), :dims, :Tuple)), (:block,
                (:line, 264, :none),
                (:call, (:$, :fname), :Float64, :dims)
              )),
            (:line, 265, :none),
            (:(=), (:call, (:$, :fname), (:(::), :T, :Type), (:..., :dims)), (:block,
                (:line, 265, :none),
                (:call, (:$, :fname), :T, :dims)
              )),
            (:line, 266, :none),
            (:(=), (:call, (:$, :fname), (:..., :dims)), (:block,
                (:line, 266, :none),
                (:call, (:$, :fname), :dims)
              ))
          ))
      )),
    (:line, 270, :none),
    (:macrocall, :(Core.@doc), "    eye([T::Type=Float64,] m::Integer, n::Integer)\n\n`m`-by-`n` identity matrix.\nThe default element type is [`Float64`](@ref).\n", (:function, (:where, (:call, :eye, (:(::), (:curly, :Type, :T)), (:(::), :m, :Integer), (:(::), :n, :Integer)), :T), (:block,
          (:line, 277, :none),
          (:(=), :a, (:call, :zeros, :T, :m, :n)),
          (:line, 278, :none),
          (:for, (:(=), :i, (:(:), 1, (:call, :min, :m, :n))), (:block,
              (:line, 279, :none),
              (:(=), (:ref, :a, :i, :i), (:call, :oneunit, :T))
            )),
          (:line, 281, :none),
          (:return, :a)
        ))),
    (:line, 284, :none),
    (:macrocall, :(Core.@doc), "    eye(m, n)\n\n`m`-by-`n` identity matrix.\n", (:(=), (:call, :eye, (:(::), :m, :Integer), (:(::), :n, :Integer)), (:block,
          (:line, 289, :none),
          (:call, :eye, :Float64, :m, :n)
        ))),
    (:line, 290, :none),
    (:(=), (:where, (:call, :eye, (:(::), (:curly, :Type, :T)), (:(::), :n, :Integer)), :T), (:block,
        (:line, 290, :none),
        (:call, :eye, :T, :n, :n)
      )),
    (:line, 291, :none),
    (:macrocall, :(Core.@doc), "    eye([T::Type=Float64,] n::Integer)\n\n`n`-by-`n` identity matrix.\nThe default element type is [`Float64`](@ref).\n", (:(=), (:call, :eye, (:(::), :n, :Integer)), (:block,
          (:line, 297, :none),
          (:call, :eye, :Float64, :n)
        ))),
    (:line, 299, :none),
    (:macrocall, :(Core.@doc), "    eye(A)\n\nConstructs an identity matrix of the same dimensions and type as `A`.\n\n```jldoctest\njulia> A = [1 2 3; 4 5 6; 7 8 9]\n3×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> eye(A)\n3×3 Array{Int64,2}:\n 1  0  0\n 0  1  0\n 0  0  1\n```\n\nNote the difference from [`ones`](@ref).\n", (:(=), (:where, (:call, :eye, (:(::), :x, (:curly, :AbstractMatrix, :T))), :T), (:block,
          (:line, 320, :none),
          (:call, :eye, (:call, :typeof, (:call, :one, :T)), (:call, :size, :x, 1), (:call, :size, :x, 2))
        ))),
    (:line, 322, :none),
    (:function, (:where, (:call, :_one, (:(::), :unit, :T), (:(::), :x, :AbstractMatrix)), :T), (:block,
        (:line, 323, :none),
        (:(=), (:tuple, :m, :n), (:call, :size, :x)),
        (:line, 324, :none),
        (:||, (:call, :(==), :m, :n), (:call, :throw, (:call, :DimensionMismatch, "multiplicative identity defined only for square matrices"))),
        (:line, 325, :none),
        (:call, :eye, :T, :m)
      )),
    (:line, 328, :none),
    (:(=), (:where, (:call, :one, (:(::), :x, (:curly, :AbstractMatrix, :T))), :T), (:block,
        (:line, 328, :none),
        (:call, :_one, (:call, :one, :T), :x)
      )),
    (:line, 329, :none),
    (:(=), (:where, (:call, :oneunit, (:(::), :x, (:curly, :AbstractMatrix, :T))), :T), (:block,
        (:line, 329, :none),
        (:call, :_one, (:call, :oneunit, :T), :x)
      )),
    (:line, 333, :none),
    (:(=), (:where, (:call, :convert, (:(::), (:curly, :Type, :Vector)), (:(::), :x, (:curly, :AbstractVector, :T))), :T), (:block,
        (:line, 333, :none),
        (:call, :convert, (:curly, :Vector, :T), :x)
      )),
    (:line, 334, :none),
    (:(=), (:where, (:call, :convert, (:(::), (:curly, :Type, :Matrix)), (:(::), :x, (:curly, :AbstractMatrix, :T))), :T), (:block,
        (:line, 334, :none),
        (:call, :convert, (:curly, :Matrix, :T), :x)
      )),
    (:line, 336, :none),
    (:(=), (:where, (:call, :convert, (:(::), (:curly, :Type, (:curly, :Array, :T))), (:(::), :x, (:curly, :Array, :T, :n))), :T, :n), (:block,
        (:line, 336, :none),
        :x
      )),
    (:line, 337, :none),
    (:(=), (:where, (:call, :convert, (:(::), (:curly, :Type, (:curly, :Array, :T, :n))), (:(::), :x, (:curly, :Array, :T, :n))), :T, :n), (:block,
        (:line, 337, :none),
        :x
      )),
    (:line, 339, :none),
    (:(=), (:where, (:call, :convert, (:(::), (:curly, :Type, (:curly, :Array, :T))), (:(::), :x, (:curly, :AbstractArray, :S, :n))), :T, :n, :S), (:block,
        (:line, 339, :none),
        (:call, :convert, (:curly, :Array, :T, :n), :x)
      )),
    (:line, 340, :none),
    (:(=), (:where, (:call, :convert, (:(::), (:curly, :Type, (:curly, :Array, :T, :n))), (:(::), :x, (:curly, :AbstractArray, :S, :n))), :T, :n, :S), (:block,
        (:line, 340, :none),
        (:call, :copy!, (:call, (:curly, :Array, :T, :n), (:call, :size, :x)), :x)
      )),
    (:line, 342, :none),
    (:(=), (:where, (:call, :promote_rule, (:(::), (:curly, :Type, (:curly, :Array, :T, :n))), (:(::), (:curly, :Type, (:curly, :Array, :S, :n)))), :T, :n, :S), (:block,
        (:line, 342, :none),
        (:curly, :Array, (:call, :promote_type, :T, :S), :n)
      )),
    (:line, 346, :none),
    (:macrocall, :(Core.@doc), "    collect(element_type, collection)\n\nReturn an `Array` with the given element type of all items in a collection or iterable.\nThe result has the same shape and number of dimensions as `collection`.\n\n```jldoctest\njulia> collect(Float64, 1:2:5)\n3-element Array{Float64,1}:\n 1.0\n 3.0\n 5.0\n```\n", (:(=), (:where, (:call, :collect, (:(::), (:curly, :Type, :T)), :itr), :T), (:block,
          (:line, 360, :none),
          (:call, :_collect, :T, :itr, (:call, :iteratorsize, :itr))
        ))),
    (:line, 362, :none),
    (:(=), (:where, (:call, :_collect, (:(::), (:curly, :Type, :T)), :itr, (:(::), :isz, :HasLength)), :T), (:block,
        (:line, 362, :none),
        (:call, :copy!, (:call, (:curly, :Array, :T, 1), (:call, :Int, (:(::), (:call, :length, :itr), :Integer))), :itr)
      )),
    (:line, 363, :none),
    (:(=), (:where, (:call, :_collect, (:(::), (:curly, :Type, :T)), :itr, (:(::), :isz, :HasShape)), :T), (:block,
        (:line, 363, :none),
        (:call, :copy!, (:call, :similar, (:curly, :Array, :T), (:call, :indices, :itr)), :itr)
      )),
    (:line, 364, :none),
    (:function, (:where, (:call, :_collect, (:(::), (:curly, :Type, :T)), :itr, (:(::), :isz, :SizeUnknown)), :T), (:block,
        (:line, 365, :none),
        (:(=), :a, (:call, (:curly, :Array, :T, 1), 0)),
        (:line, 366, :none),
        (:for, (:(=), :x, :itr), (:block,
            (:line, 367, :none),
            (:call, :push!, :a, :x)
          )),
        (:line, 369, :none),
        (:return, :a)
      )),
    (:line, 373, :none),
    (:(=), (:call, :_similar_for, (:(::), :c, :AbstractArray), :T, :itr, (:(::), :SizeUnknown)), (:block,
        (:line, 373, :none),
        (:call, :similar, :c, :T, 0)
      )),
    (:line, 374, :none),
    (:(=), (:call, :_similar_for, (:(::), :c, :AbstractArray), :T, :itr, (:(::), :HasLength)), (:block,
        (:line, 374, :none),
        (:call, :similar, :c, :T, (:call, :Int, (:(::), (:call, :length, :itr), :Integer)))
      )),
    (:line, 375, :none),
    (:(=), (:call, :_similar_for, (:(::), :c, :AbstractArray), :T, :itr, (:(::), :HasShape)), (:block,
        (:line, 375, :none),
        (:call, :similar, :c, :T, (:call, :indices, :itr))
      )),
    (:line, 376, :none),
    (:(=), (:call, :_similar_for, :c, :T, :itr, :isz), (:block,
        (:line, 376, :none),
        (:call, :similar, :c, :T)
      )),
    (:line, 378, :none),
    (:macrocall, :(Core.@doc), "    collect(collection)\n\nReturn an `Array` of all items in a collection or iterator. For associative collections, returns\n`Pair{KeyType, ValType}`. If the argument is array-like or is an iterator with the `HasShape()`\ntrait, the result will have the same shape and number of dimensions as the argument.\n\n```jldoctest\njulia> collect(1:2:13)\n7-element Array{Int64,1}:\n  1\n  3\n  5\n  7\n  9\n 11\n 13\n```\n", (:(=), (:call, :collect, :itr), (:block,
          (:line, 397, :none),
          (:call, :_collect, (:(:), 1, 1), :itr, (:call, :iteratoreltype, :itr), (:call, :iteratorsize, :itr))
        ))),
    (:line, 399, :none),
    (:(=), (:call, :collect, (:(::), :A, :AbstractArray)), (:block,
        (:line, 399, :none),
        (:call, :_collect_indices, (:call, :indices, :A), :A)
      )),
    (:line, 401, :none),
    (:(=), (:call, :collect_similar, :cont, :itr), (:block,
        (:line, 401, :none),
        (:call, :_collect, :cont, :itr, (:call, :iteratoreltype, :itr), (:call, :iteratorsize, :itr))
      )),
    (:line, 403, :none),
    (:(=), (:call, :_collect, :cont, :itr, (:(::), :HasEltype), (:(::), :isz, (:curly, :Union, :HasLength, :HasShape))), (:block,
        (:line, 403, :none),
        (:call, :copy!, (:call, :_similar_for, :cont, (:call, :eltype, :itr), :itr, :isz), :itr)
      )),
    (:line, 406, :none),
    (:function, (:call, :_collect, :cont, :itr, (:(::), :HasEltype), (:(::), :isz, :SizeUnknown)), (:block,
        (:line, 407, :none),
        (:(=), :a, (:call, :_similar_for, :cont, (:call, :eltype, :itr), :itr, :isz)),
        (:line, 408, :none),
        (:for, (:(=), :x, :itr), (:block,
            (:line, 409, :none),
            (:call, :push!, :a, :x)
          )),
        (:line, 411, :none),
        (:return, :a)
      )),
    (:line, 414, :none),
    (:(=), (:call, :_collect_indices, (:(::), (:curly, :Tuple)), :A), (:block,
        (:line, 414, :none),
        (:call, :copy!, (:call, (:curly, :Vector, (:call, :eltype, :A))), :A)
      )),
    (:line, 415, :none),
    (:(=), (:call, :_collect_indices, (:(::), :indsA, (:curly, :Tuple, (:curly, :Vararg, :OneTo))), :A), (:block,
        (:line, 415, :none),
        (:call, :copy!, (:call, (:curly, :Array, (:call, :eltype, :A)), (:., :length, (:tuple, :indsA))), :A)
      )),
    (:line, 417, :none),
    (:function, (:call, :_collect_indices, :indsA, :A), (:block,
        (:line, 418, :none),
        (:(=), :B, (:call, (:curly, :Array, (:call, :eltype, :A)), (:., :length, (:tuple, :indsA)))),
        (:line, 419, :none),
        (:call, :copy!, :B, (:call, :CartesianRange, (:call, :indices, :B)), :A, (:call, :CartesianRange, :indsA))
      )),
    (:line, 422, :none),
    (:if, (:call, :isdefined, :Core, (:quote, #QuoteNode
          :Inference
        )), (:block,
        (:line, 423, :none),
        (:(=), (:call, :_default_eltype, (:(::), :itrt, :ANY)), (:block,
            (:line, 423, :none),
            (:call, (:., (:., :Core, (:quote, #QuoteNode
                    :Inference
                  )), (:quote, #QuoteNode
                  :return_type
                )), :first, (:curly, :Tuple, :itrt))
          ))
      ), (:block,
        (:line, 425, :none),
        (:(=), (:call, :_default_eltype, (:(::), :itr, :ANY)), (:block,
            (:line, 425, :none),
            :Any
          ))
      )),
    (:line, 428, :none),
    (:(=), (:where, (:call, :_array_for, (:(::), (:curly, :Type, :T)), :itr, (:(::), :HasLength)), :T), (:block,
        (:line, 428, :none),
        (:call, (:curly, :Array, :T, 1), (:call, :Int, (:(::), (:call, :length, :itr), :Integer)))
      )),
    (:line, 429, :none),
    (:(=), (:where, (:call, :_array_for, (:(::), (:curly, :Type, :T)), :itr, (:(::), :HasShape)), :T), (:block,
        (:line, 429, :none),
        (:call, :similar, (:curly, :Array, :T), (:call, :indices, :itr))
      )),
    (:line, 431, :none),
    (:function, (:call, :collect, (:(::), :itr, :Generator)), (:block,
        (:line, 432, :none),
        (:(=), :isz, (:call, :iteratorsize, (:., :itr, (:quote, #QuoteNode
                :iter
              )))),
        (:line, 433, :none),
        (:(=), :et, (:call, :_default_eltype, (:call, :typeof, :itr))),
        (:line, 434, :none),
        (:if, (:call, :isa, :isz, :SizeUnknown), (:block,
            (:line, 435, :none),
            (:return, (:call, :grow_to!, (:call, (:curly, :Array, :et, 1), 0), :itr))
          ), (:block,
            (:line, 437, :none),
            (:(=), :st, (:call, :start, :itr)),
            (:line, 438, :none),
            (:if, (:call, :done, :itr, :st), (:block,
                (:line, 439, :none),
                (:return, (:call, :_array_for, :et, (:., :itr, (:quote, #QuoteNode
                        :iter
                      )), :isz))
              )),
            (:line, 441, :none),
            (:(=), (:tuple, :v1, :st), (:call, :next, :itr, :st)),
            (:line, 442, :none),
            (:call, :collect_to_with_first!, (:call, :_array_for, (:call, :typeof, :v1), (:., :itr, (:quote, #QuoteNode
                    :iter
                  )), :isz), :v1, :itr, :st)
          ))
      )),
    (:line, 446, :none),
    (:(=), (:call, :_collect, :c, :itr, (:(::), :EltypeUnknown), (:(::), :isz, :SizeUnknown)), (:block,
        (:line, 446, :none),
        (:call, :grow_to!, (:call, :_similar_for, :c, (:call, :_default_eltype, (:call, :typeof, :itr)), :itr, :isz), :itr)
      )),
    (:line, 449, :none),
    (:function, (:call, :_collect, :c, :itr, (:(::), :EltypeUnknown), (:(::), :isz, (:curly, :Union, :HasLength, :HasShape))), (:block,
        (:line, 450, :none),
        (:(=), :st, (:call, :start, :itr)),
        (:line, 451, :none),
        (:if, (:call, :done, :itr, :st), (:block,
            (:line, 452, :none),
            (:return, (:call, :_similar_for, :c, (:call, :_default_eltype, (:call, :typeof, :itr)), :itr, :isz))
          )),
        (:line, 454, :none),
        (:(=), (:tuple, :v1, :st), (:call, :next, :itr, :st)),
        (:line, 455, :none),
        (:call, :collect_to_with_first!, (:call, :_similar_for, :c, (:call, :typeof, :v1), :itr, :isz), :v1, :itr, :st)
      )),
    (:line, 458, :none),
    (:function, (:call, :collect_to_with_first!, (:(::), :dest, :AbstractArray), :v1, :itr, :st), (:block,
        (:line, 459, :none),
        (:(=), :i1, (:call, :first, (:call, :linearindices, :dest))),
        (:line, 460, :none),
        (:(=), (:ref, :dest, :i1), :v1),
        (:line, 461, :none),
        (:return, (:call, :collect_to!, :dest, :itr, (:call, :+, :i1, 1), :st))
      )),
    (:line, 464, :none),
    (:function, (:call, :collect_to_with_first!, :dest, :v1, :itr, :st), (:block,
        (:line, 465, :none),
        (:call, :push!, :dest, :v1),
        (:line, 466, :none),
        (:return, (:call, :grow_to!, :dest, :itr, :st))
      )),
    (:line, 469, :none),
    (:function, (:where, (:call, :collect_to!, (:(::), :dest, (:curly, :AbstractArray, :T)), :itr, :offs, :st), :T), (:block,
        (:line, 472, :none),
        (:(=), :i, :offs),
        (:line, 473, :none),
        (:while, (:call, :!, (:call, :done, :itr, :st)), (:block,
            (:line, 474, :none),
            (:(=), (:tuple, :el, :st), (:call, :next, :itr, :st)),
            (:line, 475, :none),
            (:(=), :S, (:call, :typeof, :el)),
            (:line, 476, :none),
            (:if, (:||, (:call, :(===), :S, :T), (:<:, :S, :T)), (:block,
                (:line, 477, :none),
                (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :dest, :i), (:(::), :el, :T))),
                (:line, 478, :none),
                (:+=, :i, 1)
              ), (:block,
                (:line, 480, :none),
                (:(=), :R, (:call, :typejoin, :T, :S)),
                (:line, 481, :none),
                (:(=), :new, (:call, :similar, :dest, :R)),
                (:line, 482, :none),
                (:call, :copy!, :new, 1, :dest, 1, (:call, :-, :i, 1)),
                (:line, 483, :none),
                (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :new, :i), :el)),
                (:line, 484, :none),
                (:return, (:call, :collect_to!, :new, :itr, (:call, :+, :i, 1), :st))
              ))
          )),
        (:line, 487, :none),
        (:return, :dest)
      )),
    (:line, 490, :none),
    (:function, (:call, :grow_to!, :dest, :itr), (:block,
        (:line, 491, :none),
        (:(=), :out, (:call, :grow_to!, (:call, :similar, :dest, (:curly, :Union)), :itr, (:call, :start, :itr))),
        (:line, 492, :none),
        (:return, (:if, (:call, :isempty, :out), :dest, :out))
      )),
    (:line, 495, :none),
    (:function, (:call, :grow_to!, :dest, :itr, :st), (:block,
        (:line, 496, :none),
        (:(=), :T, (:call, :eltype, :dest)),
        (:line, 497, :none),
        (:while, (:call, :!, (:call, :done, :itr, :st)), (:block,
            (:line, 498, :none),
            (:(=), (:tuple, :el, :st), (:call, :next, :itr, :st)),
            (:line, 499, :none),
            (:(=), :S, (:call, :typeof, :el)),
            (:line, 500, :none),
            (:if, (:||, (:call, :(===), :S, :T), (:<:, :S, :T)), (:block,
                (:line, 501, :none),
                (:call, :push!, :dest, (:(::), :el, :T))
              ), (:block,
                (:line, 503, :none),
                (:(=), :new, (:call, :similar, :dest, (:call, :typejoin, :T, :S))),
                (:line, 504, :none),
                (:call, :copy!, :new, :dest),
                (:line, 505, :none),
                (:call, :push!, :new, :el),
                (:line, 506, :none),
                (:return, (:call, :grow_to!, :new, :itr, :st))
              ))
          )),
        (:line, 509, :none),
        (:return, :dest)
      )),
    (:line, 513, :none),
    (:(=), (:call, :start, (:(::), :A, :Array)), (:block,
        (:line, 513, :none),
        1
      )),
    (:line, 514, :none),
    (:(=), (:call, :next, (:(::), :a, :Array), :i), (:block,
        (:line, 514, :none),
        (:block,
          (:macrocall, Symbol("@_propagate_inbounds_meta")),
          (:tuple, (:ref, :a, :i), (:call, :+, :i, 1))
        )
      )),
    (:line, 515, :none),
    (:(=), (:call, :done, (:(::), :a, :Array), :i), (:block,
        (:line, 515, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :(==), :i, (:call, :+, (:call, :length, :a), 1))
        )
      )),
    (:line, 520, :none),
    (:(=), (:call, :getindex, (:(::), :A, :Array), (:(::), :i1, :Int)), (:block,
        (:line, 520, :none),
        (:call, :arrayref, :A, :i1)
      )),
    (:line, 521, :none),
    (:(=), (:call, :getindex, (:(::), :A, :Array), (:(::), :i1, :Int), (:(::), :i2, :Int), (:..., (:(::), :I, :Int))), (:block,
        (:line, 521, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :arrayref, :A, :i1, :i2, (:..., :I))
        )
      )),
    (:line, 524, :none),
    (:function, (:call, :getindex, (:(::), :A, :Array), (:(::), :I, (:curly, :UnitRange, :Int))), (:block,
        (:line, 525, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 526, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, :I)),
        (:line, 527, :none),
        (:(=), :lI, (:call, :length, :I)),
        (:line, 528, :none),
        (:(=), :X, (:call, :similar, :A, :lI)),
        (:line, 529, :none),
        (:if, (:call, :>, :lI, 0), (:block,
            (:line, 530, :none),
            (:call, :unsafe_copy!, :X, 1, :A, (:call, :first, :I), :lI)
          )),
        (:line, 532, :none),
        (:return, :X)
      )),
    (:line, 534, :none),
    (:function, (:call, :getindex, (:(::), :A, :Array), (:(::), :c, :Colon)), (:block,
        (:line, 535, :none),
        (:(=), :lI, (:call, :length, :A)),
        (:line, 536, :none),
        (:(=), :X, (:call, :similar, :A, :lI)),
        (:line, 537, :none),
        (:if, (:call, :>, :lI, 0), (:block,
            (:line, 538, :none),
            (:call, :unsafe_copy!, :X, 1, :A, 1, :lI)
          )),
        (:line, 540, :none),
        (:return, :X)
      )),
    (:line, 544, :none),
    (:function, (:where, (:call, :getindex, (:(::), :A, (:curly, :Array, :S)), (:(::), :I, (:curly, :Range, :Int))), :S), (:block,
        (:line, 545, :none),
        (:return, (:typed_comprehension, :S, (:generator, (:ref, :A, :i), (:(=), :i, :I))))
      )),
    (:line, 549, :none),
    (:(=), (:where, (:call, :setindex!, (:(::), :A, (:curly, :Array, :T)), :x, (:(::), :i1, :Int)), :T), (:block,
        (:line, 549, :none),
        (:call, :arrayset, :A, (:(::), (:call, :convert, :T, :x), :T), :i1)
      )),
    (:line, 550, :none),
    (:(=), (:where, (:call, :setindex!, (:(::), :A, (:curly, :Array, :T)), :x, (:(::), :i1, :Int), (:(::), :i2, :Int), (:..., (:(::), :I, :Int))), :T), (:block,
        (:line, 550, :none),
        (:block,
          (:macrocall, Symbol("@_inline_meta")),
          (:call, :arrayset, :A, (:(::), (:call, :convert, :T, :x), :T), :i1, :i2, (:..., :I))
        )
      )),
    (:line, 553, :none),
    (:function, (:call, :setindex!, (:(::), :A, :Array), :x, (:(::), :I, (:curly, :AbstractVector, :Int))), (:block,
        (:line, 554, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 555, :none),
        (:&&, (:call, :(===), :A, :I), (:(=), :I, (:call, :copy, :I))),
        (:line, 556, :none),
        (:for, (:(=), :i, :I), (:block,
            (:line, 557, :none),
            (:(=), (:ref, :A, :i), :x)
          )),
        (:line, 559, :none),
        (:return, :A)
      )),
    (:line, 561, :none),
    (:function, (:call, :setindex!, (:(::), :A, :Array), (:(::), :X, :AbstractArray), (:(::), :I, (:curly, :AbstractVector, :Int))), (:block,
        (:line, 562, :none),
        (:macrocall, Symbol("@_propagate_inbounds_meta")),
        (:line, 563, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :setindex_shape_check, :X, (:call, :length, :I))),
        (:line, 564, :none),
        (:(=), :count, 1),
        (:line, 565, :none),
        (:if, (:call, :(===), :X, :A), (:block,
            (:line, 566, :none),
            (:(=), :X, (:call, :copy, :X)),
            (:line, 567, :none),
            (:&&, (:call, :(===), :I, :A), (:(=), :I, (:(::), :X, (:call, :typeof, :I))))
          ), (:block,
            (:line, 568, :none),
            (:if, (:call, :(===), :I, :A), (:block,
                (:line, 569, :none),
                (:(=), :I, (:call, :copy, :I))
              ))
          )),
        (:line, 571, :none),
        (:for, (:(=), :i, :I), (:block,
            (:line, 572, :none),
            (:macrocall, Symbol("@inbounds"), (:(=), :x, (:ref, :X, :count))),
            (:line, 573, :none),
            (:(=), (:ref, :A, :i), :x),
            (:line, 574, :none),
            (:+=, :count, 1)
          )),
        (:line, 576, :none),
        (:return, :A)
      )),
    (:line, 580, :none),
    (:function, (:where, (:call, :setindex!, (:(::), :A, (:curly, :Array, :T)), (:(::), :X, (:curly, :Array, :T)), (:(::), :I, (:curly, :UnitRange, :Int))), :T), (:block,
        (:line, 581, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 582, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :checkbounds, :A, :I)),
        (:line, 583, :none),
        (:(=), :lI, (:call, :length, :I)),
        (:line, 584, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :setindex_shape_check, :X, :lI)),
        (:line, 585, :none),
        (:if, (:call, :>, :lI, 0), (:block,
            (:line, 586, :none),
            (:call, :unsafe_copy!, :A, (:call, :first, :I), :X, 1, :lI)
          )),
        (:line, 588, :none),
        (:return, :A)
      )),
    (:line, 590, :none),
    (:function, (:where, (:call, :setindex!, (:(::), :A, (:curly, :Array, :T)), (:(::), :X, (:curly, :Array, :T)), (:(::), :c, :Colon)), :T), (:block,
        (:line, 591, :none),
        (:macrocall, Symbol("@_inline_meta")),
        (:line, 592, :none),
        (:(=), :lI, (:call, :length, :A)),
        (:line, 593, :none),
        (:macrocall, Symbol("@boundscheck"), (:call, :setindex_shape_check, :X, :lI)),
        (:line, 594, :none),
        (:if, (:call, :>, :lI, 0), (:block,
            (:line, 595, :none),
            (:call, :unsafe_copy!, :A, 1, :X, 1, :lI)
          )),
        (:line, 597, :none),
        (:return, :A)
      )),
    (:line, 600, :none),
    (:(=), (:call, :setindex!, (:(::), :A, :Array), (:(::), :x, :Number), (:(::), :Colon)), (:block,
        (:line, 600, :none),
        (:call, :fill!, :A, :x)
      )),
    (:line, 601, :none),
    (:(=), (:where, (:call, :setindex!, (:(::), :A, (:curly, :Array, :T, :N)), (:(::), :x, :Number), (:(::), (:curly, :Vararg, :Colon, :N))), :T, :N), (:block,
        (:line, 601, :none),
        (:call, :fill!, :A, :x)
      )),
    (:line, 605, :none),
    (:(=), (:call, :_growat!, (:(::), :a, :Vector), (:(::), :i, :Integer), (:(::), :delta, :Integer)), (:block,
        (:line, 605, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_array_grow_at
          ), :Void, (:tuple, :Any, :Int, :UInt), :a, (:call, :-, :i, 1), :delta)
      )),
    (:line, 610, :none),
    (:(=), (:call, :_deleteat!, (:(::), :a, :Vector), (:(::), :i, :Integer), (:(::), :delta, :Integer)), (:block,
        (:line, 610, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_array_del_at
          ), :Void, (:tuple, :Any, :Int, :UInt), :a, (:call, :-, :i, 1), :delta)
      )),
    (:line, 615, :none),
    (:function, (:where, (:call, :push!, (:(::), :a, (:curly, :Array, :T, 1)), :item), :T), (:block,
        (:line, 617, :none),
        (:(=), :itemT, (:call, :convert, :T, :item)),
        (:line, 618, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_array_grow_end
          ), :Void, (:tuple, :Any, :UInt), :a, 1),
        (:line, 619, :none),
        (:(=), (:ref, :a, :end), :itemT),
        (:line, 620, :none),
        (:return, :a)
      )),
    (:line, 623, :none),
    (:function, (:call, :push!, (:(::), :a, (:curly, :Array, :Any, 1)), (:(::), :item, :ANY)), (:block,
        (:line, 624, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_array_grow_end
          ), :Void, (:tuple, :Any, :UInt), :a, 1),
        (:line, 625, :none),
        (:call, :arrayset, :a, :item, (:call, :length, :a)),
        (:line, 626, :none),
        (:return, :a)
      )),
    (:line, 629, :none),
    (:function, (:call, :append!, (:(::), :a, (:curly, :Array, (:<:, :Any), 1)), (:(::), :items, :AbstractVector)), (:block,
        (:line, 630, :none),
        (:(=), :itemindices, (:call, :eachindex, :items)),
        (:line, 631, :none),
        (:(=), :n, (:call, :length, :itemindices)),
        (:line, 632, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_array_grow_end
          ), :Void, (:tuple, :Any, :UInt), :a, :n),
        (:line, 633, :none),
        (:call, :copy!, :a, (:call, :+, (:call, :-, (:call, :length, :a), :n), 1), :items, (:call, :first, :itemindices), :n),
        (:line, 634, :none),
        (:return, :a)
      )),
    (:line, 637, :none),
    (:(=), (:call, :append!, (:(::), :a, :Vector), :iter), (:block,
        (:line, 637, :none),
        (:call, :_append!, :a, (:call, :iteratorsize, :iter), :iter)
      )),
    (:line, 638, :none),
    (:(=), (:call, :push!, (:(::), :a, :Vector), (:..., :iter)), (:block,
        (:line, 638, :none),
        (:call, :append!, :a, :iter)
      )),
    (:line, 640, :none),
    (:function, (:call, :_append!, :a, (:(::), (:curly, :Union, :HasLength, :HasShape)), :iter), (:block,
        (:line, 641, :none),
        (:(=), :n, (:call, :length, :a)),
        (:line, 642, :none),
        (:call, :resize!, :a, (:call, :+, :n, (:call, :length, :iter))),
        (:line, 643, :none),
        (:macrocall, Symbol("@inbounds"), (:for, (:(=), (:tuple, :i, :item), (:call, :zip, (:(:), (:call, :+, :n, 1), (:call, :length, :a)), :iter)), (:block,
              (:line, 644, :none),
              (:(=), (:ref, :a, :i), :item)
            ))),
        (:line, 646, :none),
        :a
      )),
    (:line, 649, :none),
    (:function, (:call, :_append!, :a, (:(::), :IteratorSize), :iter), (:block,
        (:line, 650, :none),
        (:for, (:(=), :item, :iter), (:block,
            (:line, 651, :none),
            (:call, :push!, :a, :item)
          )),
        (:line, 653, :none),
        :a
      )),
    (:line, 656, :none),
    (:macrocall, :(Core.@doc), "    prepend!(a::Vector, items) -> collection\n\nInsert the elements of `items` to the beginning of `a`.\n\n```jldoctest\njulia> prepend!([3],[1,2])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n```\n", (:function, :prepend!)),
    (:line, 671, :none),
    (:function, (:call, :prepend!, (:(::), :a, (:curly, :Array, (:<:, :Any), 1)), (:(::), :items, :AbstractVector)), (:block,
        (:line, 672, :none),
        (:(=), :itemindices, (:call, :eachindex, :items)),
        (:line, 673, :none),
        (:(=), :n, (:call, :length, :itemindices)),
        (:line, 674, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_array_grow_beg
          ), :Void, (:tuple, :Any, :UInt), :a, :n),
        (:line, 675, :none),
        (:if, (:call, :(===), :a, :items), (:block,
            (:line, 676, :none),
            (:call, :copy!, :a, 1, :items, (:call, :+, :n, 1), :n)
          ), (:block,
            (:line, 678, :none),
            (:call, :copy!, :a, 1, :items, (:call, :first, :itemindices), :n)
          )),
        (:line, 680, :none),
        (:return, :a)
      )),
    (:line, 683, :none),
    (:(=), (:call, :prepend!, (:(::), :a, :Vector), :iter), (:block,
        (:line, 683, :none),
        (:call, :_prepend!, :a, (:call, :iteratorsize, :iter), :iter)
      )),
    (:line, 684, :none),
    (:(=), (:call, :unshift!, (:(::), :a, :Vector), (:..., :iter)), (:block,
        (:line, 684, :none),
        (:call, :prepend!, :a, :iter)
      )),
    (:line, 686, :none),
    (:function, (:call, :_prepend!, :a, (:(::), (:curly, :Union, :HasLength, :HasShape)), :iter), (:block,
        (:line, 687, :none),
        (:(=), :n, (:call, :length, :iter)),
        (:line, 688, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_array_grow_beg
          ), :Void, (:tuple, :Any, :UInt), :a, :n),
        (:line, 689, :none),
        (:(=), :i, 0),
        (:line, 690, :none),
        (:for, (:(=), :item, :iter), (:block,
            (:line, 691, :none),
            (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :a, (:+=, :i, 1)), :item))
          )),
        (:line, 693, :none),
        :a
      )),
    (:line, 695, :none),
    (:function, (:call, :_prepend!, :a, (:(::), :IteratorSize), :iter), (:block,
        (:line, 696, :none),
        (:(=), :n, 0),
        (:line, 697, :none),
        (:for, (:(=), :item, :iter), (:block,
            (:line, 698, :none),
            (:+=, :n, 1),
            (:line, 699, :none),
            (:call, :unshift!, :a, :item)
          )),
        (:line, 701, :none),
        (:call, :reverse!, :a, 1, :n),
        (:line, 702, :none),
        :a
      )),
    (:line, 706, :none),
    (:macrocall, :(Core.@doc), "    resize!(a::Vector, n::Integer) -> Vector\n\nResize `a` to contain `n` elements. If `n` is smaller than the current collection\nlength, the first `n` elements will be retained. If `n` is larger, the new elements are not\nguaranteed to be initialized.\n\n```jldoctest\njulia> resize!([6, 5, 4, 3, 2, 1], 3)\n3-element Array{Int64,1}:\n 6\n 5\n 4\n```\n\n```julia-repl\njulia> resize!([6, 5, 4, 3, 2, 1], 8)\n8-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 2\n 1\n 0\n 0\n```\n", (:function, (:call, :resize!, (:(::), :a, :Vector), (:(::), :nl, :Integer)), (:block,
          (:line, 735, :none),
          (:(=), :l, (:call, :length, :a)),
          (:line, 736, :none),
          (:if, (:call, :>, :nl, :l), (:block,
              (:line, 737, :none),
              (:call, :ccall, (:quote, #QuoteNode
                  :jl_array_grow_end
                ), :Void, (:tuple, :Any, :UInt), :a, (:call, :-, :nl, :l))
            ), (:block,
              (:line, 739, :none),
              (:if, (:call, :<, :nl, 0), (:block,
                  (:line, 740, :none),
                  (:call, :throw, (:call, :ArgumentError, "new length must be ≥ 0"))
                )),
              (:line, 742, :none),
              (:call, :ccall, (:quote, #QuoteNode
                  :jl_array_del_end
                ), :Void, (:tuple, :Any, :UInt), :a, (:call, :-, :l, :nl))
            )),
          (:line, 744, :none),
          (:return, :a)
        ))),
    (:line, 747, :none),
    (:function, (:call, :sizehint!, (:(::), :a, :Vector), (:(::), :sz, :Integer)), (:block,
        (:line, 748, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_array_sizehint
          ), :Void, (:tuple, :Any, :UInt), :a, :sz),
        (:line, 749, :none),
        :a
      )),
    (:line, 752, :none),
    (:function, (:call, :pop!, (:(::), :a, :Vector)), (:block,
        (:line, 753, :none),
        (:if, (:call, :isempty, :a), (:block,
            (:line, 754, :none),
            (:call, :throw, (:call, :ArgumentError, "array must be non-empty"))
          )),
        (:line, 756, :none),
        (:(=), :item, (:ref, :a, :end)),
        (:line, 757, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_array_del_end
          ), :Void, (:tuple, :Any, :UInt), :a, 1),
        (:line, 758, :none),
        (:return, :item)
      )),
    (:line, 761, :none),
    (:macrocall, :(Core.@doc), "    unshift!(collection, items...) -> collection\n\nInsert one or more `items` at the beginning of `collection`.\n\n```jldoctest\njulia> unshift!([1, 2, 3, 4], 5, 6)\n6-element Array{Int64,1}:\n 5\n 6\n 1\n 2\n 3\n 4\n```\n", (:function, (:where, (:call, :unshift!, (:(::), :a, (:curly, :Array, :T, 1)), :item), :T), (:block,
          (:line, 778, :none),
          (:(=), :item, (:call, :convert, :T, :item)),
          (:line, 779, :none),
          (:call, :ccall, (:quote, #QuoteNode
              :jl_array_grow_beg
            ), :Void, (:tuple, :Any, :UInt), :a, 1),
          (:line, 780, :none),
          (:(=), (:ref, :a, 1), :item),
          (:line, 781, :none),
          (:return, :a)
        ))),
    (:line, 784, :none),
    (:function, (:call, :shift!, (:(::), :a, :Vector)), (:block,
        (:line, 785, :none),
        (:if, (:call, :isempty, :a), (:block,
            (:line, 786, :none),
            (:call, :throw, (:call, :ArgumentError, "array must be non-empty"))
          )),
        (:line, 788, :none),
        (:(=), :item, (:ref, :a, 1)),
        (:line, 789, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_array_del_beg
          ), :Void, (:tuple, :Any, :UInt), :a, 1),
        (:line, 790, :none),
        (:return, :item)
      )),
    (:line, 793, :none),
    (:macrocall, :(Core.@doc), "    insert!(a::Vector, index::Integer, item)\n\nInsert an `item` into `a` at the given `index`. `index` is the index of `item` in\nthe resulting `a`.\n\n```jldoctest\njulia> insert!([6, 5, 4, 2, 1], 4, 3)\n6-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 2\n 1\n```\n", (:function, (:where, (:call, :insert!, (:(::), :a, (:curly, :Array, :T, 1)), (:(::), :i, :Integer), :item), :T), (:block,
          (:line, 812, :none),
          (:(=), :_item, (:call, :convert, :T, :item)),
          (:line, 813, :none),
          (:call, :_growat!, :a, :i, 1),
          (:line, 815, :none),
          (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :a, :i), :_item)),
          (:line, 816, :none),
          (:return, :a)
        ))),
    (:line, 819, :none),
    (:macrocall, :(Core.@doc), "    deleteat!(a::Vector, i::Integer)\n\nRemove the item at the given `i` and return the modified `a`. Subsequent items\nare shifted to fill the resulting gap.\n\n```jldoctest\njulia> deleteat!([6, 5, 4, 3, 2, 1], 2)\n5-element Array{Int64,1}:\n 6\n 4\n 3\n 2\n 1\n```\n", (:(=), (:call, :deleteat!, (:(::), :a, :Vector), (:(::), :i, :Integer)), (:block,
          (:line, 835, :none),
          (:block,
            (:call, :_deleteat!, :a, :i, 1),
            :a
          )
        ))),
    (:line, 837, :none),
    (:function, (:call, :deleteat!, (:(::), :a, :Vector), (:(::), :r, (:curly, :UnitRange, (:<:, :Integer)))), (:block,
        (:line, 838, :none),
        (:(=), :n, (:call, :length, :a)),
        (:line, 839, :none),
        (:||, (:call, :isempty, :r), (:call, :_deleteat!, :a, (:call, :first, :r), (:call, :length, :r))),
        (:line, 840, :none),
        (:return, :a)
      )),
    (:line, 843, :none),
    (:macrocall, :(Core.@doc), "    deleteat!(a::Vector, inds)\n\nRemove the items at the indices given by `inds`, and return the modified `a`.\nSubsequent items are shifted to fill the resulting gap.\n\n`inds` can be either an iterator or a collection of sorted and unique integer indices,\nor a boolean vector of the same length as `a` with `true` indicating entries to delete.\n\n```jldoctest\njulia> deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)\n3-element Array{Int64,1}:\n 5\n 3\n 1\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])\n3-element Array{Int64,1}:\n 5\n 3\n 1\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], (2, 2))\nERROR: ArgumentError: indices must be unique and sorted\nStacktrace:\n [1] _deleteat!(::Array{Int64,1}, ::Tuple{Int64,Int64}) at ./array.jl:885\n [2] deleteat!(::Array{Int64,1}, ::Tuple{Int64,Int64}) at ./array.jl:872\n```\n", (:(=), (:call, :deleteat!, (:(::), :a, :Vector), :inds), (:block,
          (:line, 872, :none),
          (:call, :_deleteat!, :a, :inds)
        ))),
    (:line, 873, :none),
    (:(=), (:call, :deleteat!, (:(::), :a, :Vector), (:(::), :inds, :AbstractVector)), (:block,
        (:line, 873, :none),
        (:call, :_deleteat!, :a, (:ref, (:call, :to_indices, :a, (:tuple, :inds)), 1))
      )),
    (:line, 875, :none),
    (:function, (:call, :_deleteat!, (:(::), :a, :Vector), :inds), (:block,
        (:line, 876, :none),
        (:(=), :n, (:call, :length, :a)),
        (:line, 877, :none),
        (:(=), :s, (:call, :start, :inds)),
        (:line, 878, :none),
        (:&&, (:call, :done, :inds, :s), (:return, :a)),
        (:line, 879, :none),
        (:(=), (:tuple, :p, :s), (:call, :next, :inds, :s)),
        (:line, 880, :none),
        (:(=), :q, (:call, :+, :p, 1)),
        (:line, 881, :none),
        (:while, (:call, :!, (:call, :done, :inds, :s)), (:block,
            (:line, 882, :none),
            (:(=), (:tuple, :i, :s), (:call, :next, :inds, :s)),
            (:line, 883, :none),
            (:if, (:call, :!, (:comparison, :q, :(<=), :i, :(<=), :n)), (:block,
                (:line, 884, :none),
                (:if, (:call, :<, :i, :q), (:block,
                    (:line, 885, :none),
                    (:call, :throw, (:call, :ArgumentError, "indices must be unique and sorted"))
                  ), (:block,
                    (:line, 887, :none),
                    (:call, :throw, (:call, :BoundsError))
                  ))
              )),
            (:line, 890, :none),
            (:while, (:call, :<, :q, :i), (:block,
                (:line, 891, :none),
                (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :a, :p), (:ref, :a, :q))),
                (:line, 892, :none),
                (:+=, :p, 1),
                (:line, 892, :none),
                (:+=, :q, 1)
              )),
            (:line, 894, :none),
            (:(=), :q, (:call, :+, :i, 1))
          )),
        (:line, 896, :none),
        (:while, (:call, :(<=), :q, :n), (:block,
            (:line, 897, :none),
            (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :a, :p), (:ref, :a, :q))),
            (:line, 898, :none),
            (:+=, :p, 1),
            (:line, 898, :none),
            (:+=, :q, 1)
          )),
        (:line, 900, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_array_del_end
          ), :Void, (:tuple, :Any, :UInt), :a, (:call, :+, (:call, :-, :n, :p), 1)),
        (:line, 901, :none),
        (:return, :a)
      )),
    (:line, 905, :none),
    (:function, (:call, :deleteat!, (:(::), :a, :Vector), (:(::), :inds, (:curly, :AbstractVector, :Bool))), (:block,
        (:line, 906, :none),
        (:(=), :n, (:call, :length, :a)),
        (:line, 907, :none),
        (:||, (:call, :(==), (:call, :length, :inds), :n), (:call, :throw, (:call, :BoundsError, :a, :inds))),
        (:line, 908, :none),
        (:(=), :p, 1),
        (:line, 909, :none),
        (:for, (:(=), (:tuple, :q, :i), (:call, :enumerate, :inds)), (:block,
            (:line, 910, :none),
            (:macrocall, Symbol("@inbounds"), (:(=), (:ref, :a, :p), (:ref, :a, :q))),
            (:line, 911, :none),
            (:+=, :p, (:call, :!, :i))
          )),
        (:line, 913, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_array_del_end
          ), :Void, (:tuple, :Any, :UInt), :a, (:call, :+, (:call, :-, :n, :p), 1)),
        (:line, 914, :none),
        (:return, :a)
      )),
    (:line, 917, :none),
    (:const, (:(=), :_default_splice, (:vect,))),
    (:line, 919, :none),
    (:macrocall, :(Core.@doc), "    splice!(a::Vector, index::Integer, [replacement]) -> item\n\nRemove the item at the given index, and return the removed item.\nSubsequent items are shifted left to fill the resulting gap.\nIf specified, replacement values from an ordered\ncollection will be spliced in place of the removed item.\n\n```jldoctest splice!\njulia> A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)\n2\n\njulia> A\n5-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 1\n\njulia> splice!(A, 5, -1)\n1\n\njulia> A\n5-element Array{Int64,1}:\n  6\n  5\n  4\n  3\n -1\n\njulia> splice!(A, 1, [-1, -2, -3])\n6\n\njulia> A\n7-element Array{Int64,1}:\n -1\n -2\n -3\n  5\n  4\n  3\n -1\n```\n\nTo insert `replacement` before an index `n` without removing any items, use\n`splice!(collection, n:n-1, replacement)`.\n", (:function, (:call, :splice!, (:(::), :a, :Vector), (:(::), :i, :Integer), (:kw, :ins, :_default_splice)), (:block,
          (:line, 968, :none),
          (:(=), :v, (:ref, :a, :i)),
          (:line, 969, :none),
          (:(=), :m, (:call, :length, :ins)),
          (:line, 970, :none),
          (:if, (:call, :(==), :m, 0), (:block,
              (:line, 971, :none),
              (:call, :_deleteat!, :a, :i, 1)
            ), (:block,
              (:line, 972, :none),
              (:if, (:call, :(==), :m, 1), (:block,
                  (:line, 973, :none),
                  (:(=), (:ref, :a, :i), (:ref, :ins, 1))
                ), (:block,
                  (:line, 975, :none),
                  (:call, :_growat!, :a, :i, (:call, :-, :m, 1)),
                  (:line, 976, :none),
                  (:(=), :k, 1),
                  (:line, 977, :none),
                  (:for, (:(=), :x, :ins), (:block,
                      (:line, 978, :none),
                      (:(=), (:ref, :a, (:call, :-, (:call, :+, :i, :k), 1)), :x),
                      (:line, 979, :none),
                      (:+=, :k, 1)
                    ))
                ))
            )),
          (:line, 982, :none),
          (:return, :v)
        ))),
    (:line, 985, :none),
    (:macrocall, :(Core.@doc), "    splice!(a::Vector, range, [replacement]) -> items\n\nRemove items in the specified index range, and return a collection containing\nthe removed items.\nSubsequent items are shifted left to fill the resulting gap.\nIf specified, replacement values from an ordered collection will be spliced in\nplace of the removed items.\n\nTo insert `replacement` before an index `n` without removing any items, use\n`splice!(collection, n:n-1, replacement)`.\n\n```jldoctest splice!\njulia> splice!(A, 4:3, 2)\n0-element Array{Int64,1}\n\njulia> A\n8-element Array{Int64,1}:\n -1\n -2\n -3\n  2\n  5\n  4\n  3\n -1\n```\n", (:function, (:call, :splice!, (:(::), :a, :Vector), (:(::), :r, (:curly, :UnitRange, (:<:, :Integer))), (:kw, :ins, :_default_splice)), (:block,
          (:line, 1014, :none),
          (:(=), :v, (:ref, :a, :r)),
          (:line, 1015, :none),
          (:(=), :m, (:call, :length, :ins)),
          (:line, 1016, :none),
          (:if, (:call, :(==), :m, 0), (:block,
              (:line, 1017, :none),
              (:call, :deleteat!, :a, :r),
              (:line, 1018, :none),
              (:return, :v)
            )),
          (:line, 1021, :none),
          (:(=), :n, (:call, :length, :a)),
          (:line, 1022, :none),
          (:(=), :f, (:call, :first, :r)),
          (:line, 1023, :none),
          (:(=), :l, (:call, :last, :r)),
          (:line, 1024, :none),
          (:(=), :d, (:call, :length, :r)),
          (:line, 1026, :none),
          (:if, (:call, :<, :m, :d), (:block,
              (:line, 1027, :none),
              (:(=), :delta, (:call, :-, :d, :m)),
              (:line, 1028, :none),
              (:call, :_deleteat!, :a, (:if, (:call, :<, (:call, :-, :f, 1), (:call, :-, :n, :l)), :f, (:call, :+, (:call, :-, :l, :delta), 1)), :delta)
            ), (:block,
              (:line, 1029, :none),
              (:if, (:call, :>, :m, :d), (:block,
                  (:line, 1030, :none),
                  (:call, :_growat!, :a, (:if, (:call, :<, (:call, :-, :f, 1), (:call, :-, :n, :l)), :f, (:call, :+, :l, 1)), (:call, :-, :m, :d))
                ))
            )),
          (:line, 1033, :none),
          (:(=), :k, 1),
          (:line, 1034, :none),
          (:for, (:(=), :x, :ins), (:block,
              (:line, 1035, :none),
              (:(=), (:ref, :a, (:call, :-, (:call, :+, :f, :k), 1)), :x),
              (:line, 1036, :none),
              (:+=, :k, 1)
            )),
          (:line, 1038, :none),
          (:return, :v)
        ))),
    (:line, 1041, :none),
    (:function, (:call, :empty!, (:(::), :a, :Vector)), (:block,
        (:line, 1042, :none),
        (:call, :ccall, (:quote, #QuoteNode
            :jl_array_del_end
          ), :Void, (:tuple, :Any, :UInt), :a, (:call, :length, :a)),
        (:line, 1043, :none),
        (:return, :a)
      )),
    (:line, 1047, :none),
    (:function, (:call, :lexcmp, (:(::), :a, (:curly, :Array, :UInt8, 1)), (:(::), :b, (:curly, :Array, :UInt8, 1))), (:block,
        (:line, 1048, :none),
        (:(=), :c, (:call, :ccall, (:quote, #QuoteNode
              :memcmp
            ), :Int32, (:tuple, (:curly, :Ptr, :UInt8), (:curly, :Ptr, :UInt8), :UInt), :a, :b, (:call, :min, (:call, :length, :a), (:call, :length, :b)))),
        (:line, 1050, :none),
        (:return, (:if, (:call, :<, :c, 0), -1, (:if, (:call, :>, :c, 0), 1, (:call, :cmp, (:call, :length, :a), (:call, :length, :b)))))
      )),
    (:line, 1054, :none),
    (:function, (:where, (:where, (:call, :(==), (:(::), :a, (:curly, :Array, :T, :N)), (:(::), :b, (:curly, :Array, :T, :N))), (:<:, :T, :BitInteger)), :N), (:block,
        (:line, 1055, :none),
        (:&&, (:call, :(==), (:call, :size, :a), (:call, :size, :b)), (:call, :(==), 0, (:call, :ccall, (:quote, #QuoteNode
                :memcmp
              ), :Int32, (:tuple, (:curly, :Ptr, :T), (:curly, :Ptr, :T), :UInt), :a, :b, (:call, :*, (:call, :sizeof, :T), (:call, :length, :a)))))
      )),
    (:line, 1060, :none),
    (:function, (:where, (:call, :(==), (:(::), :a, (:curly, :Array, :T, 1)), (:(::), :b, (:curly, :Array, :T, 1))), (:<:, :T, :BitInteger)), (:block,
        (:line, 1061, :none),
        (:(=), :len, (:call, :length, :a)),
        (:line, 1062, :none),
        (:&&, (:call, :(==), :len, (:call, :length, :b)), (:call, :(==), 0, (:call, :ccall, (:quote, #QuoteNode
                :memcmp
              ), :Int32, (:tuple, (:curly, :Ptr, :T), (:curly, :Ptr, :T), :UInt), :a, :b, (:call, :*, (:call, :sizeof, :T), :len))))
      )),
    (:line, 1066, :none),
    (:function, (:call, :reverse, (:(::), :A, :AbstractVector), (:kw, :s, (:call, :first, (:call, :linearindices, :A))), (:kw, :n, (:call, :last, (:call, :linearindices, :A)))), (:block,
        (:line, 1067, :none),
        (:(=), :B, (:call, :similar, :A)),
        (:line, 1068, :none),
        (:for, (:(=), :i, (:(:), (:call, :first, (:call, :linearindices, :A)), (:call, :-, :s, 1))), (:block,
            (:line, 1069, :none),
            (:(=), (:ref, :B, :i), (:ref, :A, :i))
          )),
        (:line, 1071, :none),
        (:for, (:(=), :i, (:(:), :s, :n)), (:block,
            (:line, 1072, :none),
            (:(=), (:ref, :B, :i), (:ref, :A, (:call, :-, (:call, :+, :n, :s), :i)))
          )),
        (:line, 1074, :none),
        (:for, (:(=), :i, (:(:), (:call, :+, :n, 1), (:call, :last, (:call, :linearindices, :A)))), (:block,
            (:line, 1075, :none),
            (:(=), (:ref, :B, :i), (:ref, :A, :i))
          )),
        (:line, 1077, :none),
        (:return, :B)
      )),
    (:line, 1079, :none),
    (:function, (:call, :reverseind, (:(::), :a, :AbstractVector), (:(::), :i, :Integer)), (:block,
        (:line, 1080, :none),
        (:(=), :li, (:call, :linearindices, :a)),
        (:line, 1081, :none),
        (:call, :-, (:call, :+, (:call, :first, :li), (:call, :last, :li)), :i)
      )),
    (:line, 1084, :none),
    (:function, (:call, :reverse!, (:(::), :v, :AbstractVector), (:kw, :s, (:call, :first, (:call, :linearindices, :v))), (:kw, :n, (:call, :last, (:call, :linearindices, :v)))), (:block,
        (:line, 1085, :none),
        (:(=), :liv, (:call, :linearindices, :v)),
        (:line, 1086, :none),
        (:if, (:call, :(<=), :n, :s), (:block,), (:block,
            (:line, 1087, :none),
            (:if, (:call, :!, (:comparison, (:call, :first, :liv), :≤, :s, :≤, (:call, :last, :liv))), (:block,
                (:line, 1088, :none),
                (:call, :throw, (:call, :BoundsError, :v, :s))
              ), (:block,
                (:line, 1089, :none),
                (:if, (:call, :!, (:comparison, (:call, :first, :liv), :≤, :n, :≤, (:call, :last, :liv))), (:block,
                    (:line, 1090, :none),
                    (:call, :throw, (:call, :BoundsError, :v, :n))
                  ))
              ))
          )),
        (:line, 1092, :none),
        (:(=), :r, :n),
        (:line, 1093, :none),
        (:macrocall, Symbol("@inbounds"), (:for, (:(=), :i, (:(:), :s, (:call, :div, (:call, :-, (:call, :+, :s, :n), 1), 2))), (:block,
              (:line, 1094, :none),
              (:(=), (:tuple, (:ref, :v, :i), (:ref, :v, :r)), (:tuple, (:ref, :v, :r), (:ref, :v, :i))),
              (:line, 1095, :none),
              (:-=, :r, 1)
            ))),
        (:line, 1097, :none),
        (:return, :v)
      )),
    (:line, 1103, :none),
    (:(=), (:call, :vcat), (:block,
        (:line, 1103, :none),
        (:call, (:curly, :Array, :Any, 1), 0)
      )),
    (:line, 1104, :none),
    (:(=), (:call, :hcat), (:block,
        (:line, 1104, :none),
        (:call, (:curly, :Array, :Any, 1), 0)
      )),
    (:line, 1106, :none),
    (:function, (:where, (:call, :hcat, (:..., (:(::), :V, (:curly, :Vector, :T)))), :T), (:block,
        (:line, 1107, :none),
        (:(=), :height, (:call, :length, (:ref, :V, 1))),
        (:line, 1108, :none),
        (:for, (:(=), :j, (:(:), 2, (:call, :length, :V))), (:block,
            (:line, 1109, :none),
            (:if, (:call, :(!=), (:call, :length, (:ref, :V, :j)), :height), (:block,
                (:line, 1110, :none),
                (:call, :throw, (:call, :DimensionMismatch, "vectors must have same lengths"))
              ))
          )),
        (:line, 1113, :none),
        (:return, (:comprehension, (:generator, (:(::), (:ref, (:ref, :V, :j), :i), :T), (:(=), :i, (:(:), 1, (:call, :length, (:ref, :V, 1)))), (:(=), :j, (:(:), 1, (:call, :length, :V))))))
      )),
    (:line, 1116, :none),
    (:function, (:where, (:call, :vcat, (:..., (:(::), :arrays, (:curly, :Vector, :T)))), :T), (:block,
        (:line, 1117, :none),
        (:(=), :n, 0),
        (:line, 1118, :none),
        (:for, (:(=), :a, :arrays), (:block,
            (:line, 1119, :none),
            (:+=, :n, (:call, :length, :a))
          )),
        (:line, 1121, :none),
        (:(=), :arr, (:call, (:curly, :Array, :T, 1), :n)),
        (:line, 1122, :none),
        (:(=), :ptr, (:call, :pointer, :arr)),
        (:line, 1123, :none),
        (:if, (:call, :isbits, :T), (:block,
            (:line, 1124, :none),
            (:(=), :elsz, (:call, (:., :Core, (:quote, #QuoteNode
                    :sizeof
                  )), :T))
          ), (:block,
            (:line, 1126, :none),
            (:(=), :elsz, (:call, (:., :Core, (:quote, #QuoteNode
                    :sizeof
                  )), (:curly, :Ptr, :Void)))
          )),
        (:line, 1128, :none),
        (:for, (:(=), :a, :arrays), (:block,
            (:line, 1129, :none),
            (:(=), :na, (:call, :length, :a)),
            (:line, 1130, :none),
            (:(=), :nba, (:call, :*, :na, :elsz)),
            (:line, 1131, :none),
            (:if, (:call, :isbits, :T), (:block,
                (:line, 1132, :none),
                (:call, :ccall, (:quote, #QuoteNode
                    :memcpy
                  ), (:curly, :Ptr, :Void), (:tuple, (:curly, :Ptr, :Void), (:curly, :Ptr, :Void), :UInt), :ptr, :a, :nba)
              ), (:block,
                (:line, 1135, :none),
                (:call, :ccall, (:quote, #QuoteNode
                    :jl_array_ptr_copy
                  ), :Void, (:tuple, :Any, (:curly, :Ptr, :Void), :Any, (:curly, :Ptr, :Void), :Int), :arr, :ptr, :a, (:call, :pointer, :a), :na)
              )),
            (:line, 1138, :none),
            (:+=, :ptr, :nba)
          )),
        (:line, 1140, :none),
        (:return, :arr)
      )),
    (:line, 1143, :none),
    (:(=), (:call, :cat, (:(::), :n, :Integer), (:..., (:(::), :x, :Integer))), (:block,
        (:line, 1143, :none),
        (:call, :reshape, (:vect, (:..., :x)), (:tuple, (:..., (:call, :ntuple, (:->, :x, (:block,
                    (:line, 1143, :none),
                    1
                  )), (:call, :-, :n, 1))), (:call, :length, :x)))
      )),
    (:line, 1148, :none),
    (:macrocall, :(Core.@doc), "    findnext(A, i::Integer)\n\nFind the next linear index >= `i` of a non-zero element of `A`, or `0` if not found.\n\n```jldoctest\njulia> A = [0 0; 1 0]\n2×2 Array{Int64,2}:\n 0  0\n 1  0\n\njulia> findnext(A,1)\n2\n\njulia> findnext(A,3)\n0\n```\n", (:function, (:call, :findnext, :A, (:(::), :start, :Integer)), (:block,
          (:line, 1167, :none),
          (:for, (:(=), :i, (:(:), :start, (:call, :length, :A))), (:block,
              (:line, 1168, :none),
              (:if, (:call, :(!=), (:ref, :A, :i), 0), (:block,
                  (:line, 1169, :none),
                  (:return, :i)
                ))
            )),
          (:line, 1172, :none),
          (:return, 0)
        ))),
    (:line, 1175, :none),
    (:macrocall, :(Core.@doc), "    findfirst(A)\n\nReturn the linear index of the first non-zero value in `A` (determined by `A[i]!=0`).\nReturns `0` if no such value is found.\n\n```jldoctest\njulia> A = [0 0; 1 0]\n2×2 Array{Int64,2}:\n 0  0\n 1  0\n\njulia> findfirst(A)\n2\n```\n", (:(=), (:call, :findfirst, :A), (:block,
          (:line, 1191, :none),
          (:call, :findnext, :A, 1)
        ))),
    (:line, 1193, :none),
    (:macrocall, :(Core.@doc), "    findnext(A, v, i::Integer)\n\nFind the next linear index >= `i` of an element of `A` equal to `v` (using `==`), or `0` if not found.\n\n```jldoctest\njulia> A = [1 4; 2 2]\n2×2 Array{Int64,2}:\n 1  4\n 2  2\n\njulia> findnext(A,4,4)\n0\n\njulia> findnext(A,4,3)\n3\n```\n", (:function, (:call, :findnext, :A, :v, (:(::), :start, :Integer)), (:block,
          (:line, 1212, :none),
          (:for, (:(=), :i, (:(:), :start, (:call, :length, :A))), (:block,
              (:line, 1213, :none),
              (:if, (:call, :(==), (:ref, :A, :i), :v), (:block,
                  (:line, 1214, :none),
                  (:return, :i)
                ))
            )),
          (:line, 1217, :none),
          (:return, 0)
        ))),
    (:line, 1219, :none),
    (:macrocall, :(Core.@doc), "    findfirst(A, v)\n\nReturn the linear index of the first element equal to `v` in `A`.\nReturns `0` if `v` is not found.\n\n```jldoctest\njulia> A = [4 6; 2 2]\n2×2 Array{Int64,2}:\n 4  6\n 2  2\n\njulia> findfirst(A,2)\n2\n\njulia> findfirst(A,3)\n0\n```\n", (:(=), (:call, :findfirst, :A, :v), (:block,
          (:line, 1238, :none),
          (:call, :findnext, :A, :v, 1)
        ))),
    (:line, 1240, :none),
    (:macrocall, :(Core.@doc), "    findnext(predicate::Function, A, i::Integer)\n\nFind the next linear index >= `i` of an element of `A` for which `predicate` returns `true`, or `0` if not found.\n\n```jldoctest\njulia> A = [1 4; 2 2]\n2×2 Array{Int64,2}:\n 1  4\n 2  2\n\njulia> findnext(isodd, A, 1)\n1\n\njulia> findnext(isodd, A, 2)\n0\n```\n", (:function, (:call, :findnext, (:(::), :testf, :Function), :A, (:(::), :start, :Integer)), (:block,
          (:line, 1259, :none),
          (:for, (:(=), :i, (:(:), :start, (:call, :length, :A))), (:block,
              (:line, 1260, :none),
              (:if, (:call, :testf, (:ref, :A, :i)), (:block,
                  (:line, 1261, :none),
                  (:return, :i)
                ))
            )),
          (:line, 1264, :none),
          (:return, 0)
        ))),
    (:line, 1267, :none),
    (:macrocall, :(Core.@doc), "    findfirst(predicate::Function, A)\n\nReturn the linear index of the first element of `A` for which `predicate` returns `true`.\nReturns `0` if there is no such element.\n\n```jldoctest\njulia> A = [1 4; 2 2]\n2×2 Array{Int64,2}:\n 1  4\n 2  2\n\njulia> findfirst(iseven, A)\n2\n\njulia> findfirst(x -> x>10, A)\n0\n```\n", (:(=), (:call, :findfirst, (:(::), :testf, :Function), :A), (:block,
          (:line, 1286, :none),
          (:call, :findnext, :testf, :A, 1)
        ))),
    (:line, 1288, :none),
    (:macrocall, :(Core.@doc), "    findprev(A, i::Integer)\n\nFind the previous linear index <= `i` of a non-zero element of `A`, or `0` if not found.\n\n```jldoctest\njulia> A = [0 0; 1 2]\n2×2 Array{Int64,2}:\n 0  0\n 1  2\n\njulia> findprev(A,2)\n2\n\njulia> findprev(A,1)\n0\n```\n", (:function, (:call, :findprev, :A, (:(::), :start, :Integer)), (:block,
          (:line, 1307, :none),
          (:for, (:(=), :i, (:(:), :start, -1, 1)), (:block,
              (:line, 1308, :none),
              (:&&, (:call, :(!=), (:ref, :A, :i), 0), (:return, :i))
            )),
          (:line, 1310, :none),
          (:return, 0)
        ))),
    (:line, 1313, :none),
    (:macrocall, :(Core.@doc), "    findlast(A)\n\nReturn the linear index of the last non-zero value in `A` (determined by `A[i]!=0`).\nReturns `0` if there is no non-zero value in `A`.\n\n```jldoctest\njulia> A = [1 0; 1 0]\n2×2 Array{Int64,2}:\n 1  0\n 1  0\n\njulia> findlast(A)\n2\n\njulia> A = zeros(2,2)\n2×2 Array{Float64,2}:\n 0.0  0.0\n 0.0  0.0\n\njulia> findlast(A)\n0\n```\n", (:(=), (:call, :findlast, :A), (:block,
          (:line, 1337, :none),
          (:call, :findprev, :A, (:call, :length, :A))
        ))),
    (:line, 1339, :none),
    (:macrocall, :(Core.@doc), "    findprev(A, v, i::Integer)\n\nFind the previous linear index <= `i` of an element of `A` equal to `v` (using `==`), or `0` if not found.\n\n```jldoctest\njulia> A = [0 0; 1 2]\n2×2 Array{Int64,2}:\n 0  0\n 1  2\n\njulia> findprev(A, 1, 4)\n2\n\njulia> findprev(A, 1, 1)\n0\n```\n", (:function, (:call, :findprev, :A, :v, (:(::), :start, :Integer)), (:block,
          (:line, 1358, :none),
          (:for, (:(=), :i, (:(:), :start, -1, 1)), (:block,
              (:line, 1359, :none),
              (:&&, (:call, :(==), (:ref, :A, :i), :v), (:return, :i))
            )),
          (:line, 1361, :none),
          (:return, 0)
        ))),
    (:line, 1364, :none),
    (:macrocall, :(Core.@doc), "    findlast(A, v)\n\nReturn the linear index of the last element equal to `v` in `A`.\nReturns `0` if there is no element of `A` equal to `v`.\n\n```jldoctest\njulia> A = [1 2; 2 1]\n2×2 Array{Int64,2}:\n 1  2\n 2  1\n\njulia> findlast(A,1)\n4\n\njulia> findlast(A,2)\n3\n\njulia> findlast(A,3)\n0\n```\n", (:(=), (:call, :findlast, :A, :v), (:block,
          (:line, 1386, :none),
          (:call, :findprev, :A, :v, (:call, :length, :A))
        ))),
    (:line, 1388, :none),
    (:macrocall, :(Core.@doc), "    findprev(predicate::Function, A, i::Integer)\n\nFind the previous linear index <= `i` of an element of `A` for which `predicate` returns `true`, or\n`0` if not found.\n\n```jldoctest\njulia> A = [4 6; 1 2]\n2×2 Array{Int64,2}:\n 4  6\n 1  2\n\njulia> findprev(isodd, A, 1)\n0\n\njulia> findprev(isodd, A, 3)\n2\n```\n", (:function, (:call, :findprev, (:(::), :testf, :Function), :A, (:(::), :start, :Integer)), (:block,
          (:line, 1408, :none),
          (:for, (:(=), :i, (:(:), :start, -1, 1)), (:block,
              (:line, 1409, :none),
              (:&&, (:call, :testf, (:ref, :A, :i)), (:return, :i))
            )),
          (:line, 1411, :none),
          (:return, 0)
        ))),
    (:line, 1414, :none),
    (:macrocall, :(Core.@doc), "    findlast(predicate::Function, A)\n\nReturn the linear index of the last element of `A` for which `predicate` returns `true`.\nReturns `0` if there is no such element.\n\n```jldoctest\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> findlast(isodd, A)\n2\n\njulia> findlast(x -> x > 5, A)\n0\n```\n", (:(=), (:call, :findlast, (:(::), :testf, :Function), :A), (:block,
          (:line, 1433, :none),
          (:call, :findprev, :testf, :A, (:call, :length, :A))
        ))),
    (:line, 1435, :none),
    (:macrocall, :(Core.@doc), "    find(f::Function, A)\n\nReturn a vector `I` of the linear indexes of `A` where `f(A[I])` returns `true`.\nIf there are no such elements of `A`, find returns an empty array.\n\n```jldoctest\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> find(isodd,A)\n2-element Array{Int64,1}:\n 1\n 2\n```\n", (:function, (:call, :find, (:(::), :testf, :Function), :A), (:block,
          (:line, 1456, :none),
          (:(=), :tmpI, (:call, (:curly, :Array, :Int, 1), 0)),
          (:line, 1457, :none),
          (:(=), :inds, (:call, :_index_remapper, :A)),
          (:line, 1458, :none),
          (:for, (:(=), (:tuple, :i, :a), (:call, :enumerate, :A)), (:block,
              (:line, 1459, :none),
              (:if, (:call, :testf, :a), (:block,
                  (:line, 1460, :none),
                  (:call, :push!, :tmpI, (:ref, :inds, :i))
                ))
            )),
          (:line, 1463, :none),
          (:(=), :I, (:call, (:curly, :Array, :Int, 1), (:call, :length, :tmpI))),
          (:line, 1464, :none),
          (:call, :copy!, :I, :tmpI),
          (:line, 1465, :none),
          (:return, :I)
        ))),
    (:line, 1467, :none),
    (:(=), (:call, :_index_remapper, (:(::), :A, :AbstractArray)), (:block,
        (:line, 1467, :none),
        (:call, :linearindices, :A)
      )),
    (:line, 1468, :none),
    (:(=), (:call, :_index_remapper, :iter), (:block,
        (:line, 1468, :none),
        (:call, :OneTo, (:call, :typemax, :Int))
      )),
    (:line, 1470, :none),
    (:macrocall, :(Core.@doc), "    find(A)\n\nReturn a vector of the linear indexes of the non-zeros in `A` (determined by `A[i]!=0`). A\ncommon use of this is to convert a boolean array to an array of indexes of the `true`\nelements. If there are no non-zero elements of `A`, `find` returns an empty array.\n\n```jldoctest\njulia> A = [true false; false true]\n2×2 Array{Bool,2}:\n  true  false\n false   true\n\njulia> find(A)\n2-element Array{Int64,1}:\n 1\n 4\n```\n", (:function, (:call, :find, :A), (:block,
          (:line, 1490, :none),
          (:(=), :nnzA, (:call, :countnz, :A)),
          (:line, 1491, :none),
          (:(=), :I, (:call, (:curly, :Vector, :Int), :nnzA)),
          (:line, 1492, :none),
          (:(=), :count, 1),
          (:line, 1493, :none),
          (:(=), :inds, (:call, :_index_remapper, :A)),
          (:line, 1494, :none),
          (:for, (:(=), (:tuple, :i, :a), (:call, :enumerate, :A)), (:block,
              (:line, 1495, :none),
              (:if, (:call, :(!=), :a, 0), (:block,
                  (:line, 1496, :none),
                  (:(=), (:ref, :I, :count), (:ref, :inds, :i)),
                  (:line, 1497, :none),
                  (:+=, :count, 1)
                ))
            )),
          (:line, 1500, :none),
          (:return, :I)
        ))),
    (:line, 1503, :none),
    (:(=), (:call, :find, (:(::), :x, :Number)), (:block,
        (:line, 1503, :none),
        (:if, (:call, :(==), :x, 0), (:call, (:curly, :Array, :Int, 1), 0), (:vect, 1))
      )),
    (:line, 1504, :none),
    (:(=), (:call, :find, (:(::), :testf, :Function), (:(::), :x, :Number)), (:block,
        (:line, 1504, :none),
        (:if, (:call, :!, (:call, :testf, :x)), (:call, (:curly, :Array, :Int, 1), 0), (:vect, 1))
      )),
    (:line, 1506, :none),
    (:(=), (:call, :findn, (:(::), :A, :AbstractVector)), (:block,
        (:line, 1506, :none),
        (:call, :find, :A)
      )),
    (:line, 1508, :none),
    (:macrocall, :(Core.@doc), "    findn(A)\n\nReturn a vector of indexes for each dimension giving the locations of the non-zeros in `A`\n(determined by `A[i]!=0`).\nIf there are no non-zero elements of `A`, `findn` returns a 2-tuple of empty arrays.\n\n```jldoctest\njulia> A = [1 2 0; 0 0 3; 0 4 0]\n3×3 Array{Int64,2}:\n 1  2  0\n 0  0  3\n 0  4  0\n\njulia> findn(A)\n([1, 1, 3, 2], [1, 2, 2, 3])\n\njulia> A = zeros(2,2)\n2×2 Array{Float64,2}:\n 0.0  0.0\n 0.0  0.0\n\njulia> findn(A)\n(Int64[], Int64[])\n```\n", (:function, (:call, :findn, (:(::), :A, :AbstractMatrix)), (:block,
          (:line, 1535, :none),
          (:(=), :nnzA, (:call, :countnz, :A)),
          (:line, 1536, :none),
          (:(=), :I, (:call, :similar, :A, :Int, :nnzA)),
          (:line, 1537, :none),
          (:(=), :J, (:call, :similar, :A, :Int, :nnzA)),
          (:line, 1538, :none),
          (:(=), :count, 1),
          (:line, 1539, :none),
          (:for, (:block,
              (:(=), :j, (:call, :indices, :A, 2)),
              (:(=), :i, (:call, :indices, :A, 1))
            ), (:block,
              (:line, 1540, :none),
              (:if, (:call, :(!=), (:ref, :A, :i, :j), 0), (:block,
                  (:line, 1541, :none),
                  (:(=), (:ref, :I, :count), :i),
                  (:line, 1542, :none),
                  (:(=), (:ref, :J, :count), :j),
                  (:line, 1543, :none),
                  (:+=, :count, 1)
                ))
            )),
          (:line, 1546, :none),
          (:return, (:tuple, :I, :J))
        ))),
    (:line, 1549, :none),
    (:macrocall, :(Core.@doc), "    findnz(A)\n\nReturn a tuple `(I, J, V)` where `I` and `J` are the row and column indexes of the non-zero\nvalues in matrix `A`, and `V` is a vector of the non-zero values.\n\n```jldoctest\njulia> A = [1 2 0; 0 0 3; 0 4 0]\n3×3 Array{Int64,2}:\n 1  2  0\n 0  0  3\n 0  4  0\n\njulia> findnz(A)\n([1, 1, 3, 2], [1, 2, 2, 3], [1, 2, 4, 3])\n```\n", (:function, (:where, (:call, :findnz, (:(::), :A, (:curly, :AbstractMatrix, :T))), :T), (:block,
          (:line, 1567, :none),
          (:(=), :nnzA, (:call, :countnz, :A)),
          (:line, 1568, :none),
          (:(=), :I, (:call, :zeros, :Int, :nnzA)),
          (:line, 1569, :none),
          (:(=), :J, (:call, :zeros, :Int, :nnzA)),
          (:line, 1570, :none),
          (:(=), :NZs, (:call, (:curly, :Array, :T, 1), :nnzA)),
          (:line, 1571, :none),
          (:(=), :count, 1),
          (:line, 1572, :none),
          (:if, (:call, :>, :nnzA, 0), (:block,
              (:line, 1573, :none),
              (:for, (:block,
                  (:(=), :j, (:call, :indices, :A, 2)),
                  (:(=), :i, (:call, :indices, :A, 1))
                ), (:block,
                  (:line, 1574, :none),
                  (:(=), :Aij, (:ref, :A, :i, :j)),
                  (:line, 1575, :none),
                  (:if, (:call, :(!=), :Aij, 0), (:block,
                      (:line, 1576, :none),
                      (:(=), (:ref, :I, :count), :i),
                      (:line, 1577, :none),
                      (:(=), (:ref, :J, :count), :j),
                      (:line, 1578, :none),
                      (:(=), (:ref, :NZs, :count), :Aij),
                      (:line, 1579, :none),
                      (:+=, :count, 1)
                    ))
                ))
            )),
          (:line, 1583, :none),
          (:return, (:tuple, :I, :J, :NZs))
        ))),
    (:line, 1586, :none),
    (:macrocall, :(Core.@doc), "    findmax(itr) -> (x, index)\n\nReturns the maximum element of the collection `itr` and its index. If there are multiple\nmaximal elements, then the first one will be returned. `NaN` values are ignored, unless\nall elements are `NaN`.\n\nThe collection must not be empty.\n\n```jldoctest\njulia> findmax([8,0.1,-9,pi])\n(8.0, 1)\n\njulia> findmax([1,7,7,6])\n(7, 2)\n\njulia> findmax([1,7,7,NaN])\n(7.0, 2)\n```\n", (:function, (:call, :findmax, :a), (:block,
          (:line, 1607, :none),
          (:if, (:call, :isempty, :a), (:block,
              (:line, 1608, :none),
              (:call, :throw, (:call, :ArgumentError, "collection must be non-empty"))
            )),
          (:line, 1610, :none),
          (:(=), :s, (:call, :start, :a)),
          (:line, 1611, :none),
          (:(=), :mi, (:(=), :i, 1)),
          (:line, 1612, :none),
          (:(=), (:tuple, :m, :s), (:call, :next, :a, :s)),
          (:line, 1613, :none),
          (:while, (:call, :!, (:call, :done, :a, :s)), (:block,
              (:line, 1614, :none),
              (:(=), (:tuple, :ai, :s), (:call, :next, :a, :s)),
              (:line, 1615, :none),
              (:+=, :i, 1),
              (:line, 1616, :none),
              (:if, (:||, (:call, :>, :ai, :m), (:call, :(!=), :m, :m)), (:block,
                  (:line, 1617, :none),
                  (:(=), :m, :ai),
                  (:line, 1618, :none),
                  (:(=), :mi, :i)
                ))
            )),
          (:line, 1621, :none),
          (:return, (:tuple, :m, :mi))
        ))),
    (:line, 1624, :none),
    (:macrocall, :(Core.@doc), "    findmin(itr) -> (x, index)\n\nReturns the minimum element of the collection `itr` and its index. If there are multiple\nminimal elements, then the first one will be returned. `NaN` values are ignored, unless\nall elements are `NaN`.\n\nThe collection must not be empty.\n\n```jldoctest\njulia> findmin([8,0.1,-9,pi])\n(-9.0, 3)\n\njulia> findmin([7,1,1,6])\n(1, 2)\n\njulia> findmin([7,1,1,NaN])\n(1.0, 2)\n```\n", (:function, (:call, :findmin, :a), (:block,
          (:line, 1645, :none),
          (:if, (:call, :isempty, :a), (:block,
              (:line, 1646, :none),
              (:call, :throw, (:call, :ArgumentError, "collection must be non-empty"))
            )),
          (:line, 1648, :none),
          (:(=), :s, (:call, :start, :a)),
          (:line, 1649, :none),
          (:(=), :mi, (:(=), :i, 1)),
          (:line, 1650, :none),
          (:(=), (:tuple, :m, :s), (:call, :next, :a, :s)),
          (:line, 1651, :none),
          (:while, (:call, :!, (:call, :done, :a, :s)), (:block,
              (:line, 1652, :none),
              (:(=), (:tuple, :ai, :s), (:call, :next, :a, :s)),
              (:line, 1653, :none),
              (:+=, :i, 1),
              (:line, 1654, :none),
              (:if, (:||, (:call, :<, :ai, :m), (:call, :(!=), :m, :m)), (:block,
                  (:line, 1655, :none),
                  (:(=), :m, :ai),
                  (:line, 1656, :none),
                  (:(=), :mi, :i)
                ))
            )),
          (:line, 1659, :none),
          (:return, (:tuple, :m, :mi))
        ))),
    (:line, 1662, :none),
    (:macrocall, :(Core.@doc), "    indmax(itr) -> Integer\n\nReturns the index of the maximum element in a collection. If there are multiple maximal\nelements, then the first one will be returned. `NaN` values are ignored, unless all\nelements are `NaN`.\n\nThe collection must not be empty.\n\n```jldoctest\njulia> indmax([8,0.1,-9,pi])\n1\n\njulia> indmax([1,7,7,6])\n2\n\njulia> indmax([1,7,7,NaN])\n2\n```\n", (:(=), (:call, :indmax, :a), (:block,
          (:line, 1682, :none),
          (:ref, (:call, :findmax, :a), 2)
        ))),
    (:line, 1684, :none),
    (:macrocall, :(Core.@doc), "    indmin(itr) -> Integer\n\nReturns the index of the minimum element in a collection. If there are multiple minimal\nelements, then the first one will be returned. `NaN` values are ignored, unless all\nelements are `NaN`.\n\nThe collection must not be empty.\n\n```jldoctest\njulia> indmin([8,0.1,-9,pi])\n3\n\njulia> indmin([7,1,1,6])\n2\n\njulia> indmin([7,1,1,NaN])\n2\n```\n", (:(=), (:call, :indmin, :a), (:block,
          (:line, 1704, :none),
          (:ref, (:call, :findmin, :a), 2)
        ))),
    (:line, 1707, :none),
    (:macrocall, :(Core.@doc), "    indexin(a, b)\n\nReturns a vector containing the highest index in `b` for\neach value in `a` that is a member of `b` . The output\nvector contains 0 wherever `a` is not a member of `b`.\n\n```jldoctest\njulia> a = ['a', 'b', 'c', 'b', 'd', 'a'];\n\njulia> b = ['a','b','c'];\n\njulia> indexin(a,b)\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 2\n 0\n 1\n\njulia> indexin(b,a)\n3-element Array{Int64,1}:\n 6\n 4\n 3\n```\n", (:function, (:call, :indexin, (:(::), :a, :AbstractArray), (:(::), :b, :AbstractArray)), (:block,
          (:line, 1736, :none),
          (:(=), :bdict, (:call, :Dict, (:call, :zip, :b, (:(:), 1, (:call, :length, :b))))),
          (:line, 1737, :none),
          (:comprehension, (:generator, (:call, :get, :bdict, :i, 0), (:(=), :i, :a)))
        ))),
    (:line, 1740, :none),
    (:macrocall, :(Core.@doc), "    findin(a, b)\n\nReturns the indices of elements in collection `a` that appear in collection `b`.\n\n```jldoctest\njulia> a = collect(1:3:15)\n5-element Array{Int64,1}:\n  1\n  4\n  7\n 10\n 13\n\njulia> b = collect(2:4:10)\n3-element Array{Int64,1}:\n  2\n  6\n 10\n\njulia> findin(a,b) # 10 is the only common element\n1-element Array{Int64,1}:\n 4\n```\n", (:function, (:call, :findin, :a, :b), (:block,
          (:line, 1766, :none),
          (:(=), :ind, (:call, (:curly, :Array, :Int, 1), 0)),
          (:line, 1767, :none),
          (:(=), :bset, (:call, :Set, :b)),
          (:line, 1768, :none),
          (:macrocall, Symbol("@inbounds"), (:for, (:(=), (:tuple, :i, :ai), (:call, :enumerate, :a)), (:block,
                (:line, 1769, :none),
                (:&&, (:call, :in, :ai, :bset), (:call, :push!, :ind, :i))
              ))),
          (:line, 1771, :none),
          :ind
        ))),
    (:line, 1776, :none),
    (:function, (:call, :indcopy, (:(::), :sz, :Dims), (:(::), :I, :Vector)), (:block,
        (:line, 1777, :none),
        (:(=), :n, (:call, :length, :I)),
        (:line, 1778, :none),
        (:(=), :s, (:ref, :sz, :n)),
        (:line, 1779, :none),
        (:for, (:(=), :i, (:(:), (:call, :+, :n, 1), (:call, :length, :sz))), (:block,
            (:line, 1780, :none),
            (:*=, :s, (:ref, :sz, :i))
          )),
        (:line, 1782, :none),
        (:(=), :dst, (:typed_comprehension, (:call, :eltype, :I), (:generator, (:call, :findin, (:ref, :I, :i), (:if, (:call, :<, :i, :n), (:(:), 1, (:ref, :sz, :i)), (:(:), 1, :s))), (:(=), :i, (:(:), 1, :n))))),
        (:line, 1783, :none),
        (:(=), :src, (:typed_comprehension, (:call, :eltype, :I), (:generator, (:ref, (:ref, :I, :i), (:call, :findin, (:ref, :I, :i), (:if, (:call, :<, :i, :n), (:(:), 1, (:ref, :sz, :i)), (:(:), 1, :s)))), (:(=), :i, (:(:), 1, :n))))),
        (:line, 1784, :none),
        (:tuple, :dst, :src)
      )),
    (:line, 1787, :none),
    (:function, (:call, :indcopy, (:(::), :sz, :Dims), (:(::), :I, (:curly, :Tuple, (:curly, :Vararg, :RangeIndex)))), (:block,
        (:line, 1788, :none),
        (:(=), :n, (:call, :length, :I)),
        (:line, 1789, :none),
        (:(=), :s, (:ref, :sz, :n)),
        (:line, 1790, :none),
        (:for, (:(=), :i, (:(:), (:call, :+, :n, 1), (:call, :length, :sz))), (:block,
            (:line, 1791, :none),
            (:*=, :s, (:ref, :sz, :i))
          )),
        (:line, 1793, :none),
        (:(=), (:(::), :dst, (:call, :typeof, :I)), (:(::), (:call, :ntuple, (:->, :i, (:block,
                  (:line, 1793, :none),
                  (:call, :findin, (:ref, :I, :i), (:if, (:call, :<, :i, :n), (:(:), 1, (:ref, :sz, :i)), (:(:), 1, :s)))
                )), :n), (:call, :typeof, :I))),
        (:line, 1794, :none),
        (:(=), (:(::), :src, (:call, :typeof, :I)), (:(::), (:call, :ntuple, (:->, :i, (:block,
                  (:line, 1794, :none),
                  (:ref, (:ref, :I, :i), (:call, :findin, (:ref, :I, :i), (:if, (:call, :<, :i, :n), (:(:), 1, (:ref, :sz, :i)), (:(:), 1, :s))))
                )), :n), (:call, :typeof, :I))),
        (:line, 1795, :none),
        (:tuple, :dst, :src)
      )),
    (:line, 1800, :none),
    (:macrocall, :(Core.@doc), "    filter(function, collection)\n\nReturn a copy of `collection`, removing elements for which `function` is `false`. For\nassociative collections, the function is passed two arguments (key and value).\n\n```jldocttest\njulia> a = 1:10\n1:10\n\njulia> filter(isodd, a)\n5-element Array{Int64,1}:\n 1\n 3\n 5\n 7\n 9\n```\n", (:(=), (:call, :filter, :f, (:(::), :As, :AbstractArray)), (:block,
          (:line, 1819, :none),
          (:ref, :As, (:(::), (:call, :map, :f, :As), (:curly, :AbstractArray, :Bool)))
        ))),
    (:line, 1821, :none),
    (:function, (:call, :filter!, :f, (:(::), :a, :AbstractVector)), (:block,
        (:line, 1822, :none),
        (:&&, (:call, :isempty, :a), (:return, :a)),
        (:line, 1824, :none),
        (:(=), :idx, (:call, :eachindex, :a)),
        (:line, 1825, :none),
        (:(=), :state, (:call, :start, :idx)),
        (:line, 1826, :none),
        (:(=), (:tuple, :i, :state), (:call, :next, :idx, :state)),
        (:line, 1828, :none),
        (:for, (:(=), :acurr, :a), (:block,
            (:line, 1829, :none),
            (:if, (:call, :f, :acurr), (:block,
                (:line, 1830, :none),
                (:(=), (:ref, :a, :i), :acurr),
                (:line, 1831, :none),
                (:(=), (:tuple, :i, :state), (:call, :next, :idx, :state))
              ))
          )),
        (:line, 1835, :none),
        (:call, :deleteat!, :a, (:(:), :i, (:call, :last, :idx))),
        (:line, 1837, :none),
        (:return, :a)
      )),
    (:line, 1840, :none),
    (:function, (:call, :filter, :f, (:(::), :a, :Vector)), (:block,
        (:line, 1841, :none),
        (:(=), :r, (:call, (:curly, :Vector, (:call, :eltype, :a)), 0)),
        (:line, 1842, :none),
        (:for, (:(=), :ai, :a), (:block,
            (:line, 1843, :none),
            (:if, (:call, :f, :ai), (:block,
                (:line, 1844, :none),
                (:call, :push!, :r, :ai)
              ))
          )),
        (:line, 1847, :none),
        (:return, :r)
      )),
    (:line, 1853, :none),
    (:function, (:call, :intersect, :v1, (:..., :vs)), (:block,
        (:line, 1854, :none),
        (:(=), :ret, (:call, (:curly, :Vector, (:call, :promote_eltype, :v1, (:..., :vs))), 0)),
        (:line, 1855, :none),
        (:for, (:(=), :v_elem, :v1), (:block,
            (:line, 1856, :none),
            (:(=), :inall, true),
            (:line, 1857, :none),
            (:for, (:(=), :vsi, :vs), (:block,
                (:line, 1858, :none),
                (:if, (:call, :!, (:call, :in, :v_elem, :vsi)), (:block,
                    (:line, 1859, :none),
                    (:(=), :inall, false),
                    (:line, 1859, :none),
                    (:break,)
                  ))
              )),
            (:line, 1862, :none),
            (:if, :inall, (:block,
                (:line, 1863, :none),
                (:call, :push!, :ret, :v_elem)
              ))
          )),
        (:line, 1866, :none),
        :ret
      )),
    (:line, 1869, :none),
    (:function, (:call, :union, (:..., :vs)), (:block,
        (:line, 1870, :none),
        (:(=), :ret, (:call, (:curly, :Vector, (:call, :promote_eltype, (:..., :vs))), 0)),
        (:line, 1871, :none),
        (:(=), :seen, (:call, :Set)),
        (:line, 1872, :none),
        (:for, (:(=), :v, :vs), (:block,
            (:line, 1873, :none),
            (:for, (:(=), :v_elem, :v), (:block,
                (:line, 1874, :none),
                (:if, (:call, :!, (:call, :in, :v_elem, :seen)), (:block,
                    (:line, 1875, :none),
                    (:call, :push!, :ret, :v_elem),
                    (:line, 1876, :none),
                    (:call, :push!, :seen, :v_elem)
                  ))
              ))
          )),
        (:line, 1880, :none),
        :ret
      )),
    (:line, 1884, :none),
    (:macrocall, :(Core.@doc), "    setdiff(a, b)\n\nConstruct the set of elements in `a` but not `b`. Maintains order with arrays. Note that\nboth arguments must be collections, and both will be iterated over. In particular,\n`setdiff(set,element)` where `element` is a potential member of `set`, will not work in\ngeneral.\n\n```jldoctest\njulia> setdiff([1,2,3],[3,4,5])\n2-element Array{Int64,1}:\n 1\n 2\n```\n", (:function, (:call, :setdiff, :a, :b), (:block,
          (:line, 1900, :none),
          (:(=), :args_type, (:call, :promote_type, (:call, :eltype, :a), (:call, :eltype, :b))),
          (:line, 1901, :none),
          (:(=), :bset, (:call, :Set, :b)),
          (:line, 1902, :none),
          (:(=), :ret, (:call, (:curly, :Array, :args_type, 1), 0)),
          (:line, 1903, :none),
          (:(=), :seen, (:call, (:curly, :Set, (:call, :eltype, :a)))),
          (:line, 1904, :none),
          (:for, (:(=), :a_elem, :a), (:block,
              (:line, 1905, :none),
              (:if, (:&&, (:call, :!, (:call, :in, :a_elem, :seen)), (:call, :!, (:call, :in, :a_elem, :bset))), (:block,
                  (:line, 1906, :none),
                  (:call, :push!, :ret, :a_elem),
                  (:line, 1907, :none),
                  (:call, :push!, :seen, :a_elem)
                ))
            )),
          (:line, 1910, :none),
          :ret
        ))),
    (:line, 1917, :none),
    (:(=), (:call, :symdiff, :a), (:block,
        (:line, 1917, :none),
        :a
      )),
    (:line, 1918, :none),
    (:(=), (:call, :symdiff, :a, :b), (:block,
        (:line, 1918, :none),
        (:call, :union, (:call, :setdiff, :a, :b), (:call, :setdiff, :b, :a))
      )),
    (:line, 1919, :none),
    (:macrocall, :(Core.@doc), "    symdiff(a, b, rest...)\n\nConstruct the symmetric difference of elements in the passed in sets or arrays.\nMaintains order with arrays.\n\n```jldoctest\njulia> symdiff([1,2,3],[3,4,5],[4,5,6])\n3-element Array{Int64,1}:\n 1\n 2\n 6\n```\n", (:(=), (:call, :symdiff, :a, :b, (:..., :rest)), (:block,
          (:line, 1933, :none),
          (:call, :symdiff, :a, (:call, :symdiff, :b, (:..., :rest)))
        )))
  ))