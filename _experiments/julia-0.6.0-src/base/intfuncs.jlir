(:quote, (:block,
    (:line, 5, :none),
    (:macrocall, :(Core.@doc), "    gcd(x,y)\n\nGreatest common (positive) divisor (or zero if `x` and `y` are both zero).\n\n```jldoctest\njulia> gcd(6,9)\n3\n\njulia> gcd(6,-9)\n3\n```\n", (:function, (:where, (:call, :gcd, (:(::), :a, :T), (:(::), :b, :T)), (:<:, :T, :Integer)), (:block,
          (:line, 19, :none),
          (:while, (:call, :(!=), :b, 0), (:block,
              (:line, 20, :none),
              (:(=), :t, :b),
              (:line, 21, :none),
              (:(=), :b, (:call, :rem, :a, :b)),
              (:line, 22, :none),
              (:(=), :a, :t)
            )),
          (:line, 24, :none),
          (:call, :checked_abs, :a)
        ))),
    (:line, 29, :none),
    (:function, (:where, (:call, :gcd, (:(::), :a, :T), (:(::), :b, :T)), (:<:, :T, (:curly, :Union, :Int64, :UInt64, :Int128, :UInt128))), (:block,
        (:line, 30, :none),
        (:&&, (:call, :(==), :a, 0), (:return, (:call, :abs, :b))),
        (:line, 31, :none),
        (:&&, (:call, :(==), :b, 0), (:return, (:call, :abs, :a))),
        (:line, 32, :none),
        (:(=), :za, (:call, :trailing_zeros, :a)),
        (:line, 33, :none),
        (:(=), :zb, (:call, :trailing_zeros, :b)),
        (:line, 34, :none),
        (:(=), :k, (:call, :min, :za, :zb)),
        (:line, 35, :none),
        (:(=), :u, (:call, :unsigned, (:call, :abs, (:call, :>>, :a, :za)))),
        (:line, 36, :none),
        (:(=), :v, (:call, :unsigned, (:call, :abs, (:call, :>>, :b, :zb)))),
        (:line, 37, :none),
        (:while, (:call, :(!=), :u, :v), (:block,
            (:line, 38, :none),
            (:if, (:call, :>, :u, :v), (:block,
                (:line, 39, :none),
                (:(=), (:tuple, :u, :v), (:tuple, :v, :u))
              )),
            (:line, 41, :none),
            (:-=, :v, :u),
            (:line, 42, :none),
            (:>>=, :v, (:call, :trailing_zeros, :v))
          )),
        (:line, 44, :none),
        (:(=), :r, (:call, :<<, :u, :k)),
        (:line, 46, :none),
        (:&&, (:call, :>, :r, (:call, :typemax, :T)), (:call, :throw, (:call, :OverflowError))),
        (:line, 47, :none),
        (:call, :%, :r, :T)
      )),
    (:line, 50, :none),
    (:macrocall, :(Core.@doc), "    lcm(x,y)\n\nLeast common (non-negative) multiple.\n```jldoctest\njulia> lcm(2,3)\n6\n\njulia> lcm(-2,3)\n6\n```\n", (:function, (:where, (:call, :lcm, (:(::), :a, :T), (:(::), :b, :T)), (:<:, :T, :Integer)), (:block,
          (:line, 64, :none),
          (:if, (:call, :(==), :a, 0), (:block,
              (:line, 65, :none),
              (:return, :a)
            ), (:block,
              (:line, 67, :none),
              (:return, (:call, :checked_abs, (:call, :*, :a, (:call, :div, :b, (:call, :gcd, :b, :a)))))
            ))
        ))),
    (:line, 71, :none),
    (:(=), (:call, :gcd, (:(::), :a, :Integer)), (:block,
        (:line, 71, :none),
        :a
      )),
    (:line, 72, :none),
    (:(=), (:call, :lcm, (:(::), :a, :Integer)), (:block,
        (:line, 72, :none),
        :a
      )),
    (:line, 73, :none),
    (:(=), (:call, :gcd, (:(::), :a, :Integer), (:(::), :b, :Integer)), (:block,
        (:line, 73, :none),
        (:call, :gcd, (:..., (:call, :promote, :a, :b)))
      )),
    (:line, 74, :none),
    (:(=), (:call, :lcm, (:(::), :a, :Integer), (:(::), :b, :Integer)), (:block,
        (:line, 74, :none),
        (:call, :lcm, (:..., (:call, :promote, :a, :b)))
      )),
    (:line, 75, :none),
    (:(=), (:call, :gcd, (:(::), :a, :Integer), (:..., (:(::), :b, :Integer))), (:block,
        (:line, 75, :none),
        (:call, :gcd, :a, (:call, :gcd, (:..., :b)))
      )),
    (:line, 76, :none),
    (:(=), (:call, :lcm, (:(::), :a, :Integer), (:..., (:(::), :b, :Integer))), (:block,
        (:line, 76, :none),
        (:call, :lcm, :a, (:call, :lcm, (:..., :b)))
      )),
    (:line, 78, :none),
    (:(=), (:call, :gcd, (:(::), :abc, (:curly, :AbstractArray, (:<:, :Integer)))), (:block,
        (:line, 78, :none),
        (:call, :reduce, :gcd, :abc)
      )),
    (:line, 79, :none),
    (:(=), (:call, :lcm, (:(::), :abc, (:curly, :AbstractArray, (:<:, :Integer)))), (:block,
        (:line, 79, :none),
        (:call, :reduce, :lcm, :abc)
      )),
    (:line, 82, :none),
    (:macrocall, :(Core.@doc), "    gcdx(x,y)\n\nComputes the greatest common (positive) divisor of `x` and `y` and their Bézout\ncoefficients, i.e. the integer coefficients `u` and `v` that satisfy\n``ux+vy = d = gcd(x,y)``. ``gcdx(x,y)`` returns ``(d,u,v)``.\n\n```jldoctest\njulia> gcdx(12, 42)\n(6, -3, 1)\n```\n\n```jldoctest\njulia> gcdx(240, 46)\n(2, -9, 47)\n```\n\n!!! note\n    Bézout coefficients are *not* uniquely defined. `gcdx` returns the minimal\n    Bézout coefficients that are computed by the extended Euclidean algorithm.\n    (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.)\n    For signed integers, these coefficients `u` and `v` are minimal in\n    the sense that ``|u| < |y/d|`` and ``|v| < |x/d|``. Furthermore,\n    the signs of `u` and `v` are chosen so that `d` is positive.\n    For unsigned integers, the coefficients `u` and `v` might be near\n    their `typemax`, and the identity then holds only via the unsigned\n    integers' modulo arithmetic.\n", (:function, (:where, (:call, :gcdx, (:(::), :a, :T), (:(::), :b, :T)), (:<:, :T, :Integer)), (:block,
          (:line, 112, :none),
          (:(=), (:tuple, :s0, :s1), (:tuple, (:call, :oneunit, :T), (:call, :zero, :T))),
          (:line, 113, :none),
          (:(=), (:tuple, :t0, :t1), (:tuple, :s1, :s0)),
          (:line, 115, :none),
          (:while, (:call, :(!=), :b, 0), (:block,
              (:line, 116, :none),
              (:(=), :q, (:call, :div, :a, :b)),
              (:line, 117, :none),
              (:(=), (:tuple, :a, :b), (:tuple, :b, (:call, :rem, :a, :b))),
              (:line, 118, :none),
              (:(=), (:tuple, :s0, :s1), (:tuple, :s1, (:call, :-, :s0, (:call, :*, :q, :s1)))),
              (:line, 119, :none),
              (:(=), (:tuple, :t0, :t1), (:tuple, :t1, (:call, :-, :t0, (:call, :*, :q, :t1))))
            )),
          (:line, 121, :none),
          (:if, (:call, :<, :a, 0), (:tuple, (:call, :-, :a), (:call, :-, :s0), (:call, :-, :t0)), (:tuple, :a, :s0, :t0))
        ))),
    (:line, 123, :none),
    (:(=), (:call, :gcdx, (:(::), :a, :Integer), (:(::), :b, :Integer)), (:block,
        (:line, 123, :none),
        (:call, :gcdx, (:..., (:call, :promote, :a, :b)))
      )),
    (:line, 127, :none),
    (:macrocall, :(Core.@doc), "    invmod(x,m)\n\nTake the inverse of `x` modulo `m`: `y` such that ``x y = 1 \\pmod m``,\nwith ``div(x,y) = 0``. This is undefined for ``m = 0``, or if\n``gcd(x,m) \\neq 1``.\n\n```jldoctest\njulia> invmod(2,5)\n3\n\njulia> invmod(2,3)\n2\n\njulia> invmod(5,6)\n5\n```\n", (:function, (:where, (:call, :invmod, (:(::), :n, :T), (:(::), :m, :T)), (:<:, :T, :Integer)), (:block,
          (:line, 146, :none),
          (:(=), (:tuple, :g, :x, :y), (:call, :gcdx, :n, :m)),
          (:line, 147, :none),
          (:&&, (:||, (:call, :(!=), :g, 1), (:call, :(==), :m, 0)), (:call, :throw, (:call, :DomainError))),
          (:line, 150, :none),
          (:(=), :r, (:call, :mod, (:call, :+, :x, :m), :m)),
          (:line, 152, :none),
          :r
        ))),
    (:line, 154, :none),
    (:(=), (:call, :invmod, (:(::), :n, :Integer), (:(::), :m, :Integer)), (:block,
        (:line, 154, :none),
        (:call, :invmod, (:..., (:call, :promote, :n, :m)))
      )),
    (:line, 157, :none),
    (:(=), (:call, :to_power_type, (:(::), :x, :Number)), (:block,
        (:line, 157, :none),
        (:call, :oftype, (:call, :*, :x, :x), :x)
      )),
    (:line, 158, :none),
    (:(=), (:call, :to_power_type, :x), (:block,
        (:line, 158, :none),
        :x
      )),
    (:line, 159, :none),
    (:function, (:call, :power_by_squaring, :x_, (:(::), :p, :Integer)), (:block,
        (:line, 160, :none),
        (:(=), :x, (:call, :to_power_type, :x_)),
        (:line, 161, :none),
        (:if, (:call, :(==), :p, 1), (:block,
            (:line, 162, :none),
            (:return, (:call, :copy, :x))
          ), (:block,
            (:line, 163, :none),
            (:if, (:call, :(==), :p, 0), (:block,
                (:line, 164, :none),
                (:return, (:call, :one, :x))
              ), (:block,
                (:line, 165, :none),
                (:if, (:call, :(==), :p, 2), (:block,
                    (:line, 166, :none),
                    (:return, (:call, :*, :x, :x))
                  ), (:block,
                    (:line, 167, :none),
                    (:if, (:call, :<, :p, 0), (:block,
                        (:line, 168, :none),
                        (:&&, (:call, :(==), :x, 1), (:return, (:call, :copy, :x))),
                        (:line, 169, :none),
                        (:&&, (:call, :(==), :x, -1), (:return, (:if, (:call, :iseven, :p), (:call, :one, :x), (:call, :copy, :x)))),
                        (:line, 170, :none),
                        (:call, :throw, (:call, :DomainError))
                      ))
                  ))
              ))
          )),
        (:line, 172, :none),
        (:(=), :t, (:call, :+, (:call, :trailing_zeros, :p), 1)),
        (:line, 173, :none),
        (:>>=, :p, :t),
        (:line, 174, :none),
        (:while, (:call, :>, (:-=, :t, 1), 0), (:block,
            (:line, 175, :none),
            (:*=, :x, :x)
          )),
        (:line, 177, :none),
        (:(=), :y, :x),
        (:line, 178, :none),
        (:while, (:call, :>, :p, 0), (:block,
            (:line, 179, :none),
            (:(=), :t, (:call, :+, (:call, :trailing_zeros, :p), 1)),
            (:line, 180, :none),
            (:>>=, :p, :t),
            (:line, 181, :none),
            (:while, (:call, :(>=), (:-=, :t, 1), 0), (:block,
                (:line, 182, :none),
                (:*=, :x, :x)
              )),
            (:line, 184, :none),
            (:*=, :y, :x)
          )),
        (:line, 186, :none),
        (:return, :y)
      )),
    (:line, 188, :none),
    (:(=), (:call, :power_by_squaring, (:(::), :x, :Bool), (:(::), :p, :Unsigned)), (:block,
        (:line, 188, :none),
        (:call, :|, (:call, :(==), :p, 0), :x)
      )),
    (:line, 189, :none),
    (:function, (:call, :power_by_squaring, (:(::), :x, :Bool), (:(::), :p, :Integer)), (:block,
        (:line, 190, :none),
        (:&&, (:call, :<, :p, 0), (:&&, (:call, :!, :x), (:call, :throw, (:call, :DomainError)))),
        (:line, 191, :none),
        (:return, (:call, :|, (:call, :(==), :p, 0), :x))
      )),
    (:line, 194, :none),
    (:(=), (:where, (:call, :^, (:(::), :x, :T), (:(::), :p, :T)), (:<:, :T, :Integer)), (:block,
        (:line, 194, :none),
        (:call, :power_by_squaring, :x, :p)
      )),
    (:line, 195, :none),
    (:(=), (:call, :^, (:(::), :x, :Number), (:(::), :p, :Integer)), (:block,
        (:line, 195, :none),
        (:call, :power_by_squaring, :x, :p)
      )),
    (:line, 196, :none),
    (:(=), (:call, :^, :x, (:(::), :p, :Integer)), (:block,
        (:line, 196, :none),
        (:call, :power_by_squaring, :x, :p)
      )),
    (:line, 205, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:where, (:call, :literal_pow, :f, :x, (:(::), (:curly, :Type, (:curly, :Val, :p)))), :p), (:block,
          (:line, 205, :none),
          (:call, :f, :x, :p)
        ))),
    (:line, 209, :none),
    (:const, (:(=), :HWReal, (:curly, :Union, :Int8, :Int16, :Int32, :Int64, :UInt8, :UInt16, :UInt32, :UInt64, :Float32, :Float64))),
    (:line, 210, :none),
    (:const, (:(=), :HWNumber, (:curly, :Union, :HWReal, (:curly, :Complex, (:<:, :HWReal)), (:curly, :Rational, (:<:, :HWReal))))),
    (:line, 216, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :literal_pow, (:(::), (:call, :typeof, :^)), (:(::), :x, :HWNumber), (:(::), (:curly, :Type, (:curly, :Val, 0)))), (:block,
          (:line, 216, :none),
          (:call, :one, :x)
        ))),
    (:line, 217, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :literal_pow, (:(::), (:call, :typeof, :^)), (:(::), :x, :HWNumber), (:(::), (:curly, :Type, (:curly, :Val, 1)))), (:block,
          (:line, 217, :none),
          :x
        ))),
    (:line, 218, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :literal_pow, (:(::), (:call, :typeof, :^)), (:(::), :x, :HWNumber), (:(::), (:curly, :Type, (:curly, :Val, 2)))), (:block,
          (:line, 218, :none),
          (:call, :*, :x, :x)
        ))),
    (:line, 219, :none),
    (:macrocall, Symbol("@inline"), (:(=), (:call, :literal_pow, (:(::), (:call, :typeof, :^)), (:(::), :x, :HWNumber), (:(::), (:curly, :Type, (:curly, :Val, 3)))), (:block,
          (:line, 219, :none),
          (:call, :*, :x, :x, :x)
        ))),
    (:line, 223, :none),
    (:macrocall, :(Core.@doc), "    powermod(x::Integer, p::Integer, m)\n\nCompute ``x^p \\pmod m``.\n", (:function, (:where, (:call, :powermod, (:(::), :x, :Integer), (:(::), :p, :Integer), (:(::), :m, :T)), (:<:, :T, :Integer)), (:block,
          (:line, 229, :none),
          (:&&, (:call, :<, :p, 0), (:return, (:call, :powermod, (:call, :invmod, :x, :m), (:call, :-, :p), :m))),
          (:line, 230, :none),
          (:&&, (:call, :(==), :p, 0), (:return, (:call, :mod, (:call, :one, :m), :m))),
          (:line, 231, :none),
          (:&&, (:||, (:call, :(==), :m, 1), (:call, :(==), :m, -1)), (:return, (:call, :zero, :m))),
          (:line, 232, :none),
          (:(=), :b, (:call, :oftype, :m, (:call, :mod, :x, :m))),
          (:line, 234, :none),
          (:(=), :t, (:call, :prevpow2, :p)),
          (:line, 235, :none),
          (:local, (:(::), :r, :T)),
          (:line, 236, :none),
          (:(=), :r, 1),
          (:line, 237, :none),
          (:while, true, (:block,
              (:line, 238, :none),
              (:if, (:call, :(>=), :p, :t), (:block,
                  (:line, 239, :none),
                  (:(=), :r, (:call, :mod, (:call, :widemul, :r, :b), :m)),
                  (:line, 240, :none),
                  (:-=, :p, :t)
                )),
              (:line, 242, :none),
              (:>>>=, :t, 1),
              (:line, 243, :none),
              (:&&, (:call, :(<=), :t, 0), (:break,)),
              (:line, 244, :none),
              (:(=), :r, (:call, :mod, (:call, :widemul, :r, :r), :m))
            )),
          (:line, 246, :none),
          (:return, :r)
        ))),
    (:line, 250, :none),
    (:(=), (:call, :powermod, (:(::), :x, :Integer), (:(::), :p, :Integer), (:(::), :m, (:curly, :Union, :Int128, :UInt128))), (:block,
        (:line, 250, :none),
        (:call, :oftype, :m, (:call, :powermod, :x, :p, (:call, :big, :m)))
      )),
    (:line, 254, :none),
    (:macrocall, :(Core.@doc), "    nextpow2(n::Integer)\n\nThe smallest power of two not less than `n`. Returns 0 for `n==0`, and returns\n`-nextpow2(-n)` for negative arguments.\n\n```jldoctest\njulia> nextpow2(16)\n16\n\njulia> nextpow2(17)\n32\n```\n", (:(=), (:call, :nextpow2, (:(::), :x, :Unsigned)), (:block,
          (:line, 268, :none),
          (:call, :<<, (:call, :oneunit, :x), (:call, :-, (:call, :<<, (:call, :sizeof, :x), 3), (:call, :leading_zeros, (:call, :-, :x, (:call, :oneunit, :x)))))
        ))),
    (:line, 269, :none),
    (:(=), (:call, :nextpow2, (:(::), :x, :Integer)), (:block,
        (:line, 269, :none),
        (:call, :reinterpret, (:call, :typeof, :x), (:if, (:call, :<, :x, 0), (:call, :-, (:call, :nextpow2, (:call, :unsigned, (:call, :-, :x)))), (:call, :nextpow2, (:call, :unsigned, :x))))
      )),
    (:line, 271, :none),
    (:macrocall, :(Core.@doc), "    prevpow2(n::Integer)\n\nThe largest power of two not greater than `n`. Returns 0 for `n==0`, and returns\n`-prevpow2(-n)` for negative arguments.\n\n```jldoctest\njulia> prevpow2(5)\n4\n```\n", (:(=), (:call, :prevpow2, (:(::), :x, :Unsigned)), (:block,
          (:line, 282, :none),
          (:call, :<<, (:call, :one, :x), (:call, :unsigned, (:call, :-, (:call, :-, (:call, :<<, (:call, :sizeof, :x), 3), (:call, :leading_zeros, :x)), 1)))
        ))),
    (:line, 283, :none),
    (:(=), (:call, :prevpow2, (:(::), :x, :Integer)), (:block,
        (:line, 283, :none),
        (:call, :reinterpret, (:call, :typeof, :x), (:if, (:call, :<, :x, 0), (:call, :-, (:call, :prevpow2, (:call, :unsigned, (:call, :-, :x)))), (:call, :prevpow2, (:call, :unsigned, :x))))
      )),
    (:line, 285, :none),
    (:macrocall, :(Core.@doc), "    ispow2(n::Integer) -> Bool\n\nTest whether `n` is a power of two.\n\n```jldoctest\njulia> ispow2(4)\ntrue\n\njulia> ispow2(5)\nfalse\n```\n", (:(=), (:call, :ispow2, (:(::), :x, :Integer)), (:block,
          (:line, 298, :none),
          (:&&, (:call, :>, :x, 0), (:call, :(==), (:call, :count_ones, :x), 1))
        ))),
    (:line, 300, :none),
    (:macrocall, :(Core.@doc), "    nextpow(a, x)\n\nThe smallest `a^n` not less than `x`, where `n` is a non-negative integer. `a` must be\ngreater than 1, and `x` must be greater than 0.\n", (:function, (:call, :nextpow, (:(::), :a, :Real), (:(::), :x, :Real)), (:block,
          (:line, 307, :none),
          (:&&, (:||, (:call, :(<=), :a, 1), (:call, :(<=), :x, 0)), (:call, :throw, (:call, :DomainError))),
          (:line, 308, :none),
          (:&&, (:call, :(<=), :x, 1), (:return, (:call, :one, :a))),
          (:line, 309, :none),
          (:(=), :n, (:call, :ceil, :Integer, (:call, :log, :a, :x))),
          (:line, 310, :none),
          (:(=), :p, (:call, :^, :a, (:call, :-, :n, 1))),
          (:line, 312, :none),
          (:if, (:call, :(>=), :p, :x), :p, (:call, :^, :a, :n))
        ))),
    (:line, 315, :none),
    (:macrocall, :(Core.@doc), "    prevpow(a, x)\n\nThe largest `a^n` not greater than `x`, where `n` is a non-negative integer.\n`a` must be greater than 1, and `x` must not be less than 1.\n", (:function, (:call, :prevpow, (:(::), :a, :Real), (:(::), :x, :Real)), (:block,
          (:line, 322, :none),
          (:&&, (:||, (:call, :(<=), :a, 1), (:call, :<, :x, 1)), (:call, :throw, (:call, :DomainError))),
          (:line, 323, :none),
          (:(=), :n, (:call, :floor, :Integer, (:call, :log, :a, :x))),
          (:line, 324, :none),
          (:(=), :p, (:call, :^, :a, (:call, :+, :n, 1))),
          (:line, 325, :none),
          (:if, (:call, :(<=), :p, :x), :p, (:call, :^, :a, :n))
        ))),
    (:line, 329, :none),
    (:const, (:(=), :powers_of_ten, (:vect, 0x0000000000000001, 0x000000000000000a, 0x0000000000000064, 0x00000000000003e8, 0x0000000000002710, 0x00000000000186a0, 0x00000000000f4240, 0x0000000000989680, 0x0000000005f5e100, 0x000000003b9aca00, 0x00000002540be400, 0x000000174876e800, 0x000000e8d4a51000, 0x000009184e72a000, 0x00005af3107a4000, 0x00038d7ea4c68000, 0x002386f26fc10000, 0x016345785d8a0000, 0x0de0b6b3a7640000, 0x8ac7230489e80000))),
    (:line, 336, :none),
    (:function, (:call, :ndigits0z, (:(::), :x, (:curly, :Union, :UInt8, :UInt16, :UInt32, :UInt64))), (:block,
        (:line, 337, :none),
        (:(=), :lz, (:call, :-, (:call, :<<, (:call, :sizeof, :x), 3), (:call, :leading_zeros, :x))),
        (:line, 338, :none),
        (:(=), :nd, (:call, :+, (:call, :>>, (:call, :*, 1233, :lz), 12), 1)),
        (:line, 339, :none),
        (:-=, :nd, (:call, :<, :x, (:ref, :powers_of_ten, :nd)))
      )),
    (:line, 341, :none),
    (:function, (:call, :ndigits0z, (:(::), :x, :UInt128)), (:block,
        (:line, 342, :none),
        (:(=), :n, 0),
        (:line, 343, :none),
        (:while, (:call, :>, :x, 0x8ac7230489e80000), (:block,
            (:line, 344, :none),
            (:(=), :x, (:call, :div, :x, 0x8ac7230489e80000)),
            (:line, 345, :none),
            (:+=, :n, 19)
          )),
        (:line, 347, :none),
        (:return, (:call, :+, :n, (:call, :ndigits0z, (:call, :UInt64, :x))))
      )),
    (:line, 349, :none),
    (:(=), (:call, :ndigits0z, (:(::), :x, :Integer)), (:block,
        (:line, 349, :none),
        (:call, :ndigits0z, (:call, :unsigned, (:call, :abs, :x)))
      )),
    (:line, 351, :none),
    (:function, (:call, :ndigits0znb, (:(::), :n, :Signed), (:(::), :b, :Int)), (:block,
        (:line, 352, :none),
        (:(=), :d, 0),
        (:line, 353, :none),
        (:while, (:call, :(!=), :n, 0), (:block,
            (:line, 354, :none),
            (:(=), :n, (:call, :cld, :n, :b)),
            (:line, 355, :none),
            (:+=, :d, 1)
          )),
        (:line, 357, :none),
        (:return, :d)
      )),
    (:line, 360, :none),
    (:function, (:call, :ndigits0z, (:(::), :n, :Unsigned), (:(::), :b, :Int)), (:block,
        (:line, 361, :none),
        (:&&, (:call, :<, :b, 0), (:return, (:call, :ndigits0znb, (:call, :signed, :n), :b))),
        (:line, 362, :none),
        (:&&, (:call, :(==), :b, 2), (:return, (:call, :-, (:call, :<<, (:call, :sizeof, :n), 3), (:call, :leading_zeros, :n)))),
        (:line, 363, :none),
        (:&&, (:call, :(==), :b, 8), (:return, (:call, :÷, (:call, :+, (:call, :-, (:call, :<<, (:call, :sizeof, :n), 3), (:call, :leading_zeros, :n)), 2), 3))),
        (:line, 364, :none),
        (:&&, (:call, :(==), :b, 16), (:return, (:call, :-, (:call, :<<, (:call, :sizeof, :n), 1), (:call, :>>, (:call, :leading_zeros, :n), 2)))),
        (:line, 365, :none),
        (:&&, (:call, :(==), :b, 10), (:return, (:call, :ndigits0z, :n))),
        (:line, 367, :none),
        (:(=), :d, 0),
        (:line, 368, :none),
        (:while, (:call, :>, :n, (:call, :typemax, :Int)), (:block,
            (:line, 369, :none),
            (:(=), :n, (:call, :div, :n, :b)),
            (:line, 370, :none),
            (:+=, :d, 1)
          )),
        (:line, 372, :none),
        (:(=), :n, (:call, :div, :n, :b)),
        (:line, 373, :none),
        (:+=, :d, 1),
        (:line, 375, :none),
        (:(=), :m, 1),
        (:line, 376, :none),
        (:while, (:call, :(<=), :m, :n), (:block,
            (:line, 377, :none),
            (:*=, :m, :b),
            (:line, 378, :none),
            (:+=, :d, 1)
          )),
        (:line, 380, :none),
        (:return, :d)
      )),
    (:line, 382, :none),
    (:(=), (:call, :ndigits0z, (:(::), :x, :Integer), (:(::), :b, :Integer)), (:block,
        (:line, 382, :none),
        (:call, :ndigits0z, (:call, :unsigned, (:call, :abs, :x)), (:call, :Int, :b))
      )),
    (:line, 384, :none),
    (:(=), (:call, :ndigitsnb, (:(::), :x, :Integer), (:(::), :b, :Integer)), (:block,
        (:line, 384, :none),
        (:if, (:call, :(==), :x, 0), 1, (:call, :ndigits0znb, :x, :b))
      )),
    (:line, 386, :none),
    (:(=), (:call, :ndigits, (:(::), :x, :Unsigned), (:(::), :b, :Integer)), (:block,
        (:line, 386, :none),
        (:if, (:call, :(==), :x, 0), 1, (:call, :ndigits0z, :x, (:call, :Int, :b)))
      )),
    (:line, 387, :none),
    (:(=), (:call, :ndigits, (:(::), :x, :Unsigned)), (:block,
        (:line, 387, :none),
        (:if, (:call, :(==), :x, 0), 1, (:call, :ndigits0z, :x))
      )),
    (:line, 389, :none),
    (:macrocall, :(Core.@doc), "    ndigits(n::Integer, b::Integer=10)\n\nCompute the number of digits in integer `n` written in base `b`.\n", (:(=), (:call, :ndigits, (:(::), :x, :Integer), (:(::), :b, :Integer)), (:block,
          (:line, 394, :none),
          (:if, (:call, :(>=), :b, 0), (:call, :ndigits, (:call, :unsigned, (:call, :abs, :x)), (:call, :Int, :b)), (:call, :ndigitsnb, :x, :b))
        ))),
    (:line, 395, :none),
    (:(=), (:call, :ndigits, (:(::), :x, :Integer)), (:block,
        (:line, 395, :none),
        (:call, :ndigits, (:call, :unsigned, (:call, :abs, :x)))
      )),
    (:line, 399, :none),
    (:(=), (:call, :string, (:(::), :x, (:curly, :Union, :Int8, :Int16, :Int32, :Int64, :Int128))), (:block,
        (:line, 399, :none),
        (:call, :dec, :x)
      )),
    (:line, 401, :none),
    (:function, (:call, :bin, (:(::), :x, :Unsigned), (:(::), :pad, :Int), (:(::), :neg, :Bool)), (:block,
        (:line, 402, :none),
        (:(=), :i, (:call, :+, :neg, (:call, :max, :pad, (:call, :-, (:call, :<<, (:call, :sizeof, :x), 3), (:call, :leading_zeros, :x))))),
        (:line, 403, :none),
        (:(=), :a, (:call, :StringVector, :i)),
        (:line, 404, :none),
        (:while, (:call, :>, :i, :neg), (:block,
            (:line, 405, :none),
            (:(=), (:ref, :a, :i), (:call, :+, '0', (:call, :&, :x, 0x01))),
            (:line, 406, :none),
            (:>>=, :x, 1),
            (:line, 407, :none),
            (:-=, :i, 1)
          )),
        (:line, 409, :none),
        (:if, :neg, (:block,
            (:line, 409, :none),
            (:(=), (:ref, :a, 1), '-')
          )),
        (:line, 410, :none),
        (:call, :String, :a)
      )),
    (:line, 413, :none),
    (:function, (:call, :oct, (:(::), :x, :Unsigned), (:(::), :pad, :Int), (:(::), :neg, :Bool)), (:block,
        (:line, 414, :none),
        (:(=), :i, (:call, :+, :neg, (:call, :max, :pad, (:call, :div, (:call, :+, (:call, :-, (:call, :<<, (:call, :sizeof, :x), 3), (:call, :leading_zeros, :x)), 2), 3)))),
        (:line, 415, :none),
        (:(=), :a, (:call, :StringVector, :i)),
        (:line, 416, :none),
        (:while, (:call, :>, :i, :neg), (:block,
            (:line, 417, :none),
            (:(=), (:ref, :a, :i), (:call, :+, '0', (:call, :&, :x, 0x07))),
            (:line, 418, :none),
            (:>>=, :x, 3),
            (:line, 419, :none),
            (:-=, :i, 1)
          )),
        (:line, 421, :none),
        (:if, :neg, (:block,
            (:line, 421, :none),
            (:(=), (:ref, :a, 1), '-')
          )),
        (:line, 422, :none),
        (:call, :String, :a)
      )),
    (:line, 425, :none),
    (:function, (:call, :dec, (:(::), :x, :Unsigned), (:(::), :pad, :Int), (:(::), :neg, :Bool)), (:block,
        (:line, 426, :none),
        (:(=), :i, (:call, :+, :neg, (:call, :max, :pad, (:call, :ndigits0z, :x)))),
        (:line, 427, :none),
        (:(=), :a, (:call, :StringVector, :i)),
        (:line, 428, :none),
        (:while, (:call, :>, :i, :neg), (:block,
            (:line, 429, :none),
            (:(=), (:ref, :a, :i), (:call, :+, '0', (:call, :rem, :x, 10))),
            (:line, 430, :none),
            (:(=), :x, (:call, :oftype, :x, (:call, :div, :x, 10))),
            (:line, 431, :none),
            (:-=, :i, 1)
          )),
        (:line, 433, :none),
        (:if, :neg, (:block,
            (:line, 433, :none),
            (:(=), (:ref, :a, 1), '-')
          )),
        (:line, 434, :none),
        (:call, :String, :a)
      )),
    (:line, 437, :none),
    (:function, (:call, :hex, (:(::), :x, :Unsigned), (:(::), :pad, :Int), (:(::), :neg, :Bool)), (:block,
        (:line, 438, :none),
        (:(=), :i, (:call, :+, :neg, (:call, :max, :pad, (:call, :-, (:call, :<<, (:call, :sizeof, :x), 1), (:call, :>>, (:call, :leading_zeros, :x), 2))))),
        (:line, 439, :none),
        (:(=), :a, (:call, :StringVector, :i)),
        (:line, 440, :none),
        (:while, (:call, :>, :i, :neg), (:block,
            (:line, 441, :none),
            (:(=), :d, (:call, :&, :x, 0x0f)),
            (:line, 442, :none),
            (:(=), (:ref, :a, :i), (:call, :+, '0', :d, (:call, :*, 39, (:call, :>, :d, 9)))),
            (:line, 443, :none),
            (:>>=, :x, 4),
            (:line, 444, :none),
            (:-=, :i, 1)
          )),
        (:line, 446, :none),
        (:if, :neg, (:block,
            (:line, 446, :none),
            (:(=), (:ref, :a, 1), '-')
          )),
        (:line, 447, :none),
        (:call, :String, :a)
      )),
    (:line, 450, :none),
    (:(=), (:call, :num2hex, (:(::), :n, :Integer)), (:block,
        (:line, 450, :none),
        (:call, :hex, :n, (:call, :*, (:call, :sizeof, :n), 2))
      )),
    (:line, 452, :none),
    (:const, (:(=), :base36digits, (:vcat, (:(:), '0', '9'), (:(:), 'a', 'z')))),
    (:line, 453, :none),
    (:const, (:(=), :base62digits, (:vcat, (:(:), '0', '9'), (:(:), 'A', 'Z'), (:(:), 'a', 'z')))),
    (:line, 455, :none),
    (:function, (:call, :base, (:(::), :b, :Int), (:(::), :x, :Unsigned), (:(::), :pad, :Int), (:(::), :neg, :Bool)), (:block,
        (:line, 456, :none),
        (:||, (:comparison, 2, :(<=), :b, :(<=), 62), (:call, :throw, (:call, :ArgumentError, (:string, "base must be 2 ≤ base ≤ 62, got ", :b)))),
        (:line, 457, :none),
        (:(=), :digits, (:if, (:call, :(<=), :b, 36), :base36digits, :base62digits)),
        (:line, 458, :none),
        (:(=), :i, (:call, :+, :neg, (:call, :max, :pad, (:call, :ndigits0z, :x, :b)))),
        (:line, 459, :none),
        (:(=), :a, (:call, :StringVector, :i)),
        (:line, 460, :none),
        (:while, (:call, :>, :i, :neg), (:block,
            (:line, 461, :none),
            (:(=), (:ref, :a, :i), (:ref, :digits, (:call, :+, 1, (:call, :rem, :x, :b)))),
            (:line, 462, :none),
            (:(=), :x, (:call, :div, :x, :b)),
            (:line, 463, :none),
            (:-=, :i, 1)
          )),
        (:line, 465, :none),
        (:if, :neg, (:block,
            (:line, 465, :none),
            (:(=), (:ref, :a, 1), '-')
          )),
        (:line, 466, :none),
        (:call, :String, :a)
      )),
    (:line, 469, :none),
    (:macrocall, :(Core.@doc), "    base(base::Integer, n::Integer, pad::Integer=1)\n\nConvert an integer `n` to a string in the given `base`,\noptionally specifying a number of digits to pad to.\n\n```jldoctest\njulia> base(13,5,4)\n\"0005\"\n\njulia> base(5,13,4)\n\"0023\"\n```\n", (:(=), (:call, :base, (:(::), :b, :Integer), (:(::), :n, :Integer), (:kw, (:(::), :pad, :Integer), 1)), (:block,
          (:line, 483, :none),
          (:call, :base, (:call, :Int, :b), (:call, :unsigned, (:call, :abs, :n)), :pad, (:call, :<, :n, 0))
        ))),
    (:line, 485, :none),
    (:for, (:(=), :sym, (:tuple, (:quote, #QuoteNode
            :bin
          ), (:quote, #QuoteNode
            :oct
          ), (:quote, #QuoteNode
            :dec
          ), (:quote, #QuoteNode
            :hex
          ))), (:block,
        (:line, 486, :none),
        (:macrocall, Symbol("@eval"), (:block,
            (:line, 487, :none),
            (:(=), (:call, (:$, :sym), (:(::), :x, :Unsigned), (:(::), :p, :Int)), (:block,
                (:line, 487, :none),
                (:call, (:$, :sym), :x, :p, false)
              )),
            (:line, 488, :none),
            (:(=), (:call, (:$, :sym), (:(::), :x, :Unsigned)), (:block,
                (:line, 488, :none),
                (:call, (:$, :sym), :x, 1, false)
              )),
            (:line, 489, :none),
            (:(=), (:call, (:$, :sym), (:(::), :x, :Char), (:(::), :p, :Int)), (:block,
                (:line, 489, :none),
                (:call, (:$, :sym), (:call, :unsigned, :x), :p, false)
              )),
            (:line, 490, :none),
            (:(=), (:call, (:$, :sym), (:(::), :x, :Char)), (:block,
                (:line, 490, :none),
                (:call, (:$, :sym), (:call, :unsigned, :x), 1, false)
              )),
            (:line, 491, :none),
            (:(=), (:call, (:$, :sym), (:(::), :x, :Integer), (:(::), :p, :Int)), (:block,
                (:line, 491, :none),
                (:call, (:$, :sym), (:call, :unsigned, (:call, :abs, :x)), :p, (:call, :<, :x, 0))
              )),
            (:line, 492, :none),
            (:(=), (:call, (:$, :sym), (:(::), :x, :Integer)), (:block,
                (:line, 492, :none),
                (:call, (:$, :sym), (:call, :unsigned, (:call, :abs, :x)), 1, (:call, :<, :x, 0))
              ))
          ))
      )),
    (:line, 496, :none),
    (:macrocall, :(Core.@doc), "    bin(n, pad::Int=1)\n\nConvert an integer to a binary string, optionally specifying a number of digits to pad to.\n\n```jldoctest\njulia> bin(10,2)\n\"1010\"\n\njulia> bin(10,8)\n\"00001010\"\n```\n", :bin),
    (:line, 511, :none),
    (:macrocall, :(Core.@doc), "    hex(n, pad::Int=1)\n\nConvert an integer to a hexadecimal string, optionally specifying a number of digits to pad to.\n", :hex),
    (:line, 518, :none),
    (:macrocall, :(Core.@doc), "    oct(n, pad::Int=1)\n\nConvert an integer to an octal string, optionally specifying a number of digits to pad to.\n", :oct),
    (:line, 525, :none),
    (:macrocall, :(Core.@doc), "    dec(n, pad::Int=1)\n\nConvert an integer to a decimal string, optionally specifying a number of digits to pad to.\n", :dec),
    (:line, 532, :none),
    (:(=), (:call, :bits, (:(::), :x, (:curly, :Union, :Bool, :Int8, :UInt8))), (:block,
        (:line, 532, :none),
        (:call, :bin, (:call, :reinterpret, :UInt8, :x), 8)
      )),
    (:line, 533, :none),
    (:(=), (:call, :bits, (:(::), :x, (:curly, :Union, :Int16, :UInt16, :Float16))), (:block,
        (:line, 533, :none),
        (:call, :bin, (:call, :reinterpret, :UInt16, :x), 16)
      )),
    (:line, 534, :none),
    (:(=), (:call, :bits, (:(::), :x, (:curly, :Union, :Char, :Int32, :UInt32, :Float32))), (:block,
        (:line, 534, :none),
        (:call, :bin, (:call, :reinterpret, :UInt32, :x), 32)
      )),
    (:line, 535, :none),
    (:(=), (:call, :bits, (:(::), :x, (:curly, :Union, :Int64, :UInt64, :Float64))), (:block,
        (:line, 535, :none),
        (:call, :bin, (:call, :reinterpret, :UInt64, :x), 64)
      )),
    (:line, 536, :none),
    (:(=), (:call, :bits, (:(::), :x, (:curly, :Union, :Int128, :UInt128))), (:block,
        (:line, 536, :none),
        (:call, :bin, (:call, :reinterpret, :UInt128, :x), 128)
      )),
    (:line, 538, :none),
    (:macrocall, :(Core.@doc), "    digits([T<:Integer], n::Integer, base::T=10, pad::Integer=1)\n\nReturns an array with element type `T` (default `Int`) of the digits of `n` in the given\nbase, optionally padded with zeros to a specified size. More significant digits are at\nhigher indexes, such that `n == sum([digits[k]*base^(k-1) for k=1:length(digits)])`.\n", (:(=), (:where, (:call, :digits, (:(::), :n, :Integer), (:kw, (:(::), :base, :T), 10), (:kw, (:(::), :pad, :Integer), 1)), (:<:, :T, :Integer)), (:block,
          (:line, 545, :none),
          (:call, :digits, :T, :n, :base, :pad)
        ))),
    (:line, 547, :none),
    (:function, (:where, (:call, :digits, (:(::), (:curly, :Type, :T)), (:(::), :n, :Integer), (:kw, (:(::), :base, :Integer), 10), (:kw, (:(::), :pad, :Integer), 1)), (:<:, :T, :Integer)), (:block,
        (:line, 548, :none),
        (:||, (:call, :(<=), 2, :base), (:call, :throw, (:call, :ArgumentError, (:string, "base must be ≥ 2, got ", :base)))),
        (:line, 549, :none),
        (:call, :digits!, (:call, :zeros, :T, (:call, :max, :pad, (:call, :ndigits0z, :n, :base))), :n, :base)
      )),
    (:line, 552, :none),
    (:macrocall, :(Core.@doc), "    digits!(array, n::Integer, base::Integer=10)\n\nFills an array of the digits of `n` in the given base. More significant digits are at higher\nindexes. If the array length is insufficient, the least significant digits are filled up to\nthe array length. If the array length is excessive, the excess portion is filled with zeros.\n", (:function, (:where, (:call, :digits!, (:(::), :a, (:curly, :AbstractArray, :T, 1)), (:(::), :n, :Integer), (:kw, (:(::), :base, :Integer), 10)), (:<:, :T, :Integer)), (:block,
          (:line, 560, :none),
          (:||, (:call, :(<=), 2, :base), (:call, :throw, (:call, :ArgumentError, (:string, "base must be ≥ 2, got ", :base)))),
          (:line, 561, :none),
          (:||, (:call, :(<=), (:call, :-, :base, 1), (:call, :typemax, :T)), (:call, :throw, (:call, :ArgumentError, (:string, "type ", :T, " too small for base ", :base)))),
          (:line, 562, :none),
          (:for, (:(=), :i, (:call, :eachindex, :a)), (:block,
              (:line, 563, :none),
              (:(=), (:ref, :a, :i), (:call, :rem, :n, :base)),
              (:line, 564, :none),
              (:(=), :n, (:call, :div, :n, :base))
            )),
          (:line, 566, :none),
          (:return, :a)
        ))),
    (:line, 569, :none),
    (:macrocall, :(Core.@doc), "    isqrt(n::Integer)\n\nInteger square root: the largest integer `m` such that `m*m <= n`.\n\n```jldoctest\njulia> isqrt(5)\n2\n```\n", (:(=), (:call, :isqrt, (:(::), :x, :Integer)), (:block,
          (:line, 579, :none),
          (:call, :oftype, :x, (:call, :trunc, (:call, :sqrt, :x)))
        ))),
    (:line, 581, :none),
    (:function, (:call, :isqrt, (:(::), :x, (:curly, :Union, :Int64, :UInt64, :Int128, :UInt128))), (:block,
        (:line, 582, :none),
        (:&&, (:call, :(==), :x, 0), (:return, :x)),
        (:line, 583, :none),
        (:(=), :s, (:call, :oftype, :x, (:call, :trunc, (:call, :sqrt, :x)))),
        (:line, 586, :none),
        (:(=), :s, (:call, :>>, (:call, :+, :s, (:call, :div, :x, :s)), 1)),
        (:line, 587, :none),
        (:if, (:call, :>, (:call, :*, :s, :s), :x), (:call, :-, :s, 1), :s)
      )),
    (:line, 590, :none),
    (:function, (:call, :factorial, (:(::), :n, :Integer)), (:block,
        (:line, 591, :none),
        (:&&, (:call, :<, :n, 0), (:call, :throw, (:call, :DomainError))),
        (:line, 592, :none),
        (:local, (:(::), :f, (:call, :typeof, (:call, :*, :n, :n))), (:(::), :i, (:call, :typeof, (:call, :*, :n, :n)))),
        (:line, 593, :none),
        (:(=), :f, 1),
        (:line, 594, :none),
        (:for, (:(=), :i, (:(:), 2, :n)), (:block,
            (:line, 595, :none),
            (:*=, :f, :i)
          )),
        (:line, 597, :none),
        (:return, :f)
      )),
    (:line, 600, :none),
    (:macrocall, :(Core.@doc), "    binomial(n,k)\n\nNumber of ways to choose `k` out of `n` items.\n", (:function, (:where, (:call, :binomial, (:(::), :n, :T), (:(::), :k, :T)), (:<:, :T, :Integer)), (:block,
          (:line, 606, :none),
          (:&&, (:call, :<, :k, 0), (:return, (:call, :zero, :T))),
          (:line, 607, :none),
          (:(=), :sgn, (:call, :one, :T)),
          (:line, 608, :none),
          (:if, (:call, :<, :n, 0), (:block,
              (:line, 609, :none),
              (:(=), :n, (:call, :-, (:call, :+, (:call, :-, :n), :k), 1)),
              (:line, 610, :none),
              (:if, (:call, :isodd, :k), (:block,
                  (:line, 611, :none),
                  (:(=), :sgn, (:call, :-, :sgn))
                ))
            )),
          (:line, 614, :none),
          (:&&, (:call, :>, :k, :n), (:return, (:call, :zero, :T))),
          (:line, 615, :none),
          (:&&, (:||, (:call, :(==), :k, 0), (:call, :(==), :k, :n)), (:return, :sgn)),
          (:line, 616, :none),
          (:&&, (:call, :(==), :k, 1), (:return, (:call, :*, :sgn, :n))),
          (:line, 617, :none),
          (:if, (:call, :>, :k, (:call, :>>, :n, 1)), (:block,
              (:line, 618, :none),
              (:(=), :k, (:call, :-, :n, :k))
            )),
          (:line, 620, :none),
          (:(=), (:(::), :x, :T), (:(=), :nn, (:call, :+, (:call, :-, :n, :k), 1))),
          (:line, 621, :none),
          (:+=, :nn, 1),
          (:line, 622, :none),
          (:(=), :rr, 2),
          (:line, 623, :none),
          (:while, (:call, :(<=), :rr, :k), (:block,
              (:line, 624, :none),
              (:(=), :xt, (:call, :div, (:call, :widemul, :x, :nn), :rr)),
              (:line, 625, :none),
              (:(=), :x, :xt),
              (:line, 626, :none),
              (:||, (:call, :(==), :x, :xt), (:call, :throw, (:call, :OverflowError))),
              (:line, 627, :none),
              (:+=, :rr, 1),
              (:line, 628, :none),
              (:+=, :nn, 1)
            )),
          (:line, 630, :none),
          (:call, :convert, :T, (:call, :copysign, :x, :sgn))
        )))
  ))